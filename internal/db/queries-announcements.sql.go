// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-announcements.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const demoteAnnouncement = `-- name: DemoteAnnouncement :exec
DELETE FROM site_announcements WHERE id = ?
`

// admin task
func (q *Queries) DemoteAnnouncement(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, demoteAnnouncement, id)
	return err
}

const getActiveAnnouncementWithNewsForViewer = `-- name: GetActiveAnnouncementWithNewsForViewer :one
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT a.id, n.idsiteNews, n.news
FROM site_announcements a
JOIN site_news n ON n.idsiteNews = a.site_news_id
WHERE a.active = 1
  AND (
      n.language_idlanguage = 0
      OR n.language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = n.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='news'
        AND g.item='post'
        AND g.action='view'
        AND g.active=1
        AND g.item_id = n.idsiteNews
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY a.created_at DESC
LIMIT 1
`

type GetActiveAnnouncementWithNewsForViewerParams struct {
	ViewerID int32
	UserID   sql.NullInt32
}

type GetActiveAnnouncementWithNewsForViewerRow struct {
	ID         int32
	Idsitenews int32
	News       sql.NullString
}

func (q *Queries) GetActiveAnnouncementWithNewsForViewer(ctx context.Context, arg GetActiveAnnouncementWithNewsForViewerParams) (*GetActiveAnnouncementWithNewsForViewerRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveAnnouncementWithNewsForViewer,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerID,
		arg.UserID,
	)
	var i GetActiveAnnouncementWithNewsForViewerRow
	err := row.Scan(&i.ID, &i.Idsitenews, &i.News)
	return &i, err
}

const getLatestAnnouncementByNewsID = `-- name: GetLatestAnnouncementByNewsID :one
SELECT id, site_news_id, active, created_at
FROM site_announcements
WHERE site_news_id = ?
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestAnnouncementByNewsID(ctx context.Context, siteNewsID int32) (*SiteAnnouncement, error) {
	row := q.db.QueryRowContext(ctx, getLatestAnnouncementByNewsID, siteNewsID)
	var i SiteAnnouncement
	err := row.Scan(
		&i.ID,
		&i.SiteNewsID,
		&i.Active,
		&i.CreatedAt,
	)
	return &i, err
}

const listAnnouncementsWithNewsForAdmin = `-- name: ListAnnouncementsWithNewsForAdmin :many
SELECT a.id, a.site_news_id, a.active, a.created_at, n.news
FROM site_announcements a
JOIN site_news n ON n.idsiteNews = a.site_news_id
ORDER BY a.created_at DESC
`

type ListAnnouncementsWithNewsForAdminRow struct {
	ID         int32
	SiteNewsID int32
	Active     bool
	CreatedAt  time.Time
	News       sql.NullString
}

// admin task
func (q *Queries) ListAnnouncementsWithNewsForAdmin(ctx context.Context) ([]*ListAnnouncementsWithNewsForAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, listAnnouncementsWithNewsForAdmin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListAnnouncementsWithNewsForAdminRow
	for rows.Next() {
		var i ListAnnouncementsWithNewsForAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.SiteNewsID,
			&i.Active,
			&i.CreatedAt,
			&i.News,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const promoteAnnouncement = `-- name: PromoteAnnouncement :exec
INSERT INTO site_announcements (site_news_id)
VALUES (?)
`

// admin task
func (q *Queries) PromoteAnnouncement(ctx context.Context, siteNewsID int32) error {
	_, err := q.db.ExecContext(ctx, promoteAnnouncement, siteNewsID)
	return err
}

const setAnnouncementActive = `-- name: SetAnnouncementActive :exec
UPDATE site_announcements SET active = ? WHERE id = ?
`

type SetAnnouncementActiveParams struct {
	Active bool
	ID     int32
}

func (q *Queries) SetAnnouncementActive(ctx context.Context, arg SetAnnouncementActiveParams) error {
	_, err := q.db.ExecContext(ctx, setAnnouncementActive, arg.Active, arg.ID)
	return err
}
