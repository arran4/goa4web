// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries-announcements.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const adminDemoteAnnouncement = `-- name: AdminDemoteAnnouncement :exec
DELETE FROM site_announcements WHERE id = ?
`

// admin task
func (q *Queries) AdminDemoteAnnouncement(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, adminDemoteAnnouncement, id)
	return err
}

const adminListAnnouncementsWithNews = `-- name: AdminListAnnouncementsWithNews :many
SELECT a.id, a.site_news_id, a.active, a.created_at, n.news
FROM site_announcements a
JOIN site_news n ON n.idsiteNews = a.site_news_id
ORDER BY a.created_at DESC
`

type AdminListAnnouncementsWithNewsRow struct {
	ID         int32
	SiteNewsID int32
	Active     bool
	CreatedAt  time.Time
	News       sql.NullString
}

// admin task
func (q *Queries) AdminListAnnouncementsWithNews(ctx context.Context) ([]*AdminListAnnouncementsWithNewsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListAnnouncementsWithNews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListAnnouncementsWithNewsRow
	for rows.Next() {
		var i AdminListAnnouncementsWithNewsRow
		if err := rows.Scan(
			&i.ID,
			&i.SiteNewsID,
			&i.Active,
			&i.CreatedAt,
			&i.News,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminPromoteAnnouncement = `-- name: AdminPromoteAnnouncement :exec
INSERT INTO site_announcements (site_news_id)
VALUES (?)
`

// admin task
func (q *Queries) AdminPromoteAnnouncement(ctx context.Context, siteNewsID int32) error {
	_, err := q.db.ExecContext(ctx, adminPromoteAnnouncement, siteNewsID)
	return err
}

const adminSetAnnouncementActive = `-- name: AdminSetAnnouncementActive :exec
UPDATE site_announcements SET active = ? WHERE id = ?
`

type AdminSetAnnouncementActiveParams struct {
	Active bool
	ID     int32
}

func (q *Queries) AdminSetAnnouncementActive(ctx context.Context, arg AdminSetAnnouncementActiveParams) error {
	_, err := q.db.ExecContext(ctx, adminSetAnnouncementActive, arg.Active, arg.ID)
	return err
}

const getActiveAnnouncementWithNewsForLister = `-- name: GetActiveAnnouncementWithNewsForLister :one
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT a.id, n.idsiteNews, n.news
FROM site_announcements a
JOIN site_news n ON n.idsiteNews = a.site_news_id
WHERE a.active = 1
  AND (
      NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
      OR n.language_id = 0
      OR n.language_id IS NULL
      OR n.language_id IN (
          SELECT ul.language_id
          FROM user_language ul
          WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='news'
        AND (g.item='post' OR g.item IS NULL)
        AND g.action='view'
        AND g.active=1
        AND (g.item_id = n.idsiteNews OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY a.created_at DESC
LIMIT 1
`

type GetActiveAnnouncementWithNewsForListerParams struct {
	ListerID int32
	UserID   sql.NullInt32
}

type GetActiveAnnouncementWithNewsForListerRow struct {
	ID         int32
	Idsitenews int32
	News       sql.NullString
}

func (q *Queries) GetActiveAnnouncementWithNewsForLister(ctx context.Context, arg GetActiveAnnouncementWithNewsForListerParams) (*GetActiveAnnouncementWithNewsForListerRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveAnnouncementWithNewsForLister,
		arg.ListerID,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
	)
	var i GetActiveAnnouncementWithNewsForListerRow
	err := row.Scan(&i.ID, &i.Idsitenews, &i.News)
	return &i, err
}

const getLatestAnnouncementByNewsID = `-- name: GetLatestAnnouncementByNewsID :one
SELECT id, site_news_id, active, created_at
FROM site_announcements
WHERE site_news_id = ?
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestAnnouncementByNewsID(ctx context.Context, siteNewsID int32) (*SiteAnnouncement, error) {
	row := q.db.QueryRowContext(ctx, getLatestAnnouncementByNewsID, siteNewsID)
	var i SiteAnnouncement
	err := row.Scan(
		&i.ID,
		&i.SiteNewsID,
		&i.Active,
		&i.CreatedAt,
	)
	return &i, err
}
