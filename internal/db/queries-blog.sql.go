// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-blog.sql

package db

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const assignThreadIdToBlogEntry = `-- name: AssignThreadIdToBlogEntry :exec
UPDATE blogs
SET forumthread_id = ?
WHERE idblogs = ?
`

type AssignThreadIdToBlogEntryParams struct {
	ForumthreadID sql.NullInt32
	Idblogs       int32
}

func (q *Queries) AssignThreadIdToBlogEntry(ctx context.Context, arg AssignThreadIdToBlogEntryParams) error {
	_, err := q.db.ExecContext(ctx, assignThreadIdToBlogEntry, arg.ForumthreadID, arg.Idblogs)
	return err
}

const blogsSearchFirst = `-- name: BlogsSearchFirst :many
SELECT DISTINCT cs.blog_id
FROM blogs_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
`

func (q *Queries) BlogsSearchFirst(ctx context.Context, word sql.NullString) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, blogsSearchFirst, word)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var blog_id int32
		if err := rows.Scan(&blog_id); err != nil {
			return nil, err
		}
		items = append(items, blog_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const blogsSearchNext = `-- name: BlogsSearchNext :many
SELECT DISTINCT cs.blog_id
FROM blogs_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
AND cs.blog_id IN (/*SLICE:ids*/?)
`

type BlogsSearchNextParams struct {
	Word sql.NullString
	Ids  []int32
}

func (q *Queries) BlogsSearchNext(ctx context.Context, arg BlogsSearchNextParams) ([]int32, error) {
	query := blogsSearchNext
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var blog_id int32
		if err := rows.Scan(&blog_id); err != nil {
			return nil, err
		}
		items = append(items, blog_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createBlogEntry = `-- name: CreateBlogEntry :execlastid
INSERT INTO blogs (users_idusers, language_idlanguage, blog, written)
SELECT ?, ?, ?, CURRENT_TIMESTAMP
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'blogs'
      AND g.item = 'entry'
      AND g.action = 'post'
      AND g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
)
`

type CreateBlogEntryParams struct {
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
	UserID             sql.NullInt32
	ViewerID           int32
}

func (q *Queries) CreateBlogEntry(ctx context.Context, arg CreateBlogEntryParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createBlogEntry,
		arg.UsersIdusers,
		arg.LanguageIdlanguage,
		arg.Blog,
		arg.UserID,
		arg.ViewerID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const getAllBlogEntriesByUser = `-- name: GetAllBlogEntriesByUser :many
SELECT b.idblogs, b.forumthread_id, b.users_idusers, b.language_idlanguage, b.blog, b.written, u.username, coalesce(th.comments, 0)
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_id = th.idforumthread
WHERE b.users_idusers = ?
ORDER BY b.written DESC
`

type GetAllBlogEntriesByUserRow struct {
	Idblogs            int32
	ForumthreadID      sql.NullInt32
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
	Written            time.Time
	Username           sql.NullString
	Comments           int32
}

func (q *Queries) GetAllBlogEntriesByUser(ctx context.Context, usersIdusers int32) ([]*GetAllBlogEntriesByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllBlogEntriesByUser, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllBlogEntriesByUserRow
	for rows.Next() {
		var i GetAllBlogEntriesByUserRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllBlogsForIndex = `-- name: GetAllBlogsForIndex :many
SELECT idblogs, blog FROM blogs WHERE deleted_at IS NULL
`

type GetAllBlogsForIndexRow struct {
	Idblogs int32
	Blog    sql.NullString
}

func (q *Queries) GetAllBlogsForIndex(ctx context.Context) ([]*GetAllBlogsForIndexRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllBlogsForIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllBlogsForIndexRow
	for rows.Next() {
		var i GetAllBlogsForIndexRow
		if err := rows.Scan(&i.Idblogs, &i.Blog); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlogEntriesByAuthorForUserDescendingLanguages = `-- name: GetBlogEntriesByAuthorForUserDescendingLanguages :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT b.idblogs, b.forumthread_id, b.users_idusers, b.language_idlanguage, b.blog, b.written, u.username, coalesce(th.comments, 0),
       b.users_idusers = ? AS is_owner
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_id = th.idforumthread
WHERE (b.users_idusers = ? OR ? = 0)
AND (
    b.language_idlanguage = 0
    OR b.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = b.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'blogs'
      AND g.item = 'entry'
      AND g.action = 'see'
      AND g.active = 1
      AND g.item_id = b.idblogs
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
ORDER BY b.written DESC
LIMIT ? OFFSET ?
`

type GetBlogEntriesByAuthorForUserDescendingLanguagesParams struct {
	ViewerID int32
	AuthorID int32
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type GetBlogEntriesByAuthorForUserDescendingLanguagesRow struct {
	Idblogs            int32
	ForumthreadID      sql.NullInt32
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
	Written            time.Time
	Username           sql.NullString
	Comments           int32
	IsOwner            bool
}

func (q *Queries) GetBlogEntriesByAuthorForUserDescendingLanguages(ctx context.Context, arg GetBlogEntriesByAuthorForUserDescendingLanguagesParams) ([]*GetBlogEntriesByAuthorForUserDescendingLanguagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getBlogEntriesByAuthorForUserDescendingLanguages,
		arg.ViewerID,
		arg.ViewerID,
		arg.AuthorID,
		arg.AuthorID,
		arg.ViewerID,
		arg.ViewerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetBlogEntriesByAuthorForUserDescendingLanguagesRow
	for rows.Next() {
		var i GetBlogEntriesByAuthorForUserDescendingLanguagesRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Comments,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlogEntriesByIdsDescending = `-- name: GetBlogEntriesByIdsDescending :many
SELECT b.idblogs, b.forumthread_id, b.users_idusers, b.language_idlanguage, b.blog, b.written
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_id = th.idforumthread
WHERE b.idblogs IN (/*SLICE:blogids*/?)
ORDER BY b.written DESC
`

type GetBlogEntriesByIdsDescendingRow struct {
	Idblogs            int32
	ForumthreadID      sql.NullInt32
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
	Written            time.Time
}

func (q *Queries) GetBlogEntriesByIdsDescending(ctx context.Context, blogids []int32) ([]*GetBlogEntriesByIdsDescendingRow, error) {
	query := getBlogEntriesByIdsDescending
	var queryParams []interface{}
	if len(blogids) > 0 {
		for _, v := range blogids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:blogids*/?", strings.Repeat(",?", len(blogids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:blogids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetBlogEntriesByIdsDescendingRow
	for rows.Next() {
		var i GetBlogEntriesByIdsDescendingRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Blog,
			&i.Written,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlogEntriesForViewerDescending = `-- name: GetBlogEntriesForViewerDescending :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT b.idblogs, b.forumthread_id, b.users_idusers, b.language_idlanguage, b.blog, b.written, u.username, coalesce(th.comments, 0),
       b.users_idusers = ? AS is_owner
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_id = th.idforumthread
WHERE (
    b.language_idlanguage = 0
    OR b.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = b.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'blogs'
      AND g.item = 'entry'
      AND g.action = 'see'
      AND g.active = 1
      AND g.item_id = b.idblogs
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
ORDER BY b.written DESC
LIMIT ? OFFSET ?
`

type GetBlogEntriesForViewerDescendingParams struct {
	ViewerID int32
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type GetBlogEntriesForViewerDescendingRow struct {
	Idblogs            int32
	ForumthreadID      sql.NullInt32
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
	Written            time.Time
	Username           sql.NullString
	Comments           int32
	IsOwner            bool
}

func (q *Queries) GetBlogEntriesForViewerDescending(ctx context.Context, arg GetBlogEntriesForViewerDescendingParams) ([]*GetBlogEntriesForViewerDescendingRow, error) {
	rows, err := q.db.QueryContext(ctx, getBlogEntriesForViewerDescending,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetBlogEntriesForViewerDescendingRow
	for rows.Next() {
		var i GetBlogEntriesForViewerDescendingRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Comments,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlogEntryForUserById = `-- name: GetBlogEntryForUserById :one
SELECT b.idblogs, b.forumthread_id, b.users_idusers, b.language_idlanguage, b.blog, b.written, u.username, coalesce(th.comments, 0),
       b.users_idusers = ? AS is_owner
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_id = th.idforumthread
WHERE b.idblogs = ?
LIMIT 1
`

type GetBlogEntryForUserByIdParams struct {
	ViewerIdusers int32
	ID            int32
}

type GetBlogEntryForUserByIdRow struct {
	Idblogs            int32
	ForumthreadID      sql.NullInt32
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
	Written            time.Time
	Username           sql.NullString
	Comments           int32
	IsOwner            bool
}

func (q *Queries) GetBlogEntryForUserById(ctx context.Context, arg GetBlogEntryForUserByIdParams) (*GetBlogEntryForUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getBlogEntryForUserById, arg.ViewerIdusers, arg.ID)
	var i GetBlogEntryForUserByIdRow
	err := row.Scan(
		&i.Idblogs,
		&i.ForumthreadID,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Blog,
		&i.Written,
		&i.Username,
		&i.Comments,
		&i.IsOwner,
	)
	return &i, err
}

const getCountOfBlogPostsByUser = `-- name: GetCountOfBlogPostsByUser :many
SELECT u.username, COUNT(b.idblogs)
FROM blogs b, users u
WHERE b.users_idusers = u.idusers
GROUP BY u.idusers
`

type GetCountOfBlogPostsByUserRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) GetCountOfBlogPostsByUser(ctx context.Context) ([]*GetCountOfBlogPostsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getCountOfBlogPostsByUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCountOfBlogPostsByUserRow
	for rows.Next() {
		var i GetCountOfBlogPostsByUserRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBloggersForViewer = `-- name: ListBloggersForViewer :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT u.username, COUNT(b.idblogs) AS count
FROM blogs b
JOIN users u ON b.users_idusers = u.idusers
WHERE (
    b.language_idlanguage = 0
    OR b.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = b.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'blogs'
      AND g.item = 'entry'
      AND g.action = 'see'
      AND g.active = 1
      AND g.item_id = b.idblogs
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
GROUP BY u.idusers
ORDER BY u.username
LIMIT ? OFFSET ?
`

type ListBloggersForViewerParams struct {
	ViewerID int32
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type ListBloggersForViewerRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) ListBloggersForViewer(ctx context.Context, arg ListBloggersForViewerParams) ([]*ListBloggersForViewerRow, error) {
	rows, err := q.db.QueryContext(ctx, listBloggersForViewer,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListBloggersForViewerRow
	for rows.Next() {
		var i ListBloggersForViewerRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBloggersForViewer = `-- name: SearchBloggersForViewer :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT u.username, COUNT(b.idblogs) AS count
FROM blogs b
JOIN users u ON b.users_idusers = u.idusers
WHERE (LOWER(u.username) LIKE LOWER(?) OR LOWER((SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1)) LIKE LOWER(?))
  AND (
    b.language_idlanguage = 0
    OR b.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = b.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'blogs'
      AND g.item = 'entry'
      AND g.action = 'see'
      AND g.active = 1
      AND g.item_id = b.idblogs
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
GROUP BY u.idusers
ORDER BY u.username
LIMIT ? OFFSET ?
`

type SearchBloggersForViewerParams struct {
	ViewerID int32
	Query    string
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type SearchBloggersForViewerRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) SearchBloggersForViewer(ctx context.Context, arg SearchBloggersForViewerParams) ([]*SearchBloggersForViewerRow, error) {
	rows, err := q.db.QueryContext(ctx, searchBloggersForViewer,
		arg.ViewerID,
		arg.Query,
		arg.Query,
		arg.ViewerID,
		arg.ViewerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchBloggersForViewerRow
	for rows.Next() {
		var i SearchBloggersForViewerRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setBlogLastIndex = `-- name: SetBlogLastIndex :exec
UPDATE blogs SET last_index = NOW() WHERE idblogs = ?
`

func (q *Queries) SetBlogLastIndex(ctx context.Context, idblogs int32) error {
	_, err := q.db.ExecContext(ctx, setBlogLastIndex, idblogs)
	return err
}

const updateBlogEntry = `-- name: UpdateBlogEntry :exec
UPDATE blogs
SET language_idlanguage = ?, blog = ?
WHERE idblogs = ?
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section = 'blogs'
        AND g.item = 'entry'
        AND g.action = 'post'
        AND g.active = 1
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (
            SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
        ))
  )
`

type UpdateBlogEntryParams struct {
	LanguageIdlanguage int32
	Blog               sql.NullString
	Idblogs            int32
	UserID             sql.NullInt32
	ViewerID           int32
}

func (q *Queries) UpdateBlogEntry(ctx context.Context, arg UpdateBlogEntryParams) error {
	_, err := q.db.ExecContext(ctx, updateBlogEntry,
		arg.LanguageIdlanguage,
		arg.Blog,
		arg.Idblogs,
		arg.UserID,
		arg.ViewerID,
	)
	return err
}
