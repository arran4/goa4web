// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries-blog.sql

package db

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const adminGetAllBlogEntriesByUser = `-- name: AdminGetAllBlogEntriesByUser :many
SELECT b.idblogs,
       b.forumthread_id,
       b.users_idusers,
       b.language_id,
       b.blog,
       b.written,
       b.timezone,
       u.username,
       coalesce(th.comments, 0),
       fc.idforumcategory,
       fc.title AS forumcategory_title
FROM blogs b
LEFT JOIN users u ON b.users_idusers = u.idusers
LEFT JOIN forumthread th ON b.forumthread_id = th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic = t.idforumtopic
LEFT JOIN forumcategory fc ON t.forumcategory_idforumcategory = fc.idforumcategory
WHERE b.users_idusers = ?
ORDER BY b.written DESC
`

type AdminGetAllBlogEntriesByUserRow struct {
	Idblogs            int32
	ForumthreadID      sql.NullInt32
	UsersIdusers       int32
	LanguageID         sql.NullInt32
	Blog               sql.NullString
	Written            time.Time
	Timezone           sql.NullString
	Username           sql.NullString
	Comments           int32
	Idforumcategory    sql.NullInt32
	ForumcategoryTitle sql.NullString
}

func (q *Queries) AdminGetAllBlogEntriesByUser(ctx context.Context, authorID int32) ([]*AdminGetAllBlogEntriesByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetAllBlogEntriesByUser, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminGetAllBlogEntriesByUserRow
	for rows.Next() {
		var i AdminGetAllBlogEntriesByUserRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageID,
			&i.Blog,
			&i.Written,
			&i.Timezone,
			&i.Username,
			&i.Comments,
			&i.Idforumcategory,
			&i.ForumcategoryTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createBlogEntryForWriter = `-- name: CreateBlogEntryForWriter :execlastid
INSERT INTO blogs (users_idusers, language_id, blog, written, timezone)
SELECT ?, ?, ?, ?, ?
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'blogs'
      AND (g.item = 'entry' OR g.item IS NULL)
      AND g.action = 'post'
      AND g.active = 1
      AND (g.item_id = 0 OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
)
`

type CreateBlogEntryForWriterParams struct {
	UsersIdusers int32
	LanguageID   sql.NullInt32
	Blog         sql.NullString
	Written      time.Time
	Timezone     sql.NullString
	UserID       sql.NullInt32
	ListerID     int32
}

func (q *Queries) CreateBlogEntryForWriter(ctx context.Context, arg CreateBlogEntryForWriterParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createBlogEntryForWriter,
		arg.UsersIdusers,
		arg.LanguageID,
		arg.Blog,
		arg.Written,
		arg.Timezone,
		arg.UserID,
		arg.ListerID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const getBlogEntryForListerByID = `-- name: GetBlogEntryForListerByID :one
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT id FROM roles WHERE name = 'anyone'
)
SELECT b.idblogs, b.forumthread_id, b.users_idusers, b.language_id, b.blog, b.written, b.timezone, u.username, coalesce(th.comments, 0),
       b.users_idusers = ? AS is_owner,
       SUBSTRING_INDEX(b.blog, '\n', 1) as title
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_id = th.idforumthread
WHERE b.idblogs = ?
  AND (
      b.language_id = 0
      OR b.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = b.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section = 'blogs'
        AND (g.item = 'entry' OR g.item IS NULL)
        AND g.action = 'see'
        AND g.active = 1
        AND (g.item_id = b.idblogs OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
LIMIT 1
`

type GetBlogEntryForListerByIDParams struct {
	ListerID int32
	ID       int32
	UserID   sql.NullInt32
}

type GetBlogEntryForListerByIDRow struct {
	Idblogs       int32
	ForumthreadID sql.NullInt32
	UsersIdusers  int32
	LanguageID    sql.NullInt32
	Blog          sql.NullString
	Written       time.Time
	Timezone      sql.NullString
	Username      sql.NullString
	Comments      int32
	IsOwner       bool
	Title         string
}

func (q *Queries) GetBlogEntryForListerByID(ctx context.Context, arg GetBlogEntryForListerByIDParams) (*GetBlogEntryForListerByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getBlogEntryForListerByID,
		arg.ListerID,
		arg.ListerID,
		arg.ID,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
	)
	var i GetBlogEntryForListerByIDRow
	err := row.Scan(
		&i.Idblogs,
		&i.ForumthreadID,
		&i.UsersIdusers,
		&i.LanguageID,
		&i.Blog,
		&i.Written,
		&i.Timezone,
		&i.Username,
		&i.Comments,
		&i.IsOwner,
		&i.Title,
	)
	return &i, err
}

const listBlogEntriesByAuthorForLister = `-- name: ListBlogEntriesByAuthorForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT id FROM roles WHERE name = 'anyone'
)
SELECT b.idblogs, b.forumthread_id, b.users_idusers, b.language_id, b.blog, b.written, b.timezone, u.username, coalesce(th.comments, 0),
       b.users_idusers = ? AS is_owner,
       SUBSTRING_INDEX(b.blog, '\n', 1) as title
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_id = th.idforumthread
WHERE (b.users_idusers = ? OR ? = 0)
AND (
    b.language_id = 0
    OR b.language_id IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_id = b.language_id
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
AND (
    ? = true
    OR EXISTS (
        SELECT 1 FROM grants g
        WHERE g.section = 'blogs'
          AND (g.item = 'entry' OR g.item IS NULL)
          AND g.action = 'see'
          AND g.active = 1
          AND (g.item_id = b.idblogs OR g.item_id IS NULL)
          AND (g.user_id = ? OR g.user_id IS NULL)
          AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
    )
)
ORDER BY b.written DESC
LIMIT ? OFFSET ?
`

type ListBlogEntriesByAuthorForListerParams struct {
	ListerID int32
	AuthorID int32
	IsAdmin  interface{}
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type ListBlogEntriesByAuthorForListerRow struct {
	Idblogs       int32
	ForumthreadID sql.NullInt32
	UsersIdusers  int32
	LanguageID    sql.NullInt32
	Blog          sql.NullString
	Written       time.Time
	Timezone      sql.NullString
	Username      sql.NullString
	Comments      int32
	IsOwner       bool
	Title         string
}

func (q *Queries) ListBlogEntriesByAuthorForLister(ctx context.Context, arg ListBlogEntriesByAuthorForListerParams) ([]*ListBlogEntriesByAuthorForListerRow, error) {
	rows, err := q.db.QueryContext(ctx, listBlogEntriesByAuthorForLister,
		arg.ListerID,
		arg.ListerID,
		arg.AuthorID,
		arg.AuthorID,
		arg.ListerID,
		arg.ListerID,
		arg.IsAdmin,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListBlogEntriesByAuthorForListerRow
	for rows.Next() {
		var i ListBlogEntriesByAuthorForListerRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageID,
			&i.Blog,
			&i.Written,
			&i.Timezone,
			&i.Username,
			&i.Comments,
			&i.IsOwner,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBlogEntriesByIDsForLister = `-- name: ListBlogEntriesByIDsForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT id FROM roles WHERE name = 'anyone'
)
SELECT b.idblogs, b.forumthread_id, b.users_idusers, b.language_id, b.blog, b.written, b.timezone
FROM blogs b
WHERE b.idblogs IN (/*SLICE:blogids*/?)
  AND (
      b.language_id = 0
      OR b.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = b.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section = 'blogs'
        AND (g.item = 'entry' OR g.item IS NULL)
        AND g.action = 'see'
        AND g.active = 1
        AND (g.item_id = b.idblogs OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY b.written DESC
LIMIT ? OFFSET ?
`

type ListBlogEntriesByIDsForListerParams struct {
	ListerID int32
	Blogids  []int32
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type ListBlogEntriesByIDsForListerRow struct {
	Idblogs       int32
	ForumthreadID sql.NullInt32
	UsersIdusers  int32
	LanguageID    sql.NullInt32
	Blog          sql.NullString
	Written       time.Time
	Timezone      sql.NullString
}

func (q *Queries) ListBlogEntriesByIDsForLister(ctx context.Context, arg ListBlogEntriesByIDsForListerParams) ([]*ListBlogEntriesByIDsForListerRow, error) {
	query := listBlogEntriesByIDsForLister
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ListerID)
	if len(arg.Blogids) > 0 {
		for _, v := range arg.Blogids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:blogids*/?", strings.Repeat(",?", len(arg.Blogids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:blogids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.UserID)
	queryParams = append(queryParams, arg.Limit)
	queryParams = append(queryParams, arg.Offset)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListBlogEntriesByIDsForListerRow
	for rows.Next() {
		var i ListBlogEntriesByIDsForListerRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageID,
			&i.Blog,
			&i.Written,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBlogEntriesForLister = `-- name: ListBlogEntriesForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT id FROM roles WHERE name = 'anyone'
)
SELECT b.idblogs, b.forumthread_id, b.users_idusers, b.language_id, b.blog, b.written, b.timezone, u.username, coalesce(th.comments, 0),
       b.users_idusers = ? AS is_owner
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_id = th.idforumthread
WHERE (
    b.language_id = 0
    OR b.language_id IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_id = b.language_id
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
AND (
    ? = true
    OR EXISTS (
        SELECT 1 FROM grants g
        WHERE g.section = 'blogs'
          AND (g.item = 'entry' OR g.item IS NULL)
          AND g.action = 'see'
          AND g.active = 1
          AND (g.item_id = b.idblogs OR g.item_id IS NULL)
          AND (g.user_id = ? OR g.user_id IS NULL)
          AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
    )
)
ORDER BY b.written DESC
LIMIT ? OFFSET ?
`

type ListBlogEntriesForListerParams struct {
	ListerID int32
	IsAdmin  interface{}
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type ListBlogEntriesForListerRow struct {
	Idblogs       int32
	ForumthreadID sql.NullInt32
	UsersIdusers  int32
	LanguageID    sql.NullInt32
	Blog          sql.NullString
	Written       time.Time
	Timezone      sql.NullString
	Username      sql.NullString
	Comments      int32
	IsOwner       bool
}

func (q *Queries) ListBlogEntriesForLister(ctx context.Context, arg ListBlogEntriesForListerParams) ([]*ListBlogEntriesForListerRow, error) {
	rows, err := q.db.QueryContext(ctx, listBlogEntriesForLister,
		arg.ListerID,
		arg.ListerID,
		arg.ListerID,
		arg.ListerID,
		arg.IsAdmin,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListBlogEntriesForListerRow
	for rows.Next() {
		var i ListBlogEntriesForListerRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageID,
			&i.Blog,
			&i.Written,
			&i.Timezone,
			&i.Username,
			&i.Comments,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBlogIDsBySearchWordFirstForLister = `-- name: ListBlogIDsBySearchWordFirstForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT id FROM roles WHERE name = 'anyone'
)
SELECT DISTINCT cs.blog_id
FROM blogs_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist = cs.searchwordlist_idsearchwordlist
JOIN blogs b ON b.idblogs = cs.blog_id
WHERE swl.word = ?
  AND (
      b.language_id = 0
      OR b.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = b.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section = 'blogs'
        AND (g.item = 'entry' OR g.item IS NULL)
        AND g.action = 'see'
        AND g.active = 1
        AND (g.item_id = b.idblogs OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type ListBlogIDsBySearchWordFirstForListerParams struct {
	ListerID int32
	Word     sql.NullString
	UserID   sql.NullInt32
}

func (q *Queries) ListBlogIDsBySearchWordFirstForLister(ctx context.Context, arg ListBlogIDsBySearchWordFirstForListerParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, listBlogIDsBySearchWordFirstForLister,
		arg.ListerID,
		arg.Word,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var blog_id int32
		if err := rows.Scan(&blog_id); err != nil {
			return nil, err
		}
		items = append(items, blog_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBlogIDsBySearchWordNextForLister = `-- name: ListBlogIDsBySearchWordNextForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT id FROM roles WHERE name = 'anyone'
)
SELECT DISTINCT cs.blog_id
FROM blogs_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist = cs.searchwordlist_idsearchwordlist
JOIN blogs b ON b.idblogs = cs.blog_id
WHERE swl.word = ?
  AND cs.blog_id IN (/*SLICE:ids*/?)
  AND (
      b.language_id = 0
      OR b.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = b.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section = 'blogs'
        AND (g.item = 'entry' OR g.item IS NULL)
        AND g.action = 'see'
        AND g.active = 1
        AND (g.item_id = b.idblogs OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type ListBlogIDsBySearchWordNextForListerParams struct {
	ListerID int32
	Word     sql.NullString
	Ids      []int32
	UserID   sql.NullInt32
}

func (q *Queries) ListBlogIDsBySearchWordNextForLister(ctx context.Context, arg ListBlogIDsBySearchWordNextForListerParams) ([]int32, error) {
	query := listBlogIDsBySearchWordNextForLister
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var blog_id int32
		if err := rows.Scan(&blog_id); err != nil {
			return nil, err
		}
		items = append(items, blog_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBloggersForLister = `-- name: ListBloggersForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT id FROM roles WHERE name = 'anyone'
)
SELECT u.username, COUNT(b.idblogs) AS count
FROM blogs b
JOIN users u ON b.users_idusers = u.idusers
WHERE (
    b.language_id = 0
    OR b.language_id IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_id = b.language_id
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'blogs'
      AND (g.item = 'entry' OR g.item IS NULL)
      AND g.action = 'see'
      AND g.active = 1
      AND (g.item_id = b.idblogs OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
GROUP BY u.idusers
ORDER BY u.username
LIMIT ? OFFSET ?
`

type ListBloggersForListerParams struct {
	ListerID int32
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type ListBloggersForListerRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) ListBloggersForLister(ctx context.Context, arg ListBloggersForListerParams) ([]*ListBloggersForListerRow, error) {
	rows, err := q.db.QueryContext(ctx, listBloggersForLister,
		arg.ListerID,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListBloggersForListerRow
	for rows.Next() {
		var i ListBloggersForListerRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBloggersSearchForLister = `-- name: ListBloggersSearchForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT id FROM roles WHERE name = 'anyone'
)
SELECT u.username, COUNT(b.idblogs) AS count
FROM blogs b
JOIN users u ON b.users_idusers = u.idusers
WHERE (LOWER(u.username) LIKE LOWER(?) OR LOWER((SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1)) LIKE LOWER(?))
  AND (
    b.language_id = 0
    OR b.language_id IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_id = b.language_id
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'blogs'
      AND (g.item = 'entry' OR g.item IS NULL)
      AND g.action = 'see'
      AND g.active = 1
      AND (g.item_id = b.idblogs OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
GROUP BY u.idusers
ORDER BY u.username
LIMIT ? OFFSET ?
`

type ListBloggersSearchForListerParams struct {
	ListerID int32
	Query    string
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type ListBloggersSearchForListerRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) ListBloggersSearchForLister(ctx context.Context, arg ListBloggersSearchForListerParams) ([]*ListBloggersSearchForListerRow, error) {
	rows, err := q.db.QueryContext(ctx, listBloggersSearchForLister,
		arg.ListerID,
		arg.Query,
		arg.Query,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListBloggersSearchForListerRow
	for rows.Next() {
		var i ListBloggersSearchForListerRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemAssignBlogEntryThreadID = `-- name: SystemAssignBlogEntryThreadID :exec
UPDATE blogs
SET forumthread_id = ?
WHERE idblogs = ?
`

type SystemAssignBlogEntryThreadIDParams struct {
	ForumthreadID sql.NullInt32
	Idblogs       int32
}

func (q *Queries) SystemAssignBlogEntryThreadID(ctx context.Context, arg SystemAssignBlogEntryThreadIDParams) error {
	_, err := q.db.ExecContext(ctx, systemAssignBlogEntryThreadID, arg.ForumthreadID, arg.Idblogs)
	return err
}

const systemGetAllBlogsForIndex = `-- name: SystemGetAllBlogsForIndex :many
SELECT idblogs, blog FROM blogs WHERE deleted_at IS NULL
`

type SystemGetAllBlogsForIndexRow struct {
	Idblogs int32
	Blog    sql.NullString
}

func (q *Queries) SystemGetAllBlogsForIndex(ctx context.Context) ([]*SystemGetAllBlogsForIndexRow, error) {
	rows, err := q.db.QueryContext(ctx, systemGetAllBlogsForIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SystemGetAllBlogsForIndexRow
	for rows.Next() {
		var i SystemGetAllBlogsForIndexRow
		if err := rows.Scan(&i.Idblogs, &i.Blog); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemGetBlogEntryByID = `-- name: SystemGetBlogEntryByID :one
SELECT idblogs, forumthread_id
FROM blogs
WHERE idblogs = ?
`

type SystemGetBlogEntryByIDRow struct {
	Idblogs       int32
	ForumthreadID sql.NullInt32
}

func (q *Queries) SystemGetBlogEntryByID(ctx context.Context, idblogs int32) (*SystemGetBlogEntryByIDRow, error) {
	row := q.db.QueryRowContext(ctx, systemGetBlogEntryByID, idblogs)
	var i SystemGetBlogEntryByIDRow
	err := row.Scan(&i.Idblogs, &i.ForumthreadID)
	return &i, err
}

const systemSetBlogLastIndex = `-- name: SystemSetBlogLastIndex :exec
UPDATE blogs SET last_index = NOW() WHERE idblogs = ?
`

func (q *Queries) SystemSetBlogLastIndex(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, systemSetBlogLastIndex, id)
	return err
}

const updateBlogEntryForWriter = `-- name: UpdateBlogEntryForWriter :exec
UPDATE blogs b
SET language_id = ?, blog = ?
WHERE b.idblogs = ?
  AND b.users_idusers = ?
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section = 'blogs'
        AND (g.item = 'entry' OR g.item IS NULL)
        AND g.action = 'post'
        AND g.active = 1
        AND (g.item_id = ? OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (
            SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
        ))
  )
`

type UpdateBlogEntryForWriterParams struct {
	LanguageID   sql.NullInt32
	Blog         sql.NullString
	EntryID      int32
	WriterID     int32
	GrantEntryID sql.NullInt32
	GranteeID    sql.NullInt32
}

func (q *Queries) UpdateBlogEntryForWriter(ctx context.Context, arg UpdateBlogEntryForWriterParams) error {
	_, err := q.db.ExecContext(ctx, updateBlogEntryForWriter,
		arg.LanguageID,
		arg.Blog,
		arg.EntryID,
		arg.WriterID,
		arg.GrantEntryID,
		arg.GranteeID,
		arg.WriterID,
	)
	return err
}
