// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-comments.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const adminGetAllCommentsByUser = `-- name: AdminGetAllCommentsByUser :many
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage,
       c.written, c.text, c.deleted_at, c.last_index,
       th.forumtopic_idforumtopic, t.title AS forumtopic_title,
       fp.text AS thread_title
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_id = th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic = t.idforumtopic
LEFT JOIN comments fp ON th.firstpost = fp.idcomments
WHERE c.users_idusers = ?
ORDER BY c.written
`

type AdminGetAllCommentsByUserRow struct {
	Idcomments             int32
	ForumthreadID          int32
	UsersIdusers           int32
	LanguageIdlanguage     sql.NullInt32
	Written                sql.NullTime
	Text                   sql.NullString
	DeletedAt              sql.NullTime
	LastIndex              sql.NullTime
	ForumtopicIdforumtopic sql.NullInt32
	ForumtopicTitle        sql.NullString
	ThreadTitle            sql.NullString
}

func (q *Queries) AdminGetAllCommentsByUser(ctx context.Context, userID int32) ([]*AdminGetAllCommentsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetAllCommentsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminGetAllCommentsByUserRow
	for rows.Next() {
		var i AdminGetAllCommentsByUserRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.DeletedAt,
			&i.LastIndex,
			&i.ForumtopicIdforumtopic,
			&i.ForumtopicTitle,
			&i.ThreadTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListAllCommentsWithThreadInfo = `-- name: AdminListAllCommentsWithThreadInfo :many
SELECT c.idcomments, c.written, c.text, c.deleted_at,
       th.idforumthread, t.idforumtopic, t.title AS forumtopic_title,
       u.idusers, u.username AS posterusername
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_id = th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic = t.idforumtopic
LEFT JOIN users u ON u.idusers = c.users_idusers
ORDER BY c.written DESC
LIMIT ? OFFSET ?
`

type AdminListAllCommentsWithThreadInfoParams struct {
	Limit  int32
	Offset int32
}

type AdminListAllCommentsWithThreadInfoRow struct {
	Idcomments      int32
	Written         sql.NullTime
	Text            sql.NullString
	DeletedAt       sql.NullTime
	Idforumthread   sql.NullInt32
	Idforumtopic    sql.NullInt32
	ForumtopicTitle sql.NullString
	Idusers         sql.NullInt32
	Posterusername  sql.NullString
}

func (q *Queries) AdminListAllCommentsWithThreadInfo(ctx context.Context, arg AdminListAllCommentsWithThreadInfoParams) ([]*AdminListAllCommentsWithThreadInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListAllCommentsWithThreadInfo, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListAllCommentsWithThreadInfoRow
	for rows.Next() {
		var i AdminListAllCommentsWithThreadInfoRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.Written,
			&i.Text,
			&i.DeletedAt,
			&i.Idforumthread,
			&i.Idforumtopic,
			&i.ForumtopicTitle,
			&i.Idusers,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createCommentInSectionForCommenter = `-- name: CreateCommentInSectionForCommenter :execlastid
INSERT INTO comments (language_idlanguage, users_idusers, forumthread_id, text, written)
SELECT ?, ?, ?, ?, NOW()
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = ?
      AND (g.item = ? OR g.item IS NULL)
      AND g.action = 'reply'
      AND g.active = 1
      AND (g.item_id = ? OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
  )
`

type CreateCommentInSectionForCommenterParams struct {
	LanguageID    sql.NullInt32
	CommenterID   sql.NullInt32
	ForumthreadID int32
	Text          sql.NullString
	Section       string
	ItemType      sql.NullString
	ItemID        sql.NullInt32
}

func (q *Queries) CreateCommentInSectionForCommenter(ctx context.Context, arg CreateCommentInSectionForCommenterParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createCommentInSectionForCommenter,
		arg.LanguageID,
		arg.CommenterID,
		arg.ForumthreadID,
		arg.Text,
		arg.Section,
		arg.ItemType,
		arg.ItemID,
		arg.CommenterID,
		arg.CommenterID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const getAllCommentsForIndex = `-- name: GetAllCommentsForIndex :many
SELECT idcomments, text FROM comments WHERE deleted_at IS NULL
`

type GetAllCommentsForIndexRow struct {
	Idcomments int32
	Text       sql.NullString
}

func (q *Queries) GetAllCommentsForIndex(ctx context.Context) ([]*GetAllCommentsForIndexRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCommentsForIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllCommentsForIndexRow
	for rows.Next() {
		var i GetAllCommentsForIndexRow
		if err := rows.Scan(&i.Idcomments, &i.Text); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentById = `-- name: GetCommentById :one
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage, c.written, c.text, c.deleted_at, c.last_index
FROM comments c
WHERE c.Idcomments=?
`

func (q *Queries) GetCommentById(ctx context.Context, idcomments int32) (*Comment, error) {
	row := q.db.QueryRowContext(ctx, getCommentById, idcomments)
	var i Comment
	err := row.Scan(
		&i.Idcomments,
		&i.ForumthreadID,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Written,
		&i.Text,
		&i.DeletedAt,
		&i.LastIndex,
	)
	return &i, err
}

const getCommentByIdForUser = `-- name: GetCommentByIdForUser :one
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage, c.written, c.text, c.deleted_at, c.last_index, pu.Username,
       c.users_idusers = ? AS is_owner
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_id=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN users pu ON pu.idusers = c.users_idusers
WHERE c.idcomments = ?
  AND (
    c.language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = c.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='see'
      AND g.active=1
      AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
LIMIT 1
`

type GetCommentByIdForUserParams struct {
	ViewerID int32
	ID       int32
	UserID   sql.NullInt32
}

type GetCommentByIdForUserRow struct {
	Idcomments         int32
	ForumthreadID      int32
	UsersIdusers       int32
	LanguageIdlanguage sql.NullInt32
	Written            sql.NullTime
	Text               sql.NullString
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Username           sql.NullString
	IsOwner            bool
}

func (q *Queries) GetCommentByIdForUser(ctx context.Context, arg GetCommentByIdForUserParams) (*GetCommentByIdForUserRow, error) {
	row := q.db.QueryRowContext(ctx, getCommentByIdForUser,
		arg.ViewerID,
		arg.ViewerID,
		arg.ID,
		arg.ViewerID,
		arg.ViewerID,
		arg.UserID,
	)
	var i GetCommentByIdForUserRow
	err := row.Scan(
		&i.Idcomments,
		&i.ForumthreadID,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Written,
		&i.Text,
		&i.DeletedAt,
		&i.LastIndex,
		&i.Username,
		&i.IsOwner,
	)
	return &i, err
}

const getCommentsByIdsForUserWithThreadInfo = `-- name: GetCommentsByIdsForUserWithThreadInfo :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage, c.written, c.text, c.deleted_at, c.last_index, pu.username AS posterusername,
       c.users_idusers = ? AS is_owner,
       th.idforumthread, t.idforumtopic, t.title AS forumtopic_title,
       fp.text AS thread_title, fc.idforumcategory, fc.title AS forumcategory_title
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_id=th.idforumthread
LEFT JOIN comments fp ON th.firstpost = fp.idcomments
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN users pu ON pu.idusers = c.users_idusers
LEFT JOIN forumcategory fc ON t.forumcategory_idforumcategory = fc.idforumcategory
WHERE c.Idcomments IN (/*SLICE:ids*/?)
  AND (
    c.language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = c.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='see'
      AND g.active=1
      AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY c.written DESC
`

type GetCommentsByIdsForUserWithThreadInfoParams struct {
	ViewerID int32
	Ids      []int32
	UserID   sql.NullInt32
}

type GetCommentsByIdsForUserWithThreadInfoRow struct {
	Idcomments         int32
	ForumthreadID      int32
	UsersIdusers       int32
	LanguageIdlanguage sql.NullInt32
	Written            sql.NullTime
	Text               sql.NullString
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Posterusername     sql.NullString
	IsOwner            bool
	Idforumthread      sql.NullInt32
	Idforumtopic       sql.NullInt32
	ForumtopicTitle    sql.NullString
	ThreadTitle        sql.NullString
	Idforumcategory    sql.NullInt32
	ForumcategoryTitle sql.NullString
}

func (q *Queries) GetCommentsByIdsForUserWithThreadInfo(ctx context.Context, arg GetCommentsByIdsForUserWithThreadInfoParams) ([]*GetCommentsByIdsForUserWithThreadInfoRow, error) {
	query := getCommentsByIdsForUserWithThreadInfo
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ViewerID)
	queryParams = append(queryParams, arg.ViewerID)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ViewerID)
	queryParams = append(queryParams, arg.ViewerID)
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCommentsByIdsForUserWithThreadInfoRow
	for rows.Next() {
		var i GetCommentsByIdsForUserWithThreadInfoRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Posterusername,
			&i.IsOwner,
			&i.Idforumthread,
			&i.Idforumtopic,
			&i.ForumtopicTitle,
			&i.ThreadTitle,
			&i.Idforumcategory,
			&i.ForumcategoryTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsBySectionThreadIdForUser = `-- name: GetCommentsBySectionThreadIdForUser :many
WITH role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage, c.written, c.text, c.deleted_at, c.last_index, pu.username AS posterusername,
       c.users_idusers = ? AS is_owner
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_id=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN users pu ON pu.idusers = c.users_idusers
WHERE c.forumthread_id=?
  AND c.forumthread_id!=0
  AND (
    c.language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = c.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section=?
      AND (g.item=? OR g.item IS NULL)
      AND g.action='view'
      AND g.active=1
      AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
ORDER BY c.written
`

type GetCommentsBySectionThreadIdForUserParams struct {
	ViewerID int32
	ThreadID int32
	Section  string
	ItemType sql.NullString
	UserID   sql.NullInt32
}

type GetCommentsBySectionThreadIdForUserRow struct {
	Idcomments         int32
	ForumthreadID      int32
	UsersIdusers       int32
	LanguageIdlanguage sql.NullInt32
	Written            sql.NullTime
	Text               sql.NullString
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Posterusername     sql.NullString
	IsOwner            bool
}

// Viewing comments in a section-specific thread requires 'view' on the
// section's primary item type since comments inherit their thread's grants.
func (q *Queries) GetCommentsBySectionThreadIdForUser(ctx context.Context, arg GetCommentsBySectionThreadIdForUserParams) ([]*GetCommentsBySectionThreadIdForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommentsBySectionThreadIdForUser,
		arg.ViewerID,
		arg.ViewerID,
		arg.ThreadID,
		arg.ViewerID,
		arg.ViewerID,
		arg.Section,
		arg.ItemType,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCommentsBySectionThreadIdForUserRow
	for rows.Next() {
		var i GetCommentsBySectionThreadIdForUserRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Posterusername,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsByThreadIdForUser = `-- name: GetCommentsByThreadIdForUser :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage, c.written, c.text, c.deleted_at, c.last_index, pu.username AS posterusername,
       c.users_idusers = ? AS is_owner
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_id=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN users pu ON pu.idusers = c.users_idusers
WHERE c.forumthread_id=?
  AND c.forumthread_id!=0
  AND (
    c.language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = c.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='see'
      AND g.active=1
      AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
ORDER BY c.written
`

type GetCommentsByThreadIdForUserParams struct {
	ViewerID int32
	ThreadID int32
	UserID   sql.NullInt32
}

type GetCommentsByThreadIdForUserRow struct {
	Idcomments         int32
	ForumthreadID      int32
	UsersIdusers       int32
	LanguageIdlanguage sql.NullInt32
	Written            sql.NullTime
	Text               sql.NullString
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Posterusername     sql.NullString
	IsOwner            bool
}

func (q *Queries) GetCommentsByThreadIdForUser(ctx context.Context, arg GetCommentsByThreadIdForUserParams) ([]*GetCommentsByThreadIdForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommentsByThreadIdForUser,
		arg.ViewerID,
		arg.ViewerID,
		arg.ThreadID,
		arg.ViewerID,
		arg.ViewerID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCommentsByThreadIdForUserRow
	for rows.Next() {
		var i GetCommentsByThreadIdForUserRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Posterusername,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemListCommentsByThreadID = `-- name: SystemListCommentsByThreadID :many
SELECT c.idcomments, c.text
FROM comments c
WHERE c.forumthread_id = ?
ORDER BY c.idcomments
`

type SystemListCommentsByThreadIDRow struct {
	Idcomments int32
	Text       sql.NullString
}

func (q *Queries) SystemListCommentsByThreadID(ctx context.Context, forumthreadID int32) ([]*SystemListCommentsByThreadIDRow, error) {
	rows, err := q.db.QueryContext(ctx, systemListCommentsByThreadID, forumthreadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SystemListCommentsByThreadIDRow
	for rows.Next() {
		var i SystemListCommentsByThreadIDRow
		if err := rows.Scan(&i.Idcomments, &i.Text); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemSetCommentLastIndex = `-- name: SystemSetCommentLastIndex :exec
UPDATE comments SET last_index = NOW() WHERE idcomments = ?
`

func (q *Queries) SystemSetCommentLastIndex(ctx context.Context, idcomments int32) error {
	_, err := q.db.ExecContext(ctx, systemSetCommentLastIndex, idcomments)
	return err
}

const updateCommentForEditor = `-- name: UpdateCommentForEditor :exec
UPDATE comments c
SET language_idlanguage = ?, text = ?
WHERE c.idcomments = ?
  AND c.users_idusers = ?
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='forum'
        AND (g.item='thread' OR g.item IS NULL)
        AND g.action='edit'
        AND g.active=1
        AND (g.item_id = c.forumthread_id OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (
            SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
        ))
  )
`

type UpdateCommentForEditorParams struct {
	LanguageID  sql.NullInt32
	Text        sql.NullString
	CommentID   int32
	CommenterID int32
	EditorID    sql.NullInt32
}

func (q *Queries) UpdateCommentForEditor(ctx context.Context, arg UpdateCommentForEditorParams) error {
	_, err := q.db.ExecContext(ctx, updateCommentForEditor,
		arg.LanguageID,
		arg.Text,
		arg.CommentID,
		arg.CommenterID,
		arg.EditorID,
		arg.CommenterID,
	)
	return err
}
