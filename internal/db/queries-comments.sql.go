// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-comments.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const createComment = `-- name: CreateComment :execlastid
INSERT INTO comments (language_idlanguage, users_idusers, forumthread_id, text, written)
VALUES (?, ?, ?, ?, NOW() )
`

type CreateCommentParams struct {
	LanguageIdlanguage int32
	UsersIdusers       int32
	ForumthreadID      int32
	Text               sql.NullString
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createComment,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
		arg.ForumthreadID,
		arg.Text,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const getAllCommentsByUser = `-- name: GetAllCommentsByUser :many
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage, c.written, c.text, c.deleted_at, c.last_index, th.forumtopic_idforumtopic
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_id = th.idforumthread
WHERE c.users_idusers = ?
ORDER BY c.written
`

type GetAllCommentsByUserRow struct {
	Idcomments             int32
	ForumthreadID          int32
	UsersIdusers           int32
	LanguageIdlanguage     int32
	Written                sql.NullTime
	Text                   sql.NullString
	DeletedAt              sql.NullTime
	LastIndex              sql.NullTime
	ForumtopicIdforumtopic sql.NullInt32
}

func (q *Queries) GetAllCommentsByUser(ctx context.Context, usersIdusers int32) ([]*GetAllCommentsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCommentsByUser, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllCommentsByUserRow
	for rows.Next() {
		var i GetAllCommentsByUserRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.DeletedAt,
			&i.LastIndex,
			&i.ForumtopicIdforumtopic,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCommentsForIndex = `-- name: GetAllCommentsForIndex :many
SELECT idcomments, text FROM comments WHERE deleted_at IS NULL
`

type GetAllCommentsForIndexRow struct {
	Idcomments int32
	Text       sql.NullString
}

func (q *Queries) GetAllCommentsForIndex(ctx context.Context) ([]*GetAllCommentsForIndexRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCommentsForIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllCommentsForIndexRow
	for rows.Next() {
		var i GetAllCommentsForIndexRow
		if err := rows.Scan(&i.Idcomments, &i.Text); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentById = `-- name: GetCommentById :one
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage, c.written, c.text, c.deleted_at, c.last_index
FROM comments c
WHERE c.Idcomments=?
`

func (q *Queries) GetCommentById(ctx context.Context, idcomments int32) (*Comment, error) {
	row := q.db.QueryRowContext(ctx, getCommentById, idcomments)
	var i Comment
	err := row.Scan(
		&i.Idcomments,
		&i.ForumthreadID,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Written,
		&i.Text,
		&i.DeletedAt,
		&i.LastIndex,
	)
	return &i, err
}

const getCommentByIdForUser = `-- name: GetCommentByIdForUser :one
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage, c.written, c.text, c.deleted_at, c.last_index, pu.Username,
       c.users_idusers = ? AS is_owner
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_id=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN users pu ON pu.idusers = c.users_idusers
WHERE c.idcomments = ? AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND g.item='topic'
      AND g.action='see'
      AND g.active=1
      AND g.item_id = t.idforumtopic
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
LIMIT 1
`

type GetCommentByIdForUserParams struct {
	ViewerID int32
	ID       int32
	UserID   sql.NullInt32
}

type GetCommentByIdForUserRow struct {
	Idcomments         int32
	ForumthreadID      int32
	UsersIdusers       int32
	LanguageIdlanguage int32
	Written            sql.NullTime
	Text               sql.NullString
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Username           sql.NullString
	IsOwner            bool
}

func (q *Queries) GetCommentByIdForUser(ctx context.Context, arg GetCommentByIdForUserParams) (*GetCommentByIdForUserRow, error) {
	row := q.db.QueryRowContext(ctx, getCommentByIdForUser,
		arg.ViewerID,
		arg.ViewerID,
		arg.ID,
		arg.UserID,
	)
	var i GetCommentByIdForUserRow
	err := row.Scan(
		&i.Idcomments,
		&i.ForumthreadID,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Written,
		&i.Text,
		&i.DeletedAt,
		&i.LastIndex,
		&i.Username,
		&i.IsOwner,
	)
	return &i, err
}

const getCommentsByIds = `-- name: GetCommentsByIds :many
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage, c.written, c.text, c.deleted_at, c.last_index
FROM comments c
WHERE c.Idcomments IN (/*SLICE:ids*/?)
`

func (q *Queries) GetCommentsByIds(ctx context.Context, ids []int32) ([]*Comment, error) {
	query := getCommentsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.DeletedAt,
			&i.LastIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsByIdsForUserWithThreadInfo = `-- name: GetCommentsByIdsForUserWithThreadInfo :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage, c.written, c.text, c.deleted_at, c.last_index, pu.username AS posterusername,
       c.users_idusers = ? AS is_owner,
       th.idforumthread, t.idforumtopic, t.title AS forumtopic_title, fc.idforumcategory, fc.title AS forumcategory_title
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_id=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN users pu ON pu.idusers = c.users_idusers
LEFT JOIN forumcategory fc ON t.forumcategory_idforumcategory = fc.idforumcategory
WHERE c.Idcomments IN (/*SLICE:ids*/?) AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND g.item='topic'
      AND g.action='see'
      AND g.active=1
      AND g.item_id = t.idforumtopic
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
ORDER BY c.written DESC
`

type GetCommentsByIdsForUserWithThreadInfoParams struct {
	ViewerID int32
	Ids      []int32
	UserID   sql.NullInt32
}

type GetCommentsByIdsForUserWithThreadInfoRow struct {
	Idcomments         int32
	ForumthreadID      int32
	UsersIdusers       int32
	LanguageIdlanguage int32
	Written            sql.NullTime
	Text               sql.NullString
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Posterusername     sql.NullString
	IsOwner            bool
	Idforumthread      sql.NullInt32
	Idforumtopic       sql.NullInt32
	ForumtopicTitle    sql.NullString
	Idforumcategory    sql.NullInt32
	ForumcategoryTitle sql.NullString
}

func (q *Queries) GetCommentsByIdsForUserWithThreadInfo(ctx context.Context, arg GetCommentsByIdsForUserWithThreadInfoParams) ([]*GetCommentsByIdsForUserWithThreadInfoRow, error) {
	query := getCommentsByIdsForUserWithThreadInfo
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ViewerID)
	queryParams = append(queryParams, arg.ViewerID)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCommentsByIdsForUserWithThreadInfoRow
	for rows.Next() {
		var i GetCommentsByIdsForUserWithThreadInfoRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Posterusername,
			&i.IsOwner,
			&i.Idforumthread,
			&i.Idforumtopic,
			&i.ForumtopicTitle,
			&i.Idforumcategory,
			&i.ForumcategoryTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsByThreadIdForUser = `-- name: GetCommentsByThreadIdForUser :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage, c.written, c.text, c.deleted_at, c.last_index, pu.username AS posterusername,
       c.users_idusers = ? AS is_owner
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_id=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN users pu ON pu.idusers = c.users_idusers
WHERE c.forumthread_id=? AND c.forumthread_id!=0 AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND g.item='topic'
      AND g.action='see'
      AND g.active=1
      AND g.item_id = t.idforumtopic
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
ORDER BY c.written
`

type GetCommentsByThreadIdForUserParams struct {
	ViewerID int32
	ThreadID int32
	UserID   sql.NullInt32
}

type GetCommentsByThreadIdForUserRow struct {
	Idcomments         int32
	ForumthreadID      int32
	UsersIdusers       int32
	LanguageIdlanguage int32
	Written            sql.NullTime
	Text               sql.NullString
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Posterusername     sql.NullString
	IsOwner            bool
}

func (q *Queries) GetCommentsByThreadIdForUser(ctx context.Context, arg GetCommentsByThreadIdForUserParams) ([]*GetCommentsByThreadIdForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommentsByThreadIdForUser,
		arg.ViewerID,
		arg.ViewerID,
		arg.ThreadID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCommentsByThreadIdForUserRow
	for rows.Next() {
		var i GetCommentsByThreadIdForUserRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Posterusername,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCommentLastIndex = `-- name: SetCommentLastIndex :exec
UPDATE comments SET last_index = NOW() WHERE idcomments = ?
`

func (q *Queries) SetCommentLastIndex(ctx context.Context, idcomments int32) error {
	_, err := q.db.ExecContext(ctx, setCommentLastIndex, idcomments)
	return err
}

const updateComment = `-- name: UpdateComment :exec
UPDATE comments
SET language_idlanguage = ?, text = ?
WHERE idcomments = ?
`

type UpdateCommentParams struct {
	LanguageIdlanguage int32
	Text               sql.NullString
	Idcomments         int32
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.ExecContext(ctx, updateComment, arg.LanguageIdlanguage, arg.Text, arg.Idcomments)
	return err
}
