// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-faq.sql

package db

import (
	"context"
	"database/sql"
)

const adminCreateFAQCategory = `-- name: AdminCreateFAQCategory :exec
INSERT INTO faq_categories (name) VALUES (?)
`

func (q *Queries) AdminCreateFAQCategory(ctx context.Context, name sql.NullString) error {
	_, err := q.db.ExecContext(ctx, adminCreateFAQCategory, name)
	return err
}

const adminDeleteFAQ = `-- name: AdminDeleteFAQ :exec
UPDATE faq SET deleted_at = NOW()
WHERE idfaq = ?
`

func (q *Queries) AdminDeleteFAQ(ctx context.Context, idfaq int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteFAQ, idfaq)
	return err
}

const adminDeleteFAQCategory = `-- name: AdminDeleteFAQCategory :exec
UPDATE faq_categories SET deleted_at = NOW()
WHERE idfaqCategories = ?
`

func (q *Queries) AdminDeleteFAQCategory(ctx context.Context, idfaqcategories int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteFAQCategory, idfaqcategories)
	return err
}

const adminRenameFAQCategory = `-- name: AdminRenameFAQCategory :exec
UPDATE faq_categories
SET name = ?
WHERE idfaqCategories = ?
`

type AdminRenameFAQCategoryParams struct {
	Name            sql.NullString
	Idfaqcategories int32
}

func (q *Queries) AdminRenameFAQCategory(ctx context.Context, arg AdminRenameFAQCategoryParams) error {
	_, err := q.db.ExecContext(ctx, adminRenameFAQCategory, arg.Name, arg.Idfaqcategories)
	return err
}

const adminUpdateFAQQuestionAnswer = `-- name: AdminUpdateFAQQuestionAnswer :exec
UPDATE faq
SET answer = ?, question = ?, faqCategories_idfaqCategories = ?
WHERE idfaq = ?
`

type AdminUpdateFAQQuestionAnswerParams struct {
	Answer                       sql.NullString
	Question                     sql.NullString
	FaqcategoriesIdfaqcategories int32
	Idfaq                        int32
}

func (q *Queries) AdminUpdateFAQQuestionAnswer(ctx context.Context, arg AdminUpdateFAQQuestionAnswerParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateFAQQuestionAnswer,
		arg.Answer,
		arg.Question,
		arg.FaqcategoriesIdfaqcategories,
		arg.Idfaq,
	)
	return err
}

const createFAQQuestionForWriter = `-- name: CreateFAQQuestionForWriter :exec
INSERT INTO faq (question, users_idusers, language_idlanguage)
SELECT ?, ?, ?
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'faq'
      AND (g.item = 'question' OR g.item IS NULL)
      AND g.action = 'post'
      AND g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
)
`

type CreateFAQQuestionForWriterParams struct {
	Question   sql.NullString
	WriterID   int32
	LanguageID int32
	GranteeID  sql.NullInt32
}

func (q *Queries) CreateFAQQuestionForWriter(ctx context.Context, arg CreateFAQQuestionForWriterParams) error {
	_, err := q.db.ExecContext(ctx, createFAQQuestionForWriter,
		arg.Question,
		arg.WriterID,
		arg.LanguageID,
		arg.GranteeID,
		arg.WriterID,
	)
	return err
}

const getAllAnsweredFAQWithFAQCategoriesForUser = `-- name: GetAllAnsweredFAQWithFAQCategoriesForUser :many
WITH role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT c.idfaqCategories, c.name, f.idfaq, f.faqCategories_idfaqCategories, f.language_idlanguage, f.users_idusers, f.answer, f.question
FROM faq f
LEFT JOIN faq_categories c ON c.idfaqCategories = f.faqCategories_idfaqCategories
WHERE c.idfaqCategories <> 0
  AND f.answer IS NOT NULL
  AND (
      f.language_idlanguage = 0
      OR f.language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = f.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='faq'
        AND (g.item='question/answer' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = f.idfaq OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY c.idfaqCategories, f.idfaq
`

type GetAllAnsweredFAQWithFAQCategoriesForUserParams struct {
	ViewerID int32
	UserID   sql.NullInt32
}

type GetAllAnsweredFAQWithFAQCategoriesForUserRow struct {
	Idfaqcategories              sql.NullInt32
	Name                         sql.NullString
	Idfaq                        int32
	FaqcategoriesIdfaqcategories int32
	LanguageIdlanguage           int32
	UsersIdusers                 int32
	Answer                       sql.NullString
	Question                     sql.NullString
}

func (q *Queries) GetAllAnsweredFAQWithFAQCategoriesForUser(ctx context.Context, arg GetAllAnsweredFAQWithFAQCategoriesForUserParams) ([]*GetAllAnsweredFAQWithFAQCategoriesForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAnsweredFAQWithFAQCategoriesForUser,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllAnsweredFAQWithFAQCategoriesForUserRow
	for rows.Next() {
		var i GetAllAnsweredFAQWithFAQCategoriesForUserRow
		if err := rows.Scan(
			&i.Idfaqcategories,
			&i.Name,
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFAQCategories = `-- name: GetAllFAQCategories :many
SELECT idfaqcategories, name
FROM faq_categories
`

func (q *Queries) GetAllFAQCategories(ctx context.Context) ([]*FaqCategory, error) {
	rows, err := q.db.QueryContext(ctx, getAllFAQCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FaqCategory
	for rows.Next() {
		var i FaqCategory
		if err := rows.Scan(&i.Idfaqcategories, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFAQQuestions = `-- name: GetAllFAQQuestions :many
SELECT idfaq, faqcategories_idfaqcategories, language_idlanguage, users_idusers, answer, question
FROM faq
`

func (q *Queries) GetAllFAQQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, getAllFAQQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFAQAnsweredQuestions = `-- name: GetFAQAnsweredQuestions :many
WITH role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT idfaq, faqCategories_idfaqCategories, language_idlanguage, users_idusers, answer, question
FROM faq
WHERE answer IS NOT NULL
  AND deleted_at IS NULL
  AND (
      language_idlanguage = 0
      OR language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = faq.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='faq'
        AND (g.item='question/answer' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = faq.idfaq OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type GetFAQAnsweredQuestionsParams struct {
	ViewerID int32
	UserID   sql.NullInt32
}

func (q *Queries) GetFAQAnsweredQuestions(ctx context.Context, arg GetFAQAnsweredQuestionsParams) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, getFAQAnsweredQuestions,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFAQByID = `-- name: GetFAQByID :one
SELECT idfaq, faqcategories_idfaqcategories, language_idlanguage, users_idusers, answer, question FROM faq WHERE idfaq = ?
`

func (q *Queries) GetFAQByID(ctx context.Context, idfaq int32) (*Faq, error) {
	row := q.db.QueryRowContext(ctx, getFAQByID, idfaq)
	var i Faq
	err := row.Scan(
		&i.Idfaq,
		&i.FaqcategoriesIdfaqcategories,
		&i.LanguageIdlanguage,
		&i.UsersIdusers,
		&i.Answer,
		&i.Question,
	)
	return &i, err
}

const getFAQCategoriesWithQuestionCount = `-- name: GetFAQCategoriesWithQuestionCount :many
SELECT c.idfaqcategories, c.name, COUNT(f.idfaq) AS QuestionCount
FROM faq_categories c
LEFT JOIN faq f ON f.faqCategories_idfaqCategories = c.idfaqCategories
GROUP BY c.idfaqCategories
`

type GetFAQCategoriesWithQuestionCountRow struct {
	Idfaqcategories int32
	Name            sql.NullString
	Questioncount   int64
}

func (q *Queries) GetFAQCategoriesWithQuestionCount(ctx context.Context) ([]*GetFAQCategoriesWithQuestionCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getFAQCategoriesWithQuestionCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetFAQCategoriesWithQuestionCountRow
	for rows.Next() {
		var i GetFAQCategoriesWithQuestionCountRow
		if err := rows.Scan(&i.Idfaqcategories, &i.Name, &i.Questioncount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFAQDismissedQuestions = `-- name: GetFAQDismissedQuestions :many
SELECT idfaq, faqCategories_idfaqCategories, language_idlanguage, users_idusers, answer, question
FROM faq
WHERE deleted_at IS NOT NULL
`

func (q *Queries) GetFAQDismissedQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, getFAQDismissedQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFAQRevisionsForAdmin = `-- name: GetFAQRevisionsForAdmin :many
SELECT id, faq_id, users_idusers, question, answer, created_at FROM faq_revisions WHERE faq_id = ? ORDER BY id DESC
`

func (q *Queries) GetFAQRevisionsForAdmin(ctx context.Context, faqID int32) ([]*FaqRevision, error) {
	rows, err := q.db.QueryContext(ctx, getFAQRevisionsForAdmin, faqID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FaqRevision
	for rows.Next() {
		var i FaqRevision
		if err := rows.Scan(
			&i.ID,
			&i.FaqID,
			&i.UsersIdusers,
			&i.Question,
			&i.Answer,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFAQUnansweredQuestions = `-- name: GetFAQUnansweredQuestions :many
SELECT idfaq, faqcategories_idfaqcategories, language_idlanguage, users_idusers, answer, question
FROM faq
WHERE faqCategories_idfaqCategories = '0' OR answer IS NULL
`

func (q *Queries) GetFAQUnansweredQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, getFAQUnansweredQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFAQQuestionForWriter = `-- name: InsertFAQQuestionForWriter :execresult
INSERT INTO faq (question, answer, faqCategories_idfaqCategories, users_idusers, language_idlanguage)
SELECT ?, ?, ?, ?, ?
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'faq'
      AND (g.item = 'question' OR g.item IS NULL)
      AND g.action = 'post'
      AND g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
)
`

type InsertFAQQuestionForWriterParams struct {
	Question   sql.NullString
	Answer     sql.NullString
	CategoryID int32
	WriterID   int32
	LanguageID int32
	GranteeID  sql.NullInt32
}

func (q *Queries) InsertFAQQuestionForWriter(ctx context.Context, arg InsertFAQQuestionForWriterParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertFAQQuestionForWriter,
		arg.Question,
		arg.Answer,
		arg.CategoryID,
		arg.WriterID,
		arg.LanguageID,
		arg.GranteeID,
		arg.WriterID,
	)
}

const insertFAQRevisionForUser = `-- name: InsertFAQRevisionForUser :exec
INSERT INTO faq_revisions (faq_id, users_idusers, question, answer)
SELECT ?, ?, ?, ?
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'faq'
      AND (g.item = 'question' OR g.item IS NULL)
      AND g.action = 'post'
      AND g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
)
`

type InsertFAQRevisionForUserParams struct {
	FaqID        int32
	UsersIdusers int32
	Question     sql.NullString
	Answer       sql.NullString
	UserID       sql.NullInt32
	ViewerID     int32
}

func (q *Queries) InsertFAQRevisionForUser(ctx context.Context, arg InsertFAQRevisionForUserParams) error {
	_, err := q.db.ExecContext(ctx, insertFAQRevisionForUser,
		arg.FaqID,
		arg.UsersIdusers,
		arg.Question,
		arg.Answer,
		arg.UserID,
		arg.ViewerID,
	)
	return err
}
