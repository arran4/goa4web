// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-faq.sql

package db

import (
	"context"
	"database/sql"
)

const adminCreateFAQCategory = `-- name: AdminCreateFAQCategory :exec
INSERT INTO faq_categories (name)
VALUES (?)
`

func (q *Queries) AdminCreateFAQCategory(ctx context.Context, name sql.NullString) error {
	_, err := q.db.ExecContext(ctx, adminCreateFAQCategory, name)
	return err
}

const adminDeleteFAQ = `-- name: AdminDeleteFAQ :exec
UPDATE faq SET deleted_at = NOW()
WHERE idfaq = ?
`

func (q *Queries) AdminDeleteFAQ(ctx context.Context, idfaq int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteFAQ, idfaq)
	return err
}

const adminDeleteFAQCategory = `-- name: AdminDeleteFAQCategory :exec
UPDATE faq_categories SET deleted_at = NOW()
WHERE idfaqCategories = ?
`

func (q *Queries) AdminDeleteFAQCategory(ctx context.Context, idfaqcategories int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteFAQCategory, idfaqcategories)
	return err
}

const adminGetAllFAQCategories = `-- name: AdminGetAllFAQCategories :many
SELECT idfaqcategories, name
FROM faq_categories
`

func (q *Queries) AdminGetAllFAQCategories(ctx context.Context) ([]*FaqCategory, error) {
	rows, err := q.db.QueryContext(ctx, adminGetAllFAQCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FaqCategory
	for rows.Next() {
		var i FaqCategory
		if err := rows.Scan(&i.Idfaqcategories, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetFAQAnsweredQuestions = `-- name: AdminGetFAQAnsweredQuestions :many
SELECT idfaq, faqCategories_idfaqCategories, language_idlanguage, users_idusers, answer, question
FROM faq
WHERE answer IS NOT NULL AND deleted_at IS NULL
`

func (q *Queries) AdminGetFAQAnsweredQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, adminGetFAQAnsweredQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetFAQByID = `-- name: AdminGetFAQByID :one
SELECT idfaq, faqcategories_idfaqcategories, language_idlanguage, users_idusers, answer, question FROM faq WHERE idfaq = ?
`

func (q *Queries) AdminGetFAQByID(ctx context.Context, idfaq int32) (*Faq, error) {
	row := q.db.QueryRowContext(ctx, adminGetFAQByID, idfaq)
	var i Faq
	err := row.Scan(
		&i.Idfaq,
		&i.FaqcategoriesIdfaqcategories,
		&i.LanguageIdlanguage,
		&i.UsersIdusers,
		&i.Answer,
		&i.Question,
	)
	return &i, err
}

const adminGetFAQCategoriesWithQuestionCount = `-- name: AdminGetFAQCategoriesWithQuestionCount :many
SELECT c.idfaqcategories, c.name, COUNT(f.idfaq) AS QuestionCount
FROM faq_categories c
LEFT JOIN faq f ON f.faqCategories_idfaqCategories = c.idfaqCategories
GROUP BY c.idfaqCategories
`

type AdminGetFAQCategoriesWithQuestionCountRow struct {
	Idfaqcategories int32
	Name            sql.NullString
	Questioncount   int64
}

func (q *Queries) AdminGetFAQCategoriesWithQuestionCount(ctx context.Context) ([]*AdminGetFAQCategoriesWithQuestionCountRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetFAQCategoriesWithQuestionCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminGetFAQCategoriesWithQuestionCountRow
	for rows.Next() {
		var i AdminGetFAQCategoriesWithQuestionCountRow
		if err := rows.Scan(&i.Idfaqcategories, &i.Name, &i.Questioncount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetFAQDismissedQuestions = `-- name: AdminGetFAQDismissedQuestions :many
SELECT idfaq, faqCategories_idfaqCategories, language_idlanguage, users_idusers, answer, question
FROM faq
WHERE deleted_at IS NOT NULL
`

func (q *Queries) AdminGetFAQDismissedQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, adminGetFAQDismissedQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetFAQRevisionsForFAQ = `-- name: AdminGetFAQRevisionsForFAQ :many
SELECT id, faq_id, users_idusers, question, answer, created_at FROM faq_revisions WHERE faq_id = ? ORDER BY id DESC
`

func (q *Queries) AdminGetFAQRevisionsForFAQ(ctx context.Context, faqID int32) ([]*FaqRevision, error) {
	rows, err := q.db.QueryContext(ctx, adminGetFAQRevisionsForFAQ, faqID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FaqRevision
	for rows.Next() {
		var i FaqRevision
		if err := rows.Scan(
			&i.ID,
			&i.FaqID,
			&i.UsersIdusers,
			&i.Question,
			&i.Answer,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetFAQUnansweredQuestions = `-- name: AdminGetFAQUnansweredQuestions :many
SELECT idfaq, faqcategories_idfaqcategories, language_idlanguage, users_idusers, answer, question
FROM faq
WHERE faqCategories_idfaqCategories = '0' OR answer IS NULL
`

func (q *Queries) AdminGetFAQUnansweredQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, adminGetFAQUnansweredQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminRenameFAQCategory = `-- name: AdminRenameFAQCategory :exec
UPDATE faq_categories
SET name = ?
WHERE idfaqCategories = ?
`

type AdminRenameFAQCategoryParams struct {
	Name            sql.NullString
	Idfaqcategories int32
}

func (q *Queries) AdminRenameFAQCategory(ctx context.Context, arg AdminRenameFAQCategoryParams) error {
	_, err := q.db.ExecContext(ctx, adminRenameFAQCategory, arg.Name, arg.Idfaqcategories)
	return err
}

const adminUpdateFAQQuestionAnswer = `-- name: AdminUpdateFAQQuestionAnswer :exec
UPDATE faq
SET answer = ?, question = ?, faqCategories_idfaqCategories = ?
WHERE idfaq = ?
`

type AdminUpdateFAQQuestionAnswerParams struct {
	Answer                       sql.NullString
	Question                     sql.NullString
	FaqcategoriesIdfaqcategories int32
	Idfaq                        int32
}

func (q *Queries) AdminUpdateFAQQuestionAnswer(ctx context.Context, arg AdminUpdateFAQQuestionAnswerParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateFAQQuestionAnswer,
		arg.Answer,
		arg.Question,
		arg.FaqcategoriesIdfaqcategories,
		arg.Idfaq,
	)
	return err
}

const createFAQQuestion = `-- name: CreateFAQQuestion :exec
INSERT INTO faq (question, users_idusers, language_idlanguage)
VALUES (?, ?, ?)
`

type CreateFAQQuestionParams struct {
	Question           sql.NullString
	UsersIdusers       int32
	LanguageIdlanguage int32
}

func (q *Queries) CreateFAQQuestion(ctx context.Context, arg CreateFAQQuestionParams) error {
	_, err := q.db.ExecContext(ctx, createFAQQuestion, arg.Question, arg.UsersIdusers, arg.LanguageIdlanguage)
	return err
}

const getAllAnsweredFAQWithFAQCategories = `-- name: GetAllAnsweredFAQWithFAQCategories :many
SELECT c.idfaqcategories, c.name, f.idfaq, f.faqcategories_idfaqcategories, f.language_idlanguage, f.users_idusers, f.answer, f.question
FROM faq f
LEFT JOIN faq_categories c ON c.idfaqCategories = f.faqCategories_idfaqCategories
WHERE c.idfaqCategories <> 0 AND f.answer IS NOT NULL
ORDER BY c.idfaqCategories
`

type GetAllAnsweredFAQWithFAQCategoriesRow struct {
	Idfaqcategories              sql.NullInt32
	Name                         sql.NullString
	Idfaq                        int32
	FaqcategoriesIdfaqcategories int32
	LanguageIdlanguage           int32
	UsersIdusers                 int32
	Answer                       sql.NullString
	Question                     sql.NullString
}

func (q *Queries) GetAllAnsweredFAQWithFAQCategories(ctx context.Context) ([]*GetAllAnsweredFAQWithFAQCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAnsweredFAQWithFAQCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllAnsweredFAQWithFAQCategoriesRow
	for rows.Next() {
		var i GetAllAnsweredFAQWithFAQCategoriesRow
		if err := rows.Scan(
			&i.Idfaqcategories,
			&i.Name,
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAnsweredFAQWithFAQCategoriesForUser = `-- name: GetAllAnsweredFAQWithFAQCategoriesForUser :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT c.idfaqcategories, c.name, f.idfaq, f.faqcategories_idfaqcategories, f.language_idlanguage, f.users_idusers, f.answer, f.question
FROM faq f
LEFT JOIN faq_categories c ON c.idfaqCategories = f.faqCategories_idfaqCategories
WHERE c.idfaqCategories <> 0
  AND f.answer IS NOT NULL
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='faq'
        AND g.item='question'
        AND g.action='see'
        AND g.active=1
        AND g.item_id = f.idfaq
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
  AND (
      f.language_idlanguage = 0
      OR f.language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = f.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
ORDER BY c.idfaqCategories
`

type GetAllAnsweredFAQWithFAQCategoriesForUserParams struct {
	ViewerID int32
	UserID   sql.NullInt32
}

type GetAllAnsweredFAQWithFAQCategoriesForUserRow struct {
	Idfaqcategories              sql.NullInt32
	Name                         sql.NullString
	Idfaq                        int32
	FaqcategoriesIdfaqcategories int32
	LanguageIdlanguage           int32
	UsersIdusers                 int32
	Answer                       sql.NullString
	Question                     sql.NullString
}

func (q *Queries) GetAllAnsweredFAQWithFAQCategoriesForUser(ctx context.Context, arg GetAllAnsweredFAQWithFAQCategoriesForUserParams) ([]*GetAllAnsweredFAQWithFAQCategoriesForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAnsweredFAQWithFAQCategoriesForUser,
		arg.ViewerID,
		arg.UserID,
		arg.ViewerID,
		arg.ViewerID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllAnsweredFAQWithFAQCategoriesForUserRow
	for rows.Next() {
		var i GetAllAnsweredFAQWithFAQCategoriesForUserRow
		if err := rows.Scan(
			&i.Idfaqcategories,
			&i.Name,
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFAQQuestions = `-- name: GetAllFAQQuestions :many
SELECT idfaq, faqcategories_idfaqcategories, language_idlanguage, users_idusers, answer, question
FROM faq
`

func (q *Queries) GetAllFAQQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, getAllFAQQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFAQQuestionsForUser = `-- name: GetAllFAQQuestionsForUser :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT f.idfaq, f.faqcategories_idfaqcategories, f.language_idlanguage, f.users_idusers, f.answer, f.question
FROM faq f
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='faq'
      AND g.item='question'
      AND g.action='see'
      AND g.active=1
      AND g.item_id = f.idfaq
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
  AND (
      f.language_idlanguage = 0
      OR f.language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = f.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
`

type GetAllFAQQuestionsForUserParams struct {
	ViewerID int32
	UserID   sql.NullInt32
}

func (q *Queries) GetAllFAQQuestionsForUser(ctx context.Context, arg GetAllFAQQuestionsForUserParams) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, getAllFAQQuestionsForUser,
		arg.ViewerID,
		arg.UserID,
		arg.ViewerID,
		arg.ViewerID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFAQRevision = `-- name: InsertFAQRevision :exec
INSERT INTO faq_revisions (faq_id, users_idusers, question, answer)
VALUES (?, ?, ?, ?)
`

type InsertFAQRevisionParams struct {
	FaqID        int32
	UsersIdusers int32
	Question     sql.NullString
	Answer       sql.NullString
}

func (q *Queries) InsertFAQRevision(ctx context.Context, arg InsertFAQRevisionParams) error {
	_, err := q.db.ExecContext(ctx, insertFAQRevision,
		arg.FaqID,
		arg.UsersIdusers,
		arg.Question,
		arg.Answer,
	)
	return err
}

const insertFAQRevisionForUser = `-- name: InsertFAQRevisionForUser :exec
INSERT INTO faq_revisions (faq_id, users_idusers, question, answer)
SELECT ?, ?, ?, ?
FROM faq f
WHERE f.idfaq = ?
  AND (
      f.language_idlanguage = 0
      OR f.language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = f.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='faq'
        AND g.item='question'
        AND g.action='post'
        AND g.active=1
        AND g.item_id = f.idfaq
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (
            SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
        ))
  )
`

type InsertFAQRevisionForUserParams struct {
	FaqID        int32
	UsersIdusers int32
	Question     sql.NullString
	Answer       sql.NullString
	ViewerID     int32
	UserID       sql.NullInt32
}

func (q *Queries) InsertFAQRevisionForUser(ctx context.Context, arg InsertFAQRevisionForUserParams) error {
	_, err := q.db.ExecContext(ctx, insertFAQRevisionForUser,
		arg.FaqID,
		arg.UsersIdusers,
		arg.Question,
		arg.Answer,
		arg.FaqID,
		arg.ViewerID,
		arg.ViewerID,
		arg.UserID,
		arg.ViewerID,
	)
	return err
}
