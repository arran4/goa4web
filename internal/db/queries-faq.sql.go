// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries-faq.sql

package db

import (
	"context"
	"database/sql"
)

const adminCreateFAQ = `-- name: AdminCreateFAQ :execresult
INSERT INTO faq (question, answer, category_id, author_id, language_id, priority)
VALUES (?, ?, ?, ?, ?, ?)
`

type AdminCreateFAQParams struct {
	Question   sql.NullString
	Answer     sql.NullString
	CategoryID sql.NullInt32
	AuthorID   int32
	LanguageID sql.NullInt32
	Priority   int32
}

func (q *Queries) AdminCreateFAQ(ctx context.Context, arg AdminCreateFAQParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, adminCreateFAQ,
		arg.Question,
		arg.Answer,
		arg.CategoryID,
		arg.AuthorID,
		arg.LanguageID,
		arg.Priority,
	)
}

const adminCreateFAQCategory = `-- name: AdminCreateFAQCategory :execresult
INSERT INTO faq_categories (name, parent_category_id, language_id, priority) VALUES (?, ?, ?, ?)
`

type AdminCreateFAQCategoryParams struct {
	Name             sql.NullString
	ParentCategoryID sql.NullInt32
	LanguageID       sql.NullInt32
	Priority         int32
}

func (q *Queries) AdminCreateFAQCategory(ctx context.Context, arg AdminCreateFAQCategoryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, adminCreateFAQCategory,
		arg.Name,
		arg.ParentCategoryID,
		arg.LanguageID,
		arg.Priority,
	)
}

const adminDeleteFAQ = `-- name: AdminDeleteFAQ :exec
UPDATE faq SET deleted_at = NOW(), updated_at = NOW()
WHERE id = ?
`

func (q *Queries) AdminDeleteFAQ(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteFAQ, id)
	return err
}

const adminDeleteFAQCategory = `-- name: AdminDeleteFAQCategory :exec
UPDATE faq_categories SET deleted_at = NOW(), updated_at = NOW()
WHERE id = ?
`

func (q *Queries) AdminDeleteFAQCategory(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteFAQCategory, id)
	return err
}

const adminGetFAQActiveQuestions = `-- name: AdminGetFAQActiveQuestions :many
SELECT id, category_id, language_id, author_id, answer, question, priority, deleted_at, updated_at
FROM faq
WHERE answer IS NOT NULL
  AND category_id IS NOT NULL
  AND deleted_at IS NULL
`

func (q *Queries) AdminGetFAQActiveQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, adminGetFAQActiveQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.LanguageID,
			&i.AuthorID,
			&i.Answer,
			&i.Question,
			&i.Priority,
			&i.DeletedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetFAQByID = `-- name: AdminGetFAQByID :one
SELECT id, category_id, language_id, author_id, answer, question, priority, deleted_at, updated_at FROM faq WHERE id = ?
`

func (q *Queries) AdminGetFAQByID(ctx context.Context, id int32) (*Faq, error) {
	row := q.db.QueryRowContext(ctx, adminGetFAQByID, id)
	var i Faq
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.LanguageID,
		&i.AuthorID,
		&i.Answer,
		&i.Question,
		&i.Priority,
		&i.DeletedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const adminGetFAQCategories = `-- name: AdminGetFAQCategories :many
SELECT id, parent_category_id, language_id, name, deleted_at, priority, updated_at
FROM faq_categories
WHERE deleted_at IS NULL
`

func (q *Queries) AdminGetFAQCategories(ctx context.Context) ([]*FaqCategory, error) {
	rows, err := q.db.QueryContext(ctx, adminGetFAQCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FaqCategory
	for rows.Next() {
		var i FaqCategory
		if err := rows.Scan(
			&i.ID,
			&i.ParentCategoryID,
			&i.LanguageID,
			&i.Name,
			&i.DeletedAt,
			&i.Priority,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetFAQCategoriesWithQuestionCount = `-- name: AdminGetFAQCategoriesWithQuestionCount :many
SELECT c.id, c.parent_category_id, c.language_id, c.name, c.priority, c.updated_at, COUNT(f.id) AS QuestionCount
FROM faq_categories c
LEFT JOIN faq f ON f.category_id = c.id
WHERE c.deleted_at IS NULL
GROUP BY c.id, c.parent_category_id, c.language_id, c.name, c.priority, c.updated_at
ORDER BY c.priority DESC, c.name ASC
`

type AdminGetFAQCategoriesWithQuestionCountRow struct {
	ID               int32
	ParentCategoryID sql.NullInt32
	LanguageID       sql.NullInt32
	Name             sql.NullString
	Priority         int32
	UpdatedAt        sql.NullTime
	Questioncount    int64
}

func (q *Queries) AdminGetFAQCategoriesWithQuestionCount(ctx context.Context) ([]*AdminGetFAQCategoriesWithQuestionCountRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetFAQCategoriesWithQuestionCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminGetFAQCategoriesWithQuestionCountRow
	for rows.Next() {
		var i AdminGetFAQCategoriesWithQuestionCountRow
		if err := rows.Scan(
			&i.ID,
			&i.ParentCategoryID,
			&i.LanguageID,
			&i.Name,
			&i.Priority,
			&i.UpdatedAt,
			&i.Questioncount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetFAQCategory = `-- name: AdminGetFAQCategory :one
SELECT id, parent_category_id, language_id, name, deleted_at, priority, updated_at FROM faq_categories WHERE id = ?
`

func (q *Queries) AdminGetFAQCategory(ctx context.Context, id int32) (*FaqCategory, error) {
	row := q.db.QueryRowContext(ctx, adminGetFAQCategory, id)
	var i FaqCategory
	err := row.Scan(
		&i.ID,
		&i.ParentCategoryID,
		&i.LanguageID,
		&i.Name,
		&i.DeletedAt,
		&i.Priority,
		&i.UpdatedAt,
	)
	return &i, err
}

const adminGetFAQCategoryWithQuestionCountByID = `-- name: AdminGetFAQCategoryWithQuestionCountByID :one
SELECT c.id, c.parent_category_id, c.language_id, c.name, c.priority, c.updated_at, COUNT(f.id) AS QuestionCount
FROM faq_categories c
LEFT JOIN faq f ON f.category_id = c.id
WHERE c.id = ?
GROUP BY c.id, c.parent_category_id, c.language_id, c.name, c.priority, c.updated_at
`

type AdminGetFAQCategoryWithQuestionCountByIDRow struct {
	ID               int32
	ParentCategoryID sql.NullInt32
	LanguageID       sql.NullInt32
	Name             sql.NullString
	Priority         int32
	UpdatedAt        sql.NullTime
	Questioncount    int64
}

func (q *Queries) AdminGetFAQCategoryWithQuestionCountByID(ctx context.Context, id int32) (*AdminGetFAQCategoryWithQuestionCountByIDRow, error) {
	row := q.db.QueryRowContext(ctx, adminGetFAQCategoryWithQuestionCountByID, id)
	var i AdminGetFAQCategoryWithQuestionCountByIDRow
	err := row.Scan(
		&i.ID,
		&i.ParentCategoryID,
		&i.LanguageID,
		&i.Name,
		&i.Priority,
		&i.UpdatedAt,
		&i.Questioncount,
	)
	return &i, err
}

const adminGetFAQDismissedQuestions = `-- name: AdminGetFAQDismissedQuestions :many
SELECT id, category_id, language_id, author_id, answer, question
FROM faq
WHERE deleted_at IS NOT NULL
`

type AdminGetFAQDismissedQuestionsRow struct {
	ID         int32
	CategoryID sql.NullInt32
	LanguageID sql.NullInt32
	AuthorID   int32
	Answer     sql.NullString
	Question   sql.NullString
}

func (q *Queries) AdminGetFAQDismissedQuestions(ctx context.Context) ([]*AdminGetFAQDismissedQuestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetFAQDismissedQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminGetFAQDismissedQuestionsRow
	for rows.Next() {
		var i AdminGetFAQDismissedQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.LanguageID,
			&i.AuthorID,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetFAQQuestionsByCategory = `-- name: AdminGetFAQQuestionsByCategory :many
SELECT id, category_id, language_id, author_id, answer, question, priority, deleted_at, updated_at FROM faq WHERE category_id = ? ORDER BY priority DESC, id DESC
`

func (q *Queries) AdminGetFAQQuestionsByCategory(ctx context.Context, categoryID sql.NullInt32) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, adminGetFAQQuestionsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.LanguageID,
			&i.AuthorID,
			&i.Answer,
			&i.Question,
			&i.Priority,
			&i.DeletedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetFAQUnansweredQuestions = `-- name: AdminGetFAQUnansweredQuestions :many
SELECT id, category_id, language_id, author_id, answer, question, priority, deleted_at, updated_at
FROM faq
WHERE category_id IS NULL OR answer IS NULL
`

func (q *Queries) AdminGetFAQUnansweredQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, adminGetFAQUnansweredQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.LanguageID,
			&i.AuthorID,
			&i.Answer,
			&i.Question,
			&i.Priority,
			&i.DeletedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListFAQCategories = `-- name: AdminListFAQCategories :many
SELECT id, parent_category_id, language_id, name, deleted_at, priority, updated_at
FROM faq_categories
WHERE deleted_at IS NULL
ORDER BY parent_category_id, id
`

func (q *Queries) AdminListFAQCategories(ctx context.Context) ([]*FaqCategory, error) {
	rows, err := q.db.QueryContext(ctx, adminListFAQCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FaqCategory
	for rows.Next() {
		var i FaqCategory
		if err := rows.Scan(
			&i.ID,
			&i.ParentCategoryID,
			&i.LanguageID,
			&i.Name,
			&i.DeletedAt,
			&i.Priority,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminMoveFAQChildren = `-- name: AdminMoveFAQChildren :exec
UPDATE faq_categories SET parent_category_id = ?, updated_at = NOW() WHERE parent_category_id = ?
`

type AdminMoveFAQChildrenParams struct {
	NewParentID sql.NullInt32
	OldParentID sql.NullInt32
}

func (q *Queries) AdminMoveFAQChildren(ctx context.Context, arg AdminMoveFAQChildrenParams) error {
	_, err := q.db.ExecContext(ctx, adminMoveFAQChildren, arg.NewParentID, arg.OldParentID)
	return err
}

const adminMoveFAQContent = `-- name: AdminMoveFAQContent :exec
UPDATE faq SET category_id = ?, updated_at = NOW() WHERE category_id = ?
`

type AdminMoveFAQContentParams struct {
	NewCategoryID sql.NullInt32
	OldCategoryID sql.NullInt32
}

func (q *Queries) AdminMoveFAQContent(ctx context.Context, arg AdminMoveFAQContentParams) error {
	_, err := q.db.ExecContext(ctx, adminMoveFAQContent, arg.NewCategoryID, arg.OldCategoryID)
	return err
}

const adminRenameFAQCategory = `-- name: AdminRenameFAQCategory :exec
UPDATE faq_categories
SET name = ?, updated_at = NOW()
WHERE id = ?
`

type AdminRenameFAQCategoryParams struct {
	Name sql.NullString
	ID   int32
}

func (q *Queries) AdminRenameFAQCategory(ctx context.Context, arg AdminRenameFAQCategoryParams) error {
	_, err := q.db.ExecContext(ctx, adminRenameFAQCategory, arg.Name, arg.ID)
	return err
}

const adminUpdateFAQ = `-- name: AdminUpdateFAQ :exec
UPDATE faq
SET answer = ?, question = ?, category_id = ?, priority = ?, updated_at = NOW()
WHERE id = ?
`

type AdminUpdateFAQParams struct {
	Answer     sql.NullString
	Question   sql.NullString
	CategoryID sql.NullInt32
	Priority   int32
	ID         int32
}

func (q *Queries) AdminUpdateFAQ(ctx context.Context, arg AdminUpdateFAQParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateFAQ,
		arg.Answer,
		arg.Question,
		arg.CategoryID,
		arg.Priority,
		arg.ID,
	)
	return err
}

const adminUpdateFAQCategory = `-- name: AdminUpdateFAQCategory :exec
UPDATE faq_categories
SET name = ?, parent_category_id = ?, language_id = ?, priority = ?, updated_at = NOW()
WHERE id = ?
`

type AdminUpdateFAQCategoryParams struct {
	Name             sql.NullString
	ParentCategoryID sql.NullInt32
	LanguageID       sql.NullInt32
	Priority         int32
	ID               int32
}

func (q *Queries) AdminUpdateFAQCategory(ctx context.Context, arg AdminUpdateFAQCategoryParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateFAQCategory,
		arg.Name,
		arg.ParentCategoryID,
		arg.LanguageID,
		arg.Priority,
		arg.ID,
	)
	return err
}

const adminUpdateFAQPriority = `-- name: AdminUpdateFAQPriority :exec
UPDATE faq SET priority = ?, updated_at = NOW() WHERE id = ?
`

type AdminUpdateFAQPriorityParams struct {
	Priority int32
	ID       int32
}

func (q *Queries) AdminUpdateFAQPriority(ctx context.Context, arg AdminUpdateFAQPriorityParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateFAQPriority, arg.Priority, arg.ID)
	return err
}

const adminUpdateFAQQuestionAnswer = `-- name: AdminUpdateFAQQuestionAnswer :exec
UPDATE faq
SET answer = ?, question = ?, category_id = ?, updated_at = NOW()
WHERE id = ?
`

type AdminUpdateFAQQuestionAnswerParams struct {
	Answer     sql.NullString
	Question   sql.NullString
	CategoryID sql.NullInt32
	ID         int32
}

func (q *Queries) AdminUpdateFAQQuestionAnswer(ctx context.Context, arg AdminUpdateFAQQuestionAnswerParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateFAQQuestionAnswer,
		arg.Answer,
		arg.Question,
		arg.CategoryID,
		arg.ID,
	)
	return err
}

const createFAQQuestionForWriter = `-- name: CreateFAQQuestionForWriter :exec
INSERT INTO faq (question, author_id, language_id)
SELECT ?, ?, ?
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'faq'
      AND (g.item = 'question' OR g.item IS NULL)
      AND g.action = 'post'
      AND g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
)
`

type CreateFAQQuestionForWriterParams struct {
	Question   sql.NullString
	WriterID   int32
	LanguageID sql.NullInt32
	GranteeID  sql.NullInt32
}

func (q *Queries) CreateFAQQuestionForWriter(ctx context.Context, arg CreateFAQQuestionForWriterParams) error {
	_, err := q.db.ExecContext(ctx, createFAQQuestionForWriter,
		arg.Question,
		arg.WriterID,
		arg.LanguageID,
		arg.GranteeID,
		arg.WriterID,
	)
	return err
}

const getAllAnsweredFAQWithFAQCategoriesForUser = `-- name: GetAllAnsweredFAQWithFAQCategoriesForUser :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT c.id AS category_id, c.name, f.id AS faq_id, f.category_id, f.language_id, f.author_id, f.answer, f.question
FROM faq f
LEFT JOIN faq_categories c ON c.id = f.category_id
WHERE c.id IS NOT NULL
  AND f.answer IS NOT NULL
  AND (
      f.language_id = 0
      OR f.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = f.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='faq'
        AND (g.item='question/answer' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = f.id OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY c.id, f.id
`

type GetAllAnsweredFAQWithFAQCategoriesForUserParams struct {
	UserID sql.NullInt32
}

type GetAllAnsweredFAQWithFAQCategoriesForUserRow struct {
	CategoryID   sql.NullInt32
	Name         sql.NullString
	FaqID        int32
	CategoryID_2 sql.NullInt32
	LanguageID   sql.NullInt32
	AuthorID     int32
	Answer       sql.NullString
	Question     sql.NullString
}

func (q *Queries) GetAllAnsweredFAQWithFAQCategoriesForUser(ctx context.Context, arg GetAllAnsweredFAQWithFAQCategoriesForUserParams) ([]*GetAllAnsweredFAQWithFAQCategoriesForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAnsweredFAQWithFAQCategoriesForUser,
		arg.UserID,
		arg.UserID,
		arg.UserID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllAnsweredFAQWithFAQCategoriesForUserRow
	for rows.Next() {
		var i GetAllAnsweredFAQWithFAQCategoriesForUserRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.Name,
			&i.FaqID,
			&i.CategoryID_2,
			&i.LanguageID,
			&i.AuthorID,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFAQAnsweredQuestions = `-- name: GetFAQAnsweredQuestions :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT faq.id, faq.category_id, faq.language_id, faq.author_id, faq.answer, faq.question
FROM faq
WHERE answer IS NOT NULL
  AND deleted_at IS NULL
  AND (
      language_id = 0
      OR language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = faq.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='faq'
        AND (g.item='question/answer' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = faq.id OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type GetFAQAnsweredQuestionsParams struct {
	UserID sql.NullInt32
}

type GetFAQAnsweredQuestionsRow struct {
	ID         int32
	CategoryID sql.NullInt32
	LanguageID sql.NullInt32
	AuthorID   int32
	Answer     sql.NullString
	Question   sql.NullString
}

func (q *Queries) GetFAQAnsweredQuestions(ctx context.Context, arg GetFAQAnsweredQuestionsParams) ([]*GetFAQAnsweredQuestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFAQAnsweredQuestions,
		arg.UserID,
		arg.UserID,
		arg.UserID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetFAQAnsweredQuestionsRow
	for rows.Next() {
		var i GetFAQAnsweredQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.LanguageID,
			&i.AuthorID,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFAQByID = `-- name: GetFAQByID :one
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT faq.id, faq.category_id, faq.language_id, faq.author_id, faq.answer, faq.question
FROM faq
WHERE faq.id = ?
  AND deleted_at IS NULL
  AND (
      language_id = 0
      OR language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = faq.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='faq'
        AND (g.item='question/answer' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = faq.id OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type GetFAQByIDParams struct {
	UserID sql.NullInt32
	FaqID  int32
}

type GetFAQByIDRow struct {
	ID         int32
	CategoryID sql.NullInt32
	LanguageID sql.NullInt32
	AuthorID   int32
	Answer     sql.NullString
	Question   sql.NullString
}

func (q *Queries) GetFAQByID(ctx context.Context, arg GetFAQByIDParams) (*GetFAQByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getFAQByID,
		arg.UserID,
		arg.FaqID,
		arg.UserID,
		arg.UserID,
		arg.UserID,
	)
	var i GetFAQByIDRow
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.LanguageID,
		&i.AuthorID,
		&i.Answer,
		&i.Question,
	)
	return &i, err
}

const getFAQQuestionsByCategory = `-- name: GetFAQQuestionsByCategory :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT faq.id, faq.category_id, faq.language_id, faq.author_id, faq.answer, faq.question
FROM faq
WHERE faq.category_id = ?
  AND deleted_at IS NULL
  AND (
      language_id = 0
      OR language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = faq.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='faq'
        AND (g.item='question/answer' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = faq.id OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type GetFAQQuestionsByCategoryParams struct {
	UserID     sql.NullInt32
	CategoryID sql.NullInt32
}

type GetFAQQuestionsByCategoryRow struct {
	ID         int32
	CategoryID sql.NullInt32
	LanguageID sql.NullInt32
	AuthorID   int32
	Answer     sql.NullString
	Question   sql.NullString
}

func (q *Queries) GetFAQQuestionsByCategory(ctx context.Context, arg GetFAQQuestionsByCategoryParams) ([]*GetFAQQuestionsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getFAQQuestionsByCategory,
		arg.UserID,
		arg.CategoryID,
		arg.UserID,
		arg.UserID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetFAQQuestionsByCategoryRow
	for rows.Next() {
		var i GetFAQQuestionsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.LanguageID,
			&i.AuthorID,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFAQRevisionsForAdmin = `-- name: GetFAQRevisionsForAdmin :many
SELECT id, faq_id, users_idusers, question, answer, created_at, timezone FROM faq_revisions WHERE faq_id = ? ORDER BY id DESC
`

func (q *Queries) GetFAQRevisionsForAdmin(ctx context.Context, faqID int32) ([]*FaqRevision, error) {
	rows, err := q.db.QueryContext(ctx, getFAQRevisionsForAdmin, faqID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FaqRevision
	for rows.Next() {
		var i FaqRevision
		if err := rows.Scan(
			&i.ID,
			&i.FaqID,
			&i.UsersIdusers,
			&i.Question,
			&i.Answer,
			&i.CreatedAt,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFAQQuestionForWriter = `-- name: InsertFAQQuestionForWriter :execresult
INSERT INTO faq (question, answer, category_id, author_id, language_id, priority)
SELECT ?, ?, ?, ?, ?, ?
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'faq'
      AND (g.item = 'question' OR g.item IS NULL)
      AND g.action = 'post'
      AND g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
)
`

type InsertFAQQuestionForWriterParams struct {
	Question   sql.NullString
	Answer     sql.NullString
	CategoryID sql.NullInt32
	WriterID   int32
	LanguageID sql.NullInt32
	Priority   int32
	GranteeID  sql.NullInt32
}

func (q *Queries) InsertFAQQuestionForWriter(ctx context.Context, arg InsertFAQQuestionForWriterParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertFAQQuestionForWriter,
		arg.Question,
		arg.Answer,
		arg.CategoryID,
		arg.WriterID,
		arg.LanguageID,
		arg.Priority,
		arg.GranteeID,
		arg.WriterID,
	)
}

const insertFAQRevisionForUser = `-- name: InsertFAQRevisionForUser :exec
INSERT INTO faq_revisions (faq_id, users_idusers, question, answer, timezone)
SELECT ?, ?, ?, ?, ?
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'faq'
      AND (g.item = 'question' OR g.item IS NULL)
      AND g.action = 'post'
      AND g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
)
`

type InsertFAQRevisionForUserParams struct {
	FaqID        int32
	UsersIdusers int32
	Question     sql.NullString
	Answer       sql.NullString
	Timezone     sql.NullString
	UserID       sql.NullInt32
}

func (q *Queries) InsertFAQRevisionForUser(ctx context.Context, arg InsertFAQRevisionForUserParams) error {
	_, err := q.db.ExecContext(ctx, insertFAQRevisionForUser,
		arg.FaqID,
		arg.UsersIdusers,
		arg.Question,
		arg.Answer,
		arg.Timezone,
		arg.UserID,
		arg.UserID,
	)
	return err
}

const systemGetFAQQuestions = `-- name: SystemGetFAQQuestions :many
SELECT id, category_id, language_id, author_id, answer, question, priority, deleted_at, updated_at
FROM faq
`

func (q *Queries) SystemGetFAQQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, systemGetFAQQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.LanguageID,
			&i.AuthorID,
			&i.Answer,
			&i.Question,
			&i.Priority,
			&i.DeletedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
