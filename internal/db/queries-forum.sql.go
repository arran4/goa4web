// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-forum.sql

package db

import (
	"context"
	"database/sql"
)

const adminCreateForumCategory = `-- name: AdminCreateForumCategory :exec
INSERT INTO forumcategory (forumcategory_idforumcategory, language_idlanguage, title, description) VALUES (?, ?, ?, ?)
`

type AdminCreateForumCategoryParams struct {
	ForumcategoryIdforumcategory int32
	LanguageIdlanguage           int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) AdminCreateForumCategory(ctx context.Context, arg AdminCreateForumCategoryParams) error {
	_, err := q.db.ExecContext(ctx, adminCreateForumCategory,
		arg.ForumcategoryIdforumcategory,
		arg.LanguageIdlanguage,
		arg.Title,
		arg.Description,
	)
	return err
}

const adminDeleteForumCategory = `-- name: AdminDeleteForumCategory :exec
UPDATE forumcategory SET deleted_at = NOW() WHERE idforumcategory = ?
`

func (q *Queries) AdminDeleteForumCategory(ctx context.Context, idforumcategory int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteForumCategory, idforumcategory)
	return err
}

const adminDeleteForumTopic = `-- name: AdminDeleteForumTopic :exec
UPDATE forumtopic SET deleted_at = NOW() WHERE idforumtopic = ?
`

// Removes a forum topic by ID.
func (q *Queries) AdminDeleteForumTopic(ctx context.Context, idforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteForumTopic, idforumtopic)
	return err
}

const adminRebuildAllForumTopicMetaColumns = `-- name: AdminRebuildAllForumTopicMetaColumns :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
), lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
`

func (q *Queries) AdminRebuildAllForumTopicMetaColumns(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, adminRebuildAllForumTopicMetaColumns)
	return err
}

const adminUpdateForumCategory = `-- name: AdminUpdateForumCategory :exec
UPDATE forumcategory SET title = ?, description = ?, forumcategory_idforumcategory = ?, language_idlanguage = ? WHERE idforumcategory = ?
`

type AdminUpdateForumCategoryParams struct {
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	LanguageIdlanguage           int32
	Idforumcategory              int32
}

func (q *Queries) AdminUpdateForumCategory(ctx context.Context, arg AdminUpdateForumCategoryParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateForumCategory,
		arg.Title,
		arg.Description,
		arg.ForumcategoryIdforumcategory,
		arg.LanguageIdlanguage,
		arg.Idforumcategory,
	)
	return err
}

const adminUpdateForumTopic = `-- name: AdminUpdateForumTopic :exec
UPDATE forumtopic SET title = ?, description = ?, forumcategory_idforumcategory = ?, language_idlanguage = ? WHERE idforumtopic = ?
`

type AdminUpdateForumTopicParams struct {
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	LanguageIdlanguage           int32
	Idforumtopic                 int32
}

func (q *Queries) AdminUpdateForumTopic(ctx context.Context, arg AdminUpdateForumTopicParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateForumTopic,
		arg.Title,
		arg.Description,
		arg.ForumcategoryIdforumcategory,
		arg.LanguageIdlanguage,
		arg.Idforumtopic,
	)
	return err
}

const countForumCategoriesForViewer = `-- name: CountForumCategoriesForViewer :one
SELECT COUNT(*)
FROM forumcategory c
WHERE (
    c.language_idlanguage = 0
    OR c.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = c.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
`

type CountForumCategoriesForViewerParams struct {
	ViewerID int32
}

func (q *Queries) CountForumCategoriesForViewer(ctx context.Context, arg CountForumCategoriesForViewerParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countForumCategoriesForViewer, arg.ViewerID, arg.ViewerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllForumCategories = `-- name: GetAllForumCategories :many
SELECT f.idforumcategory, f.forumcategory_idforumcategory, f.language_idlanguage, f.title, f.description
FROM forumcategory f
WHERE (
    f.language_idlanguage = 0
    OR f.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = f.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
`

type GetAllForumCategoriesParams struct {
	ViewerID int32
}

func (q *Queries) GetAllForumCategories(ctx context.Context, arg GetAllForumCategoriesParams) ([]*Forumcategory, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumCategories, arg.ViewerID, arg.ViewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumcategory
	for rows.Next() {
		var i Forumcategory
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageIdlanguage,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllForumCategoriesWithSubcategoryCount = `-- name: GetAllForumCategoriesWithSubcategoryCount :many
SELECT c.idforumcategory, c.forumcategory_idforumcategory, c.language_idlanguage, c.title, c.description, COUNT(c2.idforumcategory) as SubcategoryCount,
       COUNT(t.idforumtopic)   as TopicCount
FROM forumcategory c
LEFT JOIN forumcategory c2 ON c.idforumcategory = c2.forumcategory_idforumcategory
LEFT JOIN forumtopic t ON c.idforumcategory = t.forumcategory_idforumcategory
WHERE (
    c.language_idlanguage = 0
    OR c.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = c.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
GROUP BY c.idforumcategory
`

type GetAllForumCategoriesWithSubcategoryCountParams struct {
	ViewerID int32
}

type GetAllForumCategoriesWithSubcategoryCountRow struct {
	Idforumcategory              int32
	ForumcategoryIdforumcategory int32
	LanguageIdlanguage           int32
	Title                        sql.NullString
	Description                  sql.NullString
	Subcategorycount             int64
	Topiccount                   int64
}

func (q *Queries) GetAllForumCategoriesWithSubcategoryCount(ctx context.Context, arg GetAllForumCategoriesWithSubcategoryCountParams) ([]*GetAllForumCategoriesWithSubcategoryCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumCategoriesWithSubcategoryCount, arg.ViewerID, arg.ViewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllForumCategoriesWithSubcategoryCountRow
	for rows.Next() {
		var i GetAllForumCategoriesWithSubcategoryCountRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageIdlanguage,
			&i.Title,
			&i.Description,
			&i.Subcategorycount,
			&i.Topiccount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllForumThreadsWithTopic = `-- name: GetAllForumThreadsWithTopic :many
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked, t.title AS topic_title
FROM forumthread th
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic = t.idforumtopic
ORDER BY t.idforumtopic, th.lastaddition DESC
`

type GetAllForumThreadsWithTopicRow struct {
	Idforumthread          int32
	Firstpost              int32
	Lastposter             int32
	ForumtopicIdforumtopic int32
	Comments               sql.NullInt32
	Lastaddition           sql.NullTime
	Locked                 sql.NullBool
	TopicTitle             sql.NullString
}

func (q *Queries) GetAllForumThreadsWithTopic(ctx context.Context) ([]*GetAllForumThreadsWithTopicRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumThreadsWithTopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllForumThreadsWithTopicRow
	for rows.Next() {
		var i GetAllForumThreadsWithTopicRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Firstpost,
			&i.Lastposter,
			&i.ForumtopicIdforumtopic,
			&i.Comments,
			&i.Lastaddition,
			&i.Locked,
			&i.TopicTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllForumTopics = `-- name: GetAllForumTopics :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.language_idlanguage, t.title, t.description, t.threads, t.comments, t.lastaddition
FROM forumtopic t
WHERE (
    t.language_idlanguage = 0
    OR t.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = t.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
GROUP BY t.idforumtopic
`

type GetAllForumTopicsParams struct {
	ViewerID int32
}

func (q *Queries) GetAllForumTopics(ctx context.Context, arg GetAllForumTopicsParams) ([]*Forumtopic, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumTopics, arg.ViewerID, arg.ViewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumtopic
	for rows.Next() {
		var i Forumtopic
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageIdlanguage,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllForumTopicsByCategoryIdForUserWithLastPosterName = `-- name: GetAllForumTopicsByCategoryIdForUserWithLastPosterName :many
WITH role_ids AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.language_idlanguage, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername
FROM forumtopic t
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE t.forumcategory_idforumcategory = ?
  AND (
      t.language_idlanguage = 0
      OR t.language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = t.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='see'
      AND g.active=1
      AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY t.lastaddition DESC
`

type GetAllForumTopicsByCategoryIdForUserWithLastPosterNameParams struct {
	ViewerID      int32
	CategoryID    int32
	ViewerMatchID sql.NullInt32
}

type GetAllForumTopicsByCategoryIdForUserWithLastPosterNameRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	LanguageIdlanguage           int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
}

func (q *Queries) GetAllForumTopicsByCategoryIdForUserWithLastPosterName(ctx context.Context, arg GetAllForumTopicsByCategoryIdForUserWithLastPosterNameParams) ([]*GetAllForumTopicsByCategoryIdForUserWithLastPosterNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumTopicsByCategoryIdForUserWithLastPosterName,
		arg.ViewerID,
		arg.CategoryID,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerMatchID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllForumTopicsByCategoryIdForUserWithLastPosterNameRow
	for rows.Next() {
		var i GetAllForumTopicsByCategoryIdForUserWithLastPosterNameRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageIdlanguage,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Lastposterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllForumTopicsForUser = `-- name: GetAllForumTopicsForUser :many
WITH role_ids AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.language_idlanguage, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername
FROM forumtopic t
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE (
    t.language_idlanguage = 0
    OR t.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = t.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='see'
      AND g.active=1
      AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY t.lastaddition DESC
`

type GetAllForumTopicsForUserParams struct {
	ViewerID      int32
	ViewerMatchID sql.NullInt32
}

type GetAllForumTopicsForUserRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	LanguageIdlanguage           int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
}

func (q *Queries) GetAllForumTopicsForUser(ctx context.Context, arg GetAllForumTopicsForUserParams) ([]*GetAllForumTopicsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumTopicsForUser,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerMatchID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllForumTopicsForUserRow
	for rows.Next() {
		var i GetAllForumTopicsForUserRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageIdlanguage,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Lastposterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForumCategoryById = `-- name: GetForumCategoryById :one
SELECT idforumcategory, forumcategory_idforumcategory, language_idlanguage, title, description FROM forumcategory
WHERE idforumcategory = ?
  AND (
      language_idlanguage = 0
      OR language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
`

type GetForumCategoryByIdParams struct {
	Idforumcategory int32
	ViewerID        int32
}

func (q *Queries) GetForumCategoryById(ctx context.Context, arg GetForumCategoryByIdParams) (*Forumcategory, error) {
	row := q.db.QueryRowContext(ctx, getForumCategoryById, arg.Idforumcategory, arg.ViewerID, arg.ViewerID)
	var i Forumcategory
	err := row.Scan(
		&i.Idforumcategory,
		&i.ForumcategoryIdforumcategory,
		&i.LanguageIdlanguage,
		&i.Title,
		&i.Description,
	)
	return &i, err
}

const getForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostText = `-- name: GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostText :many
WITH role_ids AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked, lu.username AS lastposterusername, lu.idusers AS lastposterid, fcu.username as firstpostusername, fc.written as firstpostwritten, fc.text as firstposttext
FROM forumthread th
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN users lu ON lu.idusers = t.lastposter
LEFT JOIN comments fc ON th.firstpost=fc.idcomments
LEFT JOIN users fcu ON fcu.idusers = fc.users_idusers
WHERE th.forumtopic_idforumtopic=?
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='view'
      AND g.active=1
      AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY th.lastaddition DESC
`

type GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextParams struct {
	ViewerID      int32
	TopicID       int32
	ViewerMatchID sql.NullInt32
}

type GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextRow struct {
	Idforumthread          int32
	Firstpost              int32
	Lastposter             int32
	ForumtopicIdforumtopic int32
	Comments               sql.NullInt32
	Lastaddition           sql.NullTime
	Locked                 sql.NullBool
	Lastposterusername     sql.NullString
	Lastposterid           sql.NullInt32
	Firstpostusername      sql.NullString
	Firstpostwritten       sql.NullTime
	Firstposttext          sql.NullString
}

func (q *Queries) GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostText(ctx context.Context, arg GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextParams) ([]*GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextRow, error) {
	rows, err := q.db.QueryContext(ctx, getForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostText, arg.ViewerID, arg.TopicID, arg.ViewerMatchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextRow
	for rows.Next() {
		var i GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Firstpost,
			&i.Lastposter,
			&i.ForumtopicIdforumtopic,
			&i.Comments,
			&i.Lastaddition,
			&i.Locked,
			&i.Lastposterusername,
			&i.Lastposterid,
			&i.Firstpostusername,
			&i.Firstpostwritten,
			&i.Firstposttext,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForumTopicById = `-- name: GetForumTopicById :one
SELECT idforumtopic, lastposter, forumcategory_idforumcategory, language_idlanguage, title, description, threads, comments, lastaddition
FROM forumtopic
WHERE idforumtopic = ?
`

func (q *Queries) GetForumTopicById(ctx context.Context, idforumtopic int32) (*Forumtopic, error) {
	row := q.db.QueryRowContext(ctx, getForumTopicById, idforumtopic)
	var i Forumtopic
	err := row.Scan(
		&i.Idforumtopic,
		&i.Lastposter,
		&i.ForumcategoryIdforumcategory,
		&i.LanguageIdlanguage,
		&i.Title,
		&i.Description,
		&i.Threads,
		&i.Comments,
		&i.Lastaddition,
	)
	return &i, err
}

const getForumTopicByIdForUser = `-- name: GetForumTopicByIdForUser :one
WITH role_ids AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.language_idlanguage, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername
FROM forumtopic t
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE t.idforumtopic = ?
  AND (
      t.language_idlanguage = 0
      OR t.language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = t.language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='view'
      AND g.active=1
      AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY t.lastaddition DESC
`

type GetForumTopicByIdForUserParams struct {
	ViewerID      int32
	Idforumtopic  int32
	ViewerMatchID sql.NullInt32
}

type GetForumTopicByIdForUserRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	LanguageIdlanguage           int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
}

func (q *Queries) GetForumTopicByIdForUser(ctx context.Context, arg GetForumTopicByIdForUserParams) (*GetForumTopicByIdForUserRow, error) {
	row := q.db.QueryRowContext(ctx, getForumTopicByIdForUser,
		arg.ViewerID,
		arg.Idforumtopic,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerMatchID,
	)
	var i GetForumTopicByIdForUserRow
	err := row.Scan(
		&i.Idforumtopic,
		&i.Lastposter,
		&i.ForumcategoryIdforumcategory,
		&i.LanguageIdlanguage,
		&i.Title,
		&i.Description,
		&i.Threads,
		&i.Comments,
		&i.Lastaddition,
		&i.Lastposterusername,
	)
	return &i, err
}

const getForumTopicsByCategoryId = `-- name: GetForumTopicsByCategoryId :many
SELECT idforumtopic, lastposter, forumcategory_idforumcategory, language_idlanguage, title, description, threads, comments, lastaddition FROM forumtopic
WHERE forumcategory_idforumcategory = ?
  AND (
      language_idlanguage = 0
      OR language_idlanguage IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_idlanguage = language_idlanguage
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
ORDER BY lastaddition DESC
`

type GetForumTopicsByCategoryIdParams struct {
	CategoryID int32
	ViewerID   int32
}

func (q *Queries) GetForumTopicsByCategoryId(ctx context.Context, arg GetForumTopicsByCategoryIdParams) ([]*Forumtopic, error) {
	rows, err := q.db.QueryContext(ctx, getForumTopicsByCategoryId, arg.CategoryID, arg.ViewerID, arg.ViewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumtopic
	for rows.Next() {
		var i Forumtopic
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageIdlanguage,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listForumCategoriesWithCountsPaginatedForViewer = `-- name: ListForumCategoriesWithCountsPaginatedForViewer :many
SELECT c.idforumcategory, c.forumcategory_idforumcategory, c.language_idlanguage, c.title, c.description, COUNT(c2.idforumcategory) AS SubcategoryCount,
       COUNT(t.idforumtopic) AS TopicCount
FROM forumcategory c
LEFT JOIN forumcategory c2 ON c.idforumcategory = c2.forumcategory_idforumcategory
LEFT JOIN forumtopic t ON c.idforumcategory = t.forumcategory_idforumcategory
WHERE (
    c.language_idlanguage = 0
    OR c.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = c.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
GROUP BY c.idforumcategory
ORDER BY c.idforumcategory
LIMIT ? OFFSET ?
`

type ListForumCategoriesWithCountsPaginatedForViewerParams struct {
	ViewerID int32
	Limit    int32
	Offset   int32
}

type ListForumCategoriesWithCountsPaginatedForViewerRow struct {
	Idforumcategory              int32
	ForumcategoryIdforumcategory int32
	LanguageIdlanguage           int32
	Title                        sql.NullString
	Description                  sql.NullString
	Subcategorycount             int64
	Topiccount                   int64
}

func (q *Queries) ListForumCategoriesWithCountsPaginatedForViewer(ctx context.Context, arg ListForumCategoriesWithCountsPaginatedForViewerParams) ([]*ListForumCategoriesWithCountsPaginatedForViewerRow, error) {
	rows, err := q.db.QueryContext(ctx, listForumCategoriesWithCountsPaginatedForViewer,
		arg.ViewerID,
		arg.ViewerID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListForumCategoriesWithCountsPaginatedForViewerRow
	for rows.Next() {
		var i ListForumCategoriesWithCountsPaginatedForViewerRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageIdlanguage,
			&i.Title,
			&i.Description,
			&i.Subcategorycount,
			&i.Topiccount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listForumcategoryPath = `-- name: ListForumcategoryPath :many
WITH RECURSIVE category_path AS (
    SELECT f.idforumcategory, f.forumcategory_idforumcategory AS parent_id, f.title, 0 AS depth
    FROM forumcategory f
    WHERE f.idforumcategory = ?
    UNION ALL
    SELECT c.idforumcategory, c.forumcategory_idforumcategory, c.title, p.depth + 1
    FROM forumcategory c
    JOIN category_path p ON p.parent_id = c.idforumcategory
)
SELECT category_path.idforumcategory, category_path.title
FROM category_path
ORDER BY category_path.depth DESC
`

type ListForumcategoryPathRow struct {
	Idforumcategory int32
	Title           sql.NullString
}

func (q *Queries) ListForumcategoryPath(ctx context.Context, categoryID int32) ([]*ListForumcategoryPathRow, error) {
	rows, err := q.db.QueryContext(ctx, listForumcategoryPath, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListForumcategoryPathRow
	for rows.Next() {
		var i ListForumcategoryPathRow
		if err := rows.Scan(&i.Idforumcategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemCreateForumTopic = `-- name: SystemCreateForumTopic :execlastid
INSERT INTO forumtopic (forumcategory_idforumcategory, language_idlanguage, title, description) VALUES (?, ?, ?, ?)
`

type SystemCreateForumTopicParams struct {
	ForumcategoryIdforumcategory int32
	LanguageIdlanguage           int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) SystemCreateForumTopic(ctx context.Context, arg SystemCreateForumTopicParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, systemCreateForumTopic,
		arg.ForumcategoryIdforumcategory,
		arg.LanguageIdlanguage,
		arg.Title,
		arg.Description,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const systemGetForumTopicByTitle = `-- name: SystemGetForumTopicByTitle :one
SELECT idforumtopic, lastposter, forumcategory_idforumcategory, language_idlanguage, title, description, threads, comments, lastaddition
FROM forumtopic
WHERE title=?
`

func (q *Queries) SystemGetForumTopicByTitle(ctx context.Context, title sql.NullString) (*Forumtopic, error) {
	row := q.db.QueryRowContext(ctx, systemGetForumTopicByTitle, title)
	var i Forumtopic
	err := row.Scan(
		&i.Idforumtopic,
		&i.Lastposter,
		&i.ForumcategoryIdforumcategory,
		&i.LanguageIdlanguage,
		&i.Title,
		&i.Description,
		&i.Threads,
		&i.Comments,
		&i.Lastaddition,
	)
	return &i, err
}

const systemRebuildForumTopicMetaByID = `-- name: SystemRebuildForumTopicMetaByID :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
), lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
WHERE idforumtopic = ?
`

func (q *Queries) SystemRebuildForumTopicMetaByID(ctx context.Context, idforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, systemRebuildForumTopicMetaByID, idforumtopic)
	return err
}
