// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries-forum.sql

package db

import (
	"context"
	"database/sql"
)

const adminCountForumCategories = `-- name: AdminCountForumCategories :one
SELECT COUNT(*)
FROM forumcategory c
WHERE (
    c.language_id = 0
    OR c.language_id IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_id = c.language_id
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
`

type AdminCountForumCategoriesParams struct {
	ViewerID int32
}

func (q *Queries) AdminCountForumCategories(ctx context.Context, arg AdminCountForumCategoriesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, adminCountForumCategories, arg.ViewerID, arg.ViewerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminCreateForumCategory = `-- name: AdminCreateForumCategory :execlastid
INSERT INTO forumcategory (forumcategory_idforumcategory, language_id, title, description)
VALUES (?, ?, ?, ?)
`

type AdminCreateForumCategoryParams struct {
	ParentID           int32
	CategoryLanguageID sql.NullInt32
	Title              sql.NullString
	Description        sql.NullString
}

func (q *Queries) AdminCreateForumCategory(ctx context.Context, arg AdminCreateForumCategoryParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, adminCreateForumCategory,
		arg.ParentID,
		arg.CategoryLanguageID,
		arg.Title,
		arg.Description,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const adminCreateForumTopic = `-- name: AdminCreateForumTopic :execlastid
INSERT INTO forumtopic (forumcategory_idforumcategory, language_id, title, description, handler)
VALUES (?, ?, ?, ?, ?)
`

type AdminCreateForumTopicParams struct {
	ForumcategoryID int32
	LanguageID      sql.NullInt32
	Title           sql.NullString
	Description     sql.NullString
	Handler         string
}

func (q *Queries) AdminCreateForumTopic(ctx context.Context, arg AdminCreateForumTopicParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, adminCreateForumTopic,
		arg.ForumcategoryID,
		arg.LanguageID,
		arg.Title,
		arg.Description,
		arg.Handler,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const adminDeleteForumCategory = `-- name: AdminDeleteForumCategory :exec
UPDATE forumcategory SET deleted_at = NOW() WHERE idforumcategory = ?
`

func (q *Queries) AdminDeleteForumCategory(ctx context.Context, idforumcategory int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteForumCategory, idforumcategory)
	return err
}

const adminDeleteForumTopic = `-- name: AdminDeleteForumTopic :exec
DELETE FROM forumtopic WHERE idforumtopic = ?
`

// Removes a forum topic by ID.
func (q *Queries) AdminDeleteForumTopic(ctx context.Context, idforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteForumTopic, idforumtopic)
	return err
}

const adminGetTopicGrants = `-- name: AdminGetTopicGrants :many
SELECT g.section, g.role_id, r.name as role_name, g.user_id, u.username
FROM grants g
LEFT JOIN roles r ON r.id = g.role_id
LEFT JOIN users u ON u.idusers = g.user_id
WHERE (g.item = 'topic')
  AND g.item_id = ?
  AND g.active = 1
`

type AdminGetTopicGrantsRow struct {
	Section  string
	RoleID   sql.NullInt32
	RoleName sql.NullString
	UserID   sql.NullInt32
	Username sql.NullString
}

func (q *Queries) AdminGetTopicGrants(ctx context.Context, topicID sql.NullInt32) ([]*AdminGetTopicGrantsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetTopicGrants, topicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminGetTopicGrantsRow
	for rows.Next() {
		var i AdminGetTopicGrantsRow
		if err := rows.Scan(
			&i.Section,
			&i.RoleID,
			&i.RoleName,
			&i.UserID,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListForumCategoriesWithCounts = `-- name: AdminListForumCategoriesWithCounts :many
SELECT c.idforumcategory, c.forumcategory_idforumcategory, c.language_id, c.title, c.description, COUNT(c2.idforumcategory) AS SubcategoryCount,
       COUNT(t.idforumtopic) AS TopicCount
FROM forumcategory c
LEFT JOIN forumcategory c2 ON c.idforumcategory = c2.forumcategory_idforumcategory
LEFT JOIN forumtopic t ON c.idforumcategory = t.forumcategory_idforumcategory
WHERE (
    c.language_id = 0
    OR c.language_id IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_id = c.language_id
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
GROUP BY c.idforumcategory
ORDER BY c.idforumcategory
LIMIT ? OFFSET ?
`

type AdminListForumCategoriesWithCountsParams struct {
	ViewerID int32
	Limit    int32
	Offset   int32
}

type AdminListForumCategoriesWithCountsRow struct {
	Idforumcategory              int32
	ForumcategoryIdforumcategory int32
	LanguageID                   sql.NullInt32
	Title                        sql.NullString
	Description                  sql.NullString
	Subcategorycount             int64
	Topiccount                   int64
}

func (q *Queries) AdminListForumCategoriesWithCounts(ctx context.Context, arg AdminListForumCategoriesWithCountsParams) ([]*AdminListForumCategoriesWithCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListForumCategoriesWithCounts,
		arg.ViewerID,
		arg.ViewerID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListForumCategoriesWithCountsRow
	for rows.Next() {
		var i AdminListForumCategoriesWithCountsRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageID,
			&i.Title,
			&i.Description,
			&i.Subcategorycount,
			&i.Topiccount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListForumTopicGrantsByTopicID = `-- name: AdminListForumTopicGrantsByTopicID :many
SELECT
    g.id,
    g.section,
    g.action,
    r.name AS role_name,
    u.username
FROM
    grants g
LEFT JOIN
    roles r ON g.role_id = r.id
LEFT JOIN
    users u ON g.user_id = u.idusers
WHERE
    g.section = 'forum'
    AND (g.item = 'topic' OR g.item IS NULL)
    AND g.item_id = ?
`

type AdminListForumTopicGrantsByTopicIDRow struct {
	ID       int32
	Section  string
	Action   string
	RoleName sql.NullString
	Username sql.NullString
}

func (q *Queries) AdminListForumTopicGrantsByTopicID(ctx context.Context, itemID sql.NullInt32) ([]*AdminListForumTopicGrantsByTopicIDRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListForumTopicGrantsByTopicID, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListForumTopicGrantsByTopicIDRow
	for rows.Next() {
		var i AdminListForumTopicGrantsByTopicIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Section,
			&i.Action,
			&i.RoleName,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListForumTopics = `-- name: AdminListForumTopics :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.language_id, t.title, t.description, t.threads, t.comments, t.lastaddition, t.handler
FROM forumtopic t
ORDER BY t.idforumtopic
LIMIT ? OFFSET ?
`

type AdminListForumTopicsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) AdminListForumTopics(ctx context.Context, arg AdminListForumTopicsParams) ([]*Forumtopic, error) {
	rows, err := q.db.QueryContext(ctx, adminListForumTopics, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumtopic
	for rows.Next() {
		var i Forumtopic
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageID,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Handler,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListPrivateTopicParticipantsByTopicID = `-- name: AdminListPrivateTopicParticipantsByTopicID :many
SELECT u.idusers, u.username
FROM grants g
JOIN users u ON u.idusers = g.user_id
WHERE g.section = 'privateforum'
  AND g.item = 'topic'
  AND g.action = 'view'
  AND g.active = 1
  AND g.user_id IS NOT NULL
  AND g.item_id = ?
`

type AdminListPrivateTopicParticipantsByTopicIDRow struct {
	Idusers  int32
	Username sql.NullString
}

func (q *Queries) AdminListPrivateTopicParticipantsByTopicID(ctx context.Context, itemID sql.NullInt32) ([]*AdminListPrivateTopicParticipantsByTopicIDRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListPrivateTopicParticipantsByTopicID, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListPrivateTopicParticipantsByTopicIDRow
	for rows.Next() {
		var i AdminListPrivateTopicParticipantsByTopicIDRow
		if err := rows.Scan(&i.Idusers, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListTopicsWithUserGrantsNoRoles = `-- name: AdminListTopicsWithUserGrantsNoRoles :many
SELECT t.idforumtopic, t.title
FROM forumtopic t
WHERE t.handler <> 'private'
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum' AND g.item='topic' AND g.active=1
      AND g.item_id = t.idforumtopic
      AND g.user_id IS NOT NULL
      AND (? OR g.user_id <> 1)
  )
  AND NOT EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum' AND g.item='topic' AND g.active=1
      AND g.item_id = t.idforumtopic
      AND g.role_id IS NOT NULL
  )
ORDER BY t.idforumtopic
`

type AdminListTopicsWithUserGrantsNoRolesRow struct {
	Idforumtopic int32
	Title        sql.NullString
}

func (q *Queries) AdminListTopicsWithUserGrantsNoRoles(ctx context.Context, includeAdmin interface{}) ([]*AdminListTopicsWithUserGrantsNoRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListTopicsWithUserGrantsNoRoles, includeAdmin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListTopicsWithUserGrantsNoRolesRow
	for rows.Next() {
		var i AdminListTopicsWithUserGrantsNoRolesRow
		if err := rows.Scan(&i.Idforumtopic, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminRebuildAllForumTopicMetaColumns = `-- name: AdminRebuildAllForumTopicMetaColumns :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
), lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
`

func (q *Queries) AdminRebuildAllForumTopicMetaColumns(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, adminRebuildAllForumTopicMetaColumns)
	return err
}

const adminUpdateForumCategory = `-- name: AdminUpdateForumCategory :exec
UPDATE forumcategory
SET title = ?,
    description = ?,
    forumcategory_idforumcategory = ?,
    language_id = ?
WHERE idforumcategory = ?
`

type AdminUpdateForumCategoryParams struct {
	Title           sql.NullString
	Description     sql.NullString
	ParentID        int32
	LanguageID      sql.NullInt32
	Idforumcategory int32
}

func (q *Queries) AdminUpdateForumCategory(ctx context.Context, arg AdminUpdateForumCategoryParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateForumCategory,
		arg.Title,
		arg.Description,
		arg.ParentID,
		arg.LanguageID,
		arg.Idforumcategory,
	)
	return err
}

const adminUpdateForumTopic = `-- name: AdminUpdateForumTopic :exec
UPDATE forumtopic SET title = ?, description = ?, forumcategory_idforumcategory = ?, language_id = ? WHERE idforumtopic = ?
`

type AdminUpdateForumTopicParams struct {
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	TopicLanguageID              sql.NullInt32
	Idforumtopic                 int32
}

func (q *Queries) AdminUpdateForumTopic(ctx context.Context, arg AdminUpdateForumTopicParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateForumTopic,
		arg.Title,
		arg.Description,
		arg.ForumcategoryIdforumcategory,
		arg.TopicLanguageID,
		arg.Idforumtopic,
	)
	return err
}

const createForumTopicForPoster = `-- name: CreateForumTopicForPoster :execlastid
INSERT INTO forumtopic (forumcategory_idforumcategory, language_id, title, description, handler)
SELECT ?, ?, ?, ?, ?
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section=?
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='create'
      AND g.active=1
      AND (g.item_id = ? OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
  )
`

type CreateForumTopicForPosterParams struct {
	ForumcategoryID int32
	ForumLang       sql.NullInt32
	Title           sql.NullString
	Description     sql.NullString
	Handler         string
	Section         string
	GrantCategoryID sql.NullInt32
	GranteeID       sql.NullInt32
	PosterID        int32
}

func (q *Queries) CreateForumTopicForPoster(ctx context.Context, arg CreateForumTopicForPosterParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createForumTopicForPoster,
		arg.ForumcategoryID,
		arg.ForumLang,
		arg.Title,
		arg.Description,
		arg.Handler,
		arg.Section,
		arg.GrantCategoryID,
		arg.GranteeID,
		arg.PosterID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const getAllForumCategories = `-- name: GetAllForumCategories :many
SELECT f.idforumcategory, f.forumcategory_idforumcategory, f.language_id, f.title, f.description
FROM forumcategory f
WHERE (
    f.language_id = 0
    OR f.language_id IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_id = f.language_id
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
`

type GetAllForumCategoriesParams struct {
	ViewerID int32
}

func (q *Queries) GetAllForumCategories(ctx context.Context, arg GetAllForumCategoriesParams) ([]*Forumcategory, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumCategories, arg.ViewerID, arg.ViewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumcategory
	for rows.Next() {
		var i Forumcategory
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageID,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllForumCategoriesWithSubcategoryCount = `-- name: GetAllForumCategoriesWithSubcategoryCount :many
SELECT c.idforumcategory, c.forumcategory_idforumcategory, c.language_id, c.title, c.description, COUNT(c2.idforumcategory) as SubcategoryCount,
       COUNT(t.idforumtopic)   as TopicCount
FROM forumcategory c
LEFT JOIN forumcategory c2 ON c.idforumcategory = c2.forumcategory_idforumcategory
LEFT JOIN forumtopic t ON c.idforumcategory = t.forumcategory_idforumcategory
WHERE (
    c.language_id = 0
    OR c.language_id IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_id = c.language_id
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
GROUP BY c.idforumcategory
`

type GetAllForumCategoriesWithSubcategoryCountParams struct {
	ViewerID int32
}

type GetAllForumCategoriesWithSubcategoryCountRow struct {
	Idforumcategory              int32
	ForumcategoryIdforumcategory int32
	LanguageID                   sql.NullInt32
	Title                        sql.NullString
	Description                  sql.NullString
	Subcategorycount             int64
	Topiccount                   int64
}

func (q *Queries) GetAllForumCategoriesWithSubcategoryCount(ctx context.Context, arg GetAllForumCategoriesWithSubcategoryCountParams) ([]*GetAllForumCategoriesWithSubcategoryCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumCategoriesWithSubcategoryCount, arg.ViewerID, arg.ViewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllForumCategoriesWithSubcategoryCountRow
	for rows.Next() {
		var i GetAllForumCategoriesWithSubcategoryCountRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageID,
			&i.Title,
			&i.Description,
			&i.Subcategorycount,
			&i.Topiccount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllForumThreadsWithTopic = `-- name: GetAllForumThreadsWithTopic :many
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked, t.title AS topic_title
FROM forumthread th
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic = t.idforumtopic
ORDER BY t.idforumtopic, th.lastaddition DESC
`

type GetAllForumThreadsWithTopicRow struct {
	Idforumthread          int32
	Firstpost              int32
	Lastposter             int32
	ForumtopicIdforumtopic int32
	Comments               sql.NullInt32
	Lastaddition           sql.NullTime
	Locked                 sql.NullBool
	TopicTitle             sql.NullString
}

func (q *Queries) GetAllForumThreadsWithTopic(ctx context.Context) ([]*GetAllForumThreadsWithTopicRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumThreadsWithTopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllForumThreadsWithTopicRow
	for rows.Next() {
		var i GetAllForumThreadsWithTopicRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Firstpost,
			&i.Lastposter,
			&i.ForumtopicIdforumtopic,
			&i.Comments,
			&i.Lastaddition,
			&i.Locked,
			&i.TopicTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllForumTopics = `-- name: GetAllForumTopics :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.language_id, t.title, t.description, t.threads, t.comments, t.lastaddition, t.handler
FROM forumtopic t
WHERE (
    t.language_id = 0
    OR t.language_id IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_id = t.language_id
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
GROUP BY t.idforumtopic
`

type GetAllForumTopicsParams struct {
	ViewerID int32
}

func (q *Queries) GetAllForumTopics(ctx context.Context, arg GetAllForumTopicsParams) ([]*Forumtopic, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumTopics, arg.ViewerID, arg.ViewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumtopic
	for rows.Next() {
		var i Forumtopic
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageID,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Handler,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllForumTopicsByCategoryIdForUserWithLastPosterName = `-- name: GetAllForumTopicsByCategoryIdForUserWithLastPosterName :many
WITH role_ids AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.language_id, t.title, t.description, t.threads, t.comments, t.lastaddition, t.handler, lu.username AS LastPosterUsername
FROM forumtopic t
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE t.forumcategory_idforumcategory = ?
  AND (
      t.language_id = 0
      OR t.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = t.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='see'
      AND g.active=1
      AND ((t.handler = 'private' AND g.item_id = t.idforumtopic) OR (t.handler <> 'private' AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)))
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY t.lastaddition DESC
`

type GetAllForumTopicsByCategoryIdForUserWithLastPosterNameParams struct {
	ViewerID      int32
	CategoryID    int32
	ViewerMatchID sql.NullInt32
}

type GetAllForumTopicsByCategoryIdForUserWithLastPosterNameRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	LanguageID                   sql.NullInt32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Handler                      string
	Lastposterusername           sql.NullString
}

func (q *Queries) GetAllForumTopicsByCategoryIdForUserWithLastPosterName(ctx context.Context, arg GetAllForumTopicsByCategoryIdForUserWithLastPosterNameParams) ([]*GetAllForumTopicsByCategoryIdForUserWithLastPosterNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumTopicsByCategoryIdForUserWithLastPosterName,
		arg.ViewerID,
		arg.CategoryID,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerMatchID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllForumTopicsByCategoryIdForUserWithLastPosterNameRow
	for rows.Next() {
		var i GetAllForumTopicsByCategoryIdForUserWithLastPosterNameRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageID,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Handler,
			&i.Lastposterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForumCategoryById = `-- name: GetForumCategoryById :one
SELECT idforumcategory, forumcategory_idforumcategory, language_id, title, description FROM forumcategory
WHERE idforumcategory = ?
  AND (
      language_id = 0
      OR language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
`

type GetForumCategoryByIdParams struct {
	Idforumcategory int32
	ViewerID        int32
}

func (q *Queries) GetForumCategoryById(ctx context.Context, arg GetForumCategoryByIdParams) (*Forumcategory, error) {
	row := q.db.QueryRowContext(ctx, getForumCategoryById, arg.Idforumcategory, arg.ViewerID, arg.ViewerID)
	var i Forumcategory
	err := row.Scan(
		&i.Idforumcategory,
		&i.ForumcategoryIdforumcategory,
		&i.LanguageID,
		&i.Title,
		&i.Description,
	)
	return &i, err
}

const getForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostText = `-- name: GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostText :many
WITH role_ids AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked, lu.username AS lastposterusername, lu.idusers AS lastposterid, fcu.username as firstpostusername, fcu.idusers as firstpostuserid, fc.written as firstpostwritten, fc.text as firstposttext
FROM forumthread th
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN users lu ON lu.idusers = th.lastposter
LEFT JOIN comments fc ON th.firstpost=fc.idcomments
LEFT JOIN users fcu ON fcu.idusers = fc.users_idusers
WHERE th.forumtopic_idforumtopic=?
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE ((t.handler = 'private' AND g.section = 'privateforum') OR (t.handler <> 'private' AND g.section = 'forum'))
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='view'
      AND g.active=1
      AND ((t.handler = 'private' AND g.item_id = t.idforumtopic) OR (t.handler <> 'private' AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)))
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY th.lastaddition DESC
`

type GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextParams struct {
	ViewerID      int32
	TopicID       int32
	ViewerMatchID sql.NullInt32
}

type GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextRow struct {
	Idforumthread          int32
	Firstpost              int32
	Lastposter             int32
	ForumtopicIdforumtopic int32
	Comments               sql.NullInt32
	Lastaddition           sql.NullTime
	Locked                 sql.NullBool
	Lastposterusername     sql.NullString
	Lastposterid           sql.NullInt32
	Firstpostusername      sql.NullString
	Firstpostuserid        sql.NullInt32
	Firstpostwritten       sql.NullTime
	Firstposttext          sql.NullString
}

func (q *Queries) GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostText(ctx context.Context, arg GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextParams) ([]*GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextRow, error) {
	rows, err := q.db.QueryContext(ctx, getForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostText, arg.ViewerID, arg.TopicID, arg.ViewerMatchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextRow
	for rows.Next() {
		var i GetForumThreadsByForumTopicIdForUserWithFirstAndLastPosterAndFirstPostTextRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Firstpost,
			&i.Lastposter,
			&i.ForumtopicIdforumtopic,
			&i.Comments,
			&i.Lastaddition,
			&i.Locked,
			&i.Lastposterusername,
			&i.Lastposterid,
			&i.Firstpostusername,
			&i.Firstpostuserid,
			&i.Firstpostwritten,
			&i.Firstposttext,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForumTopicById = `-- name: GetForumTopicById :one
SELECT idforumtopic, lastposter, forumcategory_idforumcategory, language_id, title, description, threads, comments, lastaddition, handler
FROM forumtopic
WHERE idforumtopic = ?
`

func (q *Queries) GetForumTopicById(ctx context.Context, idforumtopic int32) (*Forumtopic, error) {
	row := q.db.QueryRowContext(ctx, getForumTopicById, idforumtopic)
	var i Forumtopic
	err := row.Scan(
		&i.Idforumtopic,
		&i.Lastposter,
		&i.ForumcategoryIdforumcategory,
		&i.LanguageID,
		&i.Title,
		&i.Description,
		&i.Threads,
		&i.Comments,
		&i.Lastaddition,
		&i.Handler,
	)
	return &i, err
}

const getForumTopicByIdForUser = `-- name: GetForumTopicByIdForUser :one
WITH role_ids AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.language_id, t.title, t.description, t.threads, t.comments, t.lastaddition, t.handler, lu.username AS LastPosterUsername
FROM forumtopic t
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE t.idforumtopic = ?
  AND (
      t.language_id = 0
      OR t.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = t.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE ((t.handler = 'private' AND g.section = 'privateforum') OR (t.handler <> 'private' AND g.section = 'forum'))
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='view'
      AND g.active=1
      AND ((t.handler = 'private' AND g.item_id = t.idforumtopic) OR (t.handler <> 'private' AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)))
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY t.lastaddition DESC
`

type GetForumTopicByIdForUserParams struct {
	ViewerID      int32
	Idforumtopic  int32
	ViewerMatchID sql.NullInt32
}

type GetForumTopicByIdForUserRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	LanguageID                   sql.NullInt32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Handler                      string
	Lastposterusername           sql.NullString
}

func (q *Queries) GetForumTopicByIdForUser(ctx context.Context, arg GetForumTopicByIdForUserParams) (*GetForumTopicByIdForUserRow, error) {
	row := q.db.QueryRowContext(ctx, getForumTopicByIdForUser,
		arg.ViewerID,
		arg.Idforumtopic,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerMatchID,
	)
	var i GetForumTopicByIdForUserRow
	err := row.Scan(
		&i.Idforumtopic,
		&i.Lastposter,
		&i.ForumcategoryIdforumcategory,
		&i.LanguageID,
		&i.Title,
		&i.Description,
		&i.Threads,
		&i.Comments,
		&i.Lastaddition,
		&i.Handler,
		&i.Lastposterusername,
	)
	return &i, err
}

const getForumTopicsByCategoryId = `-- name: GetForumTopicsByCategoryId :many
SELECT idforumtopic, lastposter, forumcategory_idforumcategory, language_id, title, description, threads, comments, lastaddition, handler FROM forumtopic
WHERE forumcategory_idforumcategory = ?
  AND (
      language_id = 0
      OR language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
ORDER BY lastaddition DESC
`

type GetForumTopicsByCategoryIdParams struct {
	CategoryID int32
	ViewerID   int32
}

func (q *Queries) GetForumTopicsByCategoryId(ctx context.Context, arg GetForumTopicsByCategoryIdParams) ([]*Forumtopic, error) {
	rows, err := q.db.QueryContext(ctx, getForumTopicsByCategoryId, arg.CategoryID, arg.ViewerID, arg.ViewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumtopic
	for rows.Next() {
		var i Forumtopic
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageID,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Handler,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForumTopicsForUser = `-- name: GetForumTopicsForUser :many
WITH role_ids AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.language_id, t.title, t.description, t.threads, t.comments, t.lastaddition, t.handler, lu.username AS LastPosterUsername
FROM forumtopic t
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE t.handler <> 'private'
  AND (
    t.language_id = 0
    OR t.language_id IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_id = t.language_id
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='forum'
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='see'
      AND g.active=1
      AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY t.lastaddition DESC
`

type GetForumTopicsForUserParams struct {
	ViewerID      int32
	ViewerMatchID sql.NullInt32
}

type GetForumTopicsForUserRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	LanguageID                   sql.NullInt32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Handler                      string
	Lastposterusername           sql.NullString
}

func (q *Queries) GetForumTopicsForUser(ctx context.Context, arg GetForumTopicsForUserParams) ([]*GetForumTopicsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getForumTopicsForUser,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerMatchID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetForumTopicsForUserRow
	for rows.Next() {
		var i GetForumTopicsForUserRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageID,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Handler,
			&i.Lastposterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrivateTopicThreadsAndLabels = `-- name: GetPrivateTopicThreadsAndLabels :many
SELECT th.idforumthread, c.users_idusers AS author_id, cpl.label, cpl.invert
FROM forumthread th
JOIN comments c ON th.firstpost = c.idcomments
LEFT JOIN content_private_labels cpl
    ON cpl.item = 'thread'
    AND cpl.item_id = th.idforumthread
    AND cpl.user_id = ?
WHERE th.forumtopic_idforumtopic = ?
`

type GetPrivateTopicThreadsAndLabelsParams struct {
	UserID  int32
	TopicID int32
}

type GetPrivateTopicThreadsAndLabelsRow struct {
	Idforumthread int32
	AuthorID      int32
	Label         sql.NullString
	Invert        sql.NullBool
}

func (q *Queries) GetPrivateTopicThreadsAndLabels(ctx context.Context, arg GetPrivateTopicThreadsAndLabelsParams) ([]*GetPrivateTopicThreadsAndLabelsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrivateTopicThreadsAndLabels, arg.UserID, arg.TopicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPrivateTopicThreadsAndLabelsRow
	for rows.Next() {
		var i GetPrivateTopicThreadsAndLabelsRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.AuthorID,
			&i.Label,
			&i.Invert,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listForumcategoryPath = `-- name: ListForumcategoryPath :many
WITH RECURSIVE category_path AS (
    SELECT f.idforumcategory, f.forumcategory_idforumcategory AS parent_id, f.title, 0 AS depth
    FROM forumcategory f
    WHERE f.idforumcategory = ?
    UNION ALL
    SELECT c.idforumcategory, c.forumcategory_idforumcategory, c.title, p.depth + 1
    FROM forumcategory c
    JOIN category_path p ON p.parent_id = c.idforumcategory
)
SELECT category_path.idforumcategory, category_path.title
FROM category_path
ORDER BY category_path.depth DESC
`

type ListForumcategoryPathRow struct {
	Idforumcategory int32
	Title           sql.NullString
}

func (q *Queries) ListForumcategoryPath(ctx context.Context, categoryID int32) ([]*ListForumcategoryPathRow, error) {
	rows, err := q.db.QueryContext(ctx, listForumcategoryPath, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListForumcategoryPathRow
	for rows.Next() {
		var i ListForumcategoryPathRow
		if err := rows.Scan(&i.Idforumcategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPrivateTopicParticipantsByTopicIDForUser = `-- name: ListPrivateTopicParticipantsByTopicIDForUser :many
SELECT u.idusers, u.username
FROM grants g
JOIN users u ON u.idusers = g.user_id
WHERE g.section = 'privateforum'
  AND g.item = 'topic'
  AND g.action = 'view'
  AND g.active = 1
  AND g.user_id IS NOT NULL
  AND g.item_id = ?
  AND EXISTS (
      SELECT 1 FROM grants pg
      WHERE pg.section='privateforum'
        AND pg.item='topic'
        AND pg.action='view'
        AND pg.active=1
        AND pg.item_id = g.item_id
        AND pg.user_id = ?
  )
`

type ListPrivateTopicParticipantsByTopicIDForUserParams struct {
	TopicID  sql.NullInt32
	ViewerID sql.NullInt32
}

type ListPrivateTopicParticipantsByTopicIDForUserRow struct {
	Idusers  int32
	Username sql.NullString
}

func (q *Queries) ListPrivateTopicParticipantsByTopicIDForUser(ctx context.Context, arg ListPrivateTopicParticipantsByTopicIDForUserParams) ([]*ListPrivateTopicParticipantsByTopicIDForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listPrivateTopicParticipantsByTopicIDForUser, arg.TopicID, arg.ViewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListPrivateTopicParticipantsByTopicIDForUserRow
	for rows.Next() {
		var i ListPrivateTopicParticipantsByTopicIDForUserRow
		if err := rows.Scan(&i.Idusers, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPrivateTopicsByUserID = `-- name: ListPrivateTopicsByUserID :many
SELECT t.idforumtopic,
       t.lastposter,
       t.forumcategory_idforumcategory,
       t.language_id,
       t.title,
       t.description,
       t.threads,
       t.comments,
       t.lastaddition,
       t.handler,
       lu.username AS LastPosterUsername
FROM forumtopic t
LEFT JOIN users lu ON lu.idusers = t.lastposter
JOIN grants g ON g.item_id = t.idforumtopic
WHERE t.handler = 'private'
  AND g.section = 'privateforum'
  AND g.item = 'topic'
  AND g.action = 'see'
  AND g.active = 1
  AND g.user_id = ?
ORDER BY t.lastaddition DESC
`

type ListPrivateTopicsByUserIDRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	LanguageID                   sql.NullInt32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Handler                      string
	Lastposterusername           sql.NullString
}

func (q *Queries) ListPrivateTopicsByUserID(ctx context.Context, userID sql.NullInt32) ([]*ListPrivateTopicsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listPrivateTopicsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListPrivateTopicsByUserIDRow
	for rows.Next() {
		var i ListPrivateTopicsByUserIDRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.LanguageID,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Handler,
			&i.Lastposterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemGetForumTopicByTitle = `-- name: SystemGetForumTopicByTitle :one
SELECT idforumtopic, lastposter, forumcategory_idforumcategory, language_id, title, description, threads, comments, lastaddition, handler
FROM forumtopic
WHERE title=?
`

func (q *Queries) SystemGetForumTopicByTitle(ctx context.Context, title sql.NullString) (*Forumtopic, error) {
	row := q.db.QueryRowContext(ctx, systemGetForumTopicByTitle, title)
	var i Forumtopic
	err := row.Scan(
		&i.Idforumtopic,
		&i.Lastposter,
		&i.ForumcategoryIdforumcategory,
		&i.LanguageID,
		&i.Title,
		&i.Description,
		&i.Threads,
		&i.Comments,
		&i.Lastaddition,
		&i.Handler,
	)
	return &i, err
}

const systemRebuildForumTopicMetaByID = `-- name: SystemRebuildForumTopicMetaByID :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
), lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
WHERE idforumtopic = ?
`

func (q *Queries) SystemRebuildForumTopicMetaByID(ctx context.Context, idforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, systemRebuildForumTopicMetaByID, idforumtopic)
	return err
}

const systemSetForumTopicHandlerByID = `-- name: SystemSetForumTopicHandlerByID :exec
UPDATE forumtopic SET handler = ? WHERE idforumtopic = ?
`

type SystemSetForumTopicHandlerByIDParams struct {
	Handler string
	ID      int32
}

func (q *Queries) SystemSetForumTopicHandlerByID(ctx context.Context, arg SystemSetForumTopicHandlerByIDParams) error {
	_, err := q.db.ExecContext(ctx, systemSetForumTopicHandlerByID, arg.Handler, arg.ID)
	return err
}
