// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-languages.sql

package db

import (
	"context"
	"database/sql"
)

const adminDeleteLanguage = `-- name: AdminDeleteLanguage :exec
DELETE FROM language
WHERE idlanguage = ?
`

// admin task
// This query deletes a record from the "language" table based on the provided "cid".
// Parameters:
//
//	? - Language ID to be deleted (int)
func (q *Queries) AdminDeleteLanguage(ctx context.Context, idlanguage int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteLanguage, idlanguage)
	return err
}

const adminInsertLanguage = `-- name: AdminInsertLanguage :execresult
INSERT INTO language (nameof)
VALUES (?)
`

// admin task
func (q *Queries) AdminInsertLanguage(ctx context.Context, nameof sql.NullString) (sql.Result, error) {
	return q.db.ExecContext(ctx, adminInsertLanguage, nameof)
}

const adminListLanguages = `-- name: AdminListLanguages :many
SELECT idlanguage, nameof FROM language
ORDER BY nameof
`

// admin task
func (q *Queries) AdminListLanguages(ctx context.Context) ([]*Language, error) {
	rows, err := q.db.QueryContext(ctx, adminListLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(&i.Idlanguage, &i.Nameof); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminRenameLanguage = `-- name: AdminRenameLanguage :exec
UPDATE language
SET nameof = ?
WHERE idlanguage = ?
`

type AdminRenameLanguageParams struct {
	Nameof     sql.NullString
	Idlanguage int32
}

// admin task
// This query updates the "nameof" field in the "language" table based on the provided "cid".
// Parameters:
//
//	? - New name for the language (string)
//	? - Language ID to be updated (int)
func (q *Queries) AdminRenameLanguage(ctx context.Context, arg AdminRenameLanguageParams) error {
	_, err := q.db.ExecContext(ctx, adminRenameLanguage, arg.Nameof, arg.Idlanguage)
	return err
}

const countLanguages = `-- name: CountLanguages :one
SELECT COUNT(*) FROM language
`

func (q *Queries) CountLanguages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLanguages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLanguageIDByName = `-- name: GetLanguageIDByName :one
SELECT idlanguage FROM language WHERE nameof = ?
`

func (q *Queries) GetLanguageIDByName(ctx context.Context, nameof sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, getLanguageIDByName, nameof)
	var idlanguage int32
	err := row.Scan(&idlanguage)
	return idlanguage, err
}

const listLanguagesForUser = `-- name: ListLanguagesForUser :many
SELECT idlanguage, nameof
FROM language
WHERE NOT EXISTS (
    SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
) OR EXISTS (
    SELECT 1 FROM user_language ul
    WHERE ul.users_idusers = ?
      AND ul.language_idlanguage = idlanguage
)
ORDER BY nameof
`

type ListLanguagesForUserParams struct {
	ViewerID int32
}

// user listing
func (q *Queries) ListLanguagesForUser(ctx context.Context, arg ListLanguagesForUserParams) ([]*Language, error) {
	rows, err := q.db.QueryContext(ctx, listLanguagesForUser, arg.ViewerID, arg.ViewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(&i.Idlanguage, &i.Nameof); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
