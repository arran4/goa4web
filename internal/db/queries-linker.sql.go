// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-linker.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const adminCountLinksByCategory = `-- name: AdminCountLinksByCategory :one
SELECT COUNT(*) FROM linker WHERE linker_category_id = ?
`

func (q *Queries) AdminCountLinksByCategory(ctx context.Context, linkerCategoryID sql.NullInt32) (int64, error) {
	row := q.db.QueryRowContext(ctx, adminCountLinksByCategory, linkerCategoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminCreateLinkerCategory = `-- name: AdminCreateLinkerCategory :exec
INSERT INTO linker_category (title, position) VALUES (?, ?)
`

type AdminCreateLinkerCategoryParams struct {
	Title    sql.NullString
	Position int32
}

func (q *Queries) AdminCreateLinkerCategory(ctx context.Context, arg AdminCreateLinkerCategoryParams) error {
	_, err := q.db.ExecContext(ctx, adminCreateLinkerCategory, arg.Title, arg.Position)
	return err
}

const adminCreateLinkerItem = `-- name: AdminCreateLinkerItem :exec
INSERT INTO linker (users_idusers, linker_category_id, title, url, description, listed)
VALUES (?, ?, ?, ?, ?, NOW())
`

type AdminCreateLinkerItemParams struct {
	UsersIdusers     int32
	LinkerCategoryID sql.NullInt32
	Title            sql.NullString
	Url              sql.NullString
	Description      sql.NullString
}

func (q *Queries) AdminCreateLinkerItem(ctx context.Context, arg AdminCreateLinkerItemParams) error {
	_, err := q.db.ExecContext(ctx, adminCreateLinkerItem,
		arg.UsersIdusers,
		arg.LinkerCategoryID,
		arg.Title,
		arg.Url,
		arg.Description,
	)
	return err
}

const adminDeleteLinkerCategory = `-- name: AdminDeleteLinkerCategory :exec
DELETE FROM linker_category
WHERE idlinkerCategory = ?
`

// AdminDeleteLinkerCategory removes a linker category.
func (q *Queries) AdminDeleteLinkerCategory(ctx context.Context, idlinkercategory int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteLinkerCategory, idlinkercategory)
	return err
}

const adminDeleteLinkerQueuedItem = `-- name: AdminDeleteLinkerQueuedItem :exec
DELETE FROM linker_queue
WHERE idlinkerQueue = ?
`

func (q *Queries) AdminDeleteLinkerQueuedItem(ctx context.Context, idlinkerqueue int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteLinkerQueuedItem, idlinkerqueue)
	return err
}

const adminInsertQueuedLinkFromQueue = `-- name: AdminInsertQueuedLinkFromQueue :execlastid
INSERT INTO linker (users_idusers, linker_category_id, language_idlanguage, title, ` + "`" + `url` + "`" + `, description)
SELECT l.users_idusers, l.linker_category_id, l.language_idlanguage, l.title, l.url, l.description
FROM linker_queue l
WHERE l.idlinkerQueue = ?
`

func (q *Queries) AdminInsertQueuedLinkFromQueue(ctx context.Context, idlinkerqueue int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, adminInsertQueuedLinkFromQueue, idlinkerqueue)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const adminRenameLinkerCategory = `-- name: AdminRenameLinkerCategory :exec
UPDATE linker_category SET title = ?, position = ?
WHERE idlinkerCategory = ?
`

type AdminRenameLinkerCategoryParams struct {
	Title            sql.NullString
	Position         int32
	Idlinkercategory int32
}

func (q *Queries) AdminRenameLinkerCategory(ctx context.Context, arg AdminRenameLinkerCategoryParams) error {
	_, err := q.db.ExecContext(ctx, adminRenameLinkerCategory, arg.Title, arg.Position, arg.Idlinkercategory)
	return err
}

const adminUpdateLinkerCategorySortOrder = `-- name: AdminUpdateLinkerCategorySortOrder :exec
UPDATE linker_category SET sortorder = ?
WHERE idlinkerCategory = ?
`

type AdminUpdateLinkerCategorySortOrderParams struct {
	Sortorder        int32
	Idlinkercategory int32
}

func (q *Queries) AdminUpdateLinkerCategorySortOrder(ctx context.Context, arg AdminUpdateLinkerCategorySortOrderParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateLinkerCategorySortOrder, arg.Sortorder, arg.Idlinkercategory)
	return err
}

const adminUpdateLinkerItem = `-- name: AdminUpdateLinkerItem :exec
UPDATE linker SET title = ?, url = ?, description = ?, linker_category_id = ?, language_idlanguage = ?
WHERE idlinker = ?
`

type AdminUpdateLinkerItemParams struct {
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	LinkerCategoryID   sql.NullInt32
	LanguageIdlanguage sql.NullInt32
	Idlinker           int32
}

func (q *Queries) AdminUpdateLinkerItem(ctx context.Context, arg AdminUpdateLinkerItemParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateLinkerItem,
		arg.Title,
		arg.Url,
		arg.Description,
		arg.LinkerCategoryID,
		arg.LanguageIdlanguage,
		arg.Idlinker,
	)
	return err
}

const adminUpdateLinkerQueuedItem = `-- name: AdminUpdateLinkerQueuedItem :exec
UPDATE linker_queue SET linker_category_id = ?, title = ?, url = ?, description = ?
WHERE idlinkerQueue = ?
`

type AdminUpdateLinkerQueuedItemParams struct {
	LinkerCategoryID sql.NullInt32
	Title            sql.NullString
	Url              sql.NullString
	Description      sql.NullString
	Idlinkerqueue    int32
}

func (q *Queries) AdminUpdateLinkerQueuedItem(ctx context.Context, arg AdminUpdateLinkerQueuedItemParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateLinkerQueuedItem,
		arg.LinkerCategoryID,
		arg.Title,
		arg.Url,
		arg.Description,
		arg.Idlinkerqueue,
	)
	return err
}

const createLinkerQueuedItemForWriter = `-- name: CreateLinkerQueuedItemForWriter :exec
INSERT INTO linker_queue (users_idusers, linker_category_id, title, url, description)
SELECT ?, ?, ?, ?, ?
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='linker'
      AND (g.item='link' OR g.item IS NULL)
      AND g.action='post'
      AND g.active=1
      AND (g.item_id = ? OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
)
`

type CreateLinkerQueuedItemForWriterParams struct {
	WriterID         int32
	LinkerCategoryID sql.NullInt32
	Title            sql.NullString
	Url              sql.NullString
	Description      sql.NullString
	GrantCategoryID  sql.NullInt32
	GranteeID        sql.NullInt32
}

func (q *Queries) CreateLinkerQueuedItemForWriter(ctx context.Context, arg CreateLinkerQueuedItemForWriterParams) error {
	_, err := q.db.ExecContext(ctx, createLinkerQueuedItemForWriter,
		arg.WriterID,
		arg.LinkerCategoryID,
		arg.Title,
		arg.Url,
		arg.Description,
		arg.GrantCategoryID,
		arg.GranteeID,
		arg.WriterID,
	)
	return err
}

const getAllLinkerCategories = `-- name: GetAllLinkerCategories :many
SELECT
    lc.idlinkerCategory,
    lc.position,
    lc.title,
    lc.sortorder
FROM linker_category lc
ORDER BY lc.position
`

func (q *Queries) GetAllLinkerCategories(ctx context.Context) ([]*LinkerCategory, error) {
	rows, err := q.db.QueryContext(ctx, getAllLinkerCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*LinkerCategory
	for rows.Next() {
		var i LinkerCategory
		if err := rows.Scan(
			&i.Idlinkercategory,
			&i.Position,
			&i.Title,
			&i.Sortorder,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLinkerCategoriesForUser = `-- name: GetAllLinkerCategoriesForUser :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur
    WHERE ur.users_idusers = ?
),
grants_for_viewer AS (
    SELECT g.section, g.item, g.action, g.item_id
    FROM grants g
    WHERE g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
SELECT
    lc.idlinkerCategory,
    lc.position,
    lc.title,
    lc.sortorder
FROM linker_category lc
WHERE EXISTS (
    SELECT 1
    FROM grants_for_viewer g
    WHERE g.section = 'linker'
      AND (g.item = 'category' OR g.item IS NULL)
      AND g.action = 'see'
      AND (g.item_id = lc.idlinkerCategory OR g.item_id IS NULL)
)
  AND EXISTS (
    SELECT 1 FROM linker l
    WHERE l.linker_category_id = lc.idlinkerCategory
      AND l.listed IS NOT NULL
      AND l.deleted_at IS NULL
  )
ORDER BY lc.position
`

type GetAllLinkerCategoriesForUserParams struct {
	ViewerID     int32
	ViewerUserID sql.NullInt32
}

func (q *Queries) GetAllLinkerCategoriesForUser(ctx context.Context, arg GetAllLinkerCategoriesForUserParams) ([]*LinkerCategory, error) {
	rows, err := q.db.QueryContext(ctx, getAllLinkerCategoriesForUser, arg.ViewerID, arg.ViewerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*LinkerCategory
	for rows.Next() {
		var i LinkerCategory
		if err := rows.Scan(
			&i.Idlinkercategory,
			&i.Position,
			&i.Title,
			&i.Sortorder,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescending = `-- name: GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescending :many
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.forumthread_id, l.title, l.url, l.description, l.listed, th.Comments, lc.title as Category_Title, u.Username as PosterUsername
FROM linker l
LEFT JOIN users u ON l.users_idusers = u.idusers
LEFT JOIN linker_category lc ON l.linker_category_id = lc.idlinkerCategory
LEFT JOIN forumthread th ON l.forumthread_id = th.idforumthread
WHERE (lc.idlinkerCategory = ? OR ? = 0)
  AND l.listed IS NOT NULL
  AND l.deleted_at IS NULL
ORDER BY l.listed DESC
`

type GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingParams struct {
	Idlinkercategory int32
}

type GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingRow struct {
	Idlinker           int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	ForumthreadID      int32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Listed             sql.NullTime
	Comments           sql.NullInt32
	CategoryTitle      sql.NullString
	Posterusername     sql.NullString
}

func (q *Queries) GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescending(ctx context.Context, arg GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingParams) ([]*GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescending, arg.Idlinkercategory, arg.Idlinkercategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingRow
	for rows.Next() {
		var i GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.ForumthreadID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Comments,
			&i.CategoryTitle,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUser = `-- name: GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUser :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur
    WHERE ur.users_idusers = ?
),
grants_for_viewer AS (
    SELECT g.section, g.item, g.action, g.item_id
    FROM grants g
    WHERE g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.forumthread_id, l.title, l.url, l.description, l.listed, th.Comments, lc.title as Category_Title, u.Username as PosterUsername
FROM linker l
LEFT JOIN users u ON l.users_idusers = u.idusers
LEFT JOIN linker_category lc ON l.linker_category_id = lc.idlinkerCategory
LEFT JOIN forumthread th ON l.forumthread_id = th.idforumthread
WHERE (lc.idlinkerCategory = ? OR ? = 0)
  AND l.listed IS NOT NULL
  AND l.deleted_at IS NULL
  AND EXISTS (
    SELECT 1
    FROM grants_for_viewer g
    WHERE g.section = 'linker'
      AND (g.item = 'link' OR g.item IS NULL)
      AND g.action = 'see'
      AND (g.item_id = l.idlinker OR g.item_id IS NULL)
  )
ORDER BY l.listed DESC
`

type GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserParams struct {
	ViewerID         int32
	ViewerUserID     sql.NullInt32
	Idlinkercategory int32
}

type GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserRow struct {
	Idlinker           int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	ForumthreadID      int32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Listed             sql.NullTime
	Comments           sql.NullInt32
	CategoryTitle      sql.NullString
	Posterusername     sql.NullString
}

func (q *Queries) GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUser(ctx context.Context, arg GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserParams) ([]*GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUser,
		arg.ViewerID,
		arg.ViewerUserID,
		arg.Idlinkercategory,
		arg.Idlinkercategory,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserRow
	for rows.Next() {
		var i GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.ForumthreadID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Comments,
			&i.CategoryTitle,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginated = `-- name: GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginated :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur
    WHERE ur.users_idusers = ?
),
grants_for_viewer AS (
    SELECT g.section, g.item, g.action, g.item_id
    FROM grants g
    WHERE g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.forumthread_id, l.title, l.url, l.description, l.listed, th.Comments, lc.title as Category_Title, u.Username as PosterUsername
FROM linker l
LEFT JOIN users u ON l.users_idusers = u.idusers
LEFT JOIN linker_category lc ON l.linker_category_id = lc.idlinkerCategory
LEFT JOIN forumthread th ON l.forumthread_id = th.idforumthread
WHERE (lc.idlinkerCategory = ? OR ? = 0)
  AND EXISTS (
    SELECT 1
    FROM grants_for_viewer g
    WHERE g.section = 'linker'
      AND (g.item = 'link' OR g.item IS NULL)
      AND g.action = 'see'
      AND (g.item_id = l.idlinker OR g.item_id IS NULL)
  )
ORDER BY l.listed DESC
LIMIT ? OFFSET ?
`

type GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedParams struct {
	ViewerID         int32
	ViewerUserID     sql.NullInt32
	Idlinkercategory int32
	Limit            int32
	Offset           int32
}

type GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRow struct {
	Idlinker           int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	ForumthreadID      int32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Listed             sql.NullTime
	Comments           sql.NullInt32
	CategoryTitle      sql.NullString
	Posterusername     sql.NullString
}

func (q *Queries) GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginated(ctx context.Context, arg GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedParams) ([]*GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginated,
		arg.ViewerID,
		arg.ViewerUserID,
		arg.Idlinkercategory,
		arg.Idlinkercategory,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRow
	for rows.Next() {
		var i GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.ForumthreadID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Comments,
			&i.CategoryTitle,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRow = `-- name: GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRow :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur
    WHERE ur.users_idusers = ?
),
grants_for_viewer AS (
    SELECT g.section, g.item, g.action, g.item_id
    FROM grants g
    WHERE g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.forumthread_id, l.title, l.url, l.description, l.listed, th.Comments, lc.title as Category_Title, u.Username as PosterUsername
FROM linker l
LEFT JOIN users u ON l.users_idusers = u.idusers
LEFT JOIN linker_category lc ON l.linker_category_id = lc.idlinkerCategory
LEFT JOIN forumthread th ON l.forumthread_id = th.idforumthread
WHERE (lc.idlinkerCategory = ? OR ? = 0)
  AND l.listed IS NOT NULL
  AND l.deleted_at IS NULL
  AND EXISTS (
    SELECT 1
    FROM grants_for_viewer g
    WHERE g.section = 'linker'
      AND (g.item = 'link' OR g.item IS NULL)
      AND g.action = 'see'
      AND (g.item_id = l.idlinker OR g.item_id IS NULL)
  )
ORDER BY l.listed DESC
LIMIT ? OFFSET ?
`

type GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRowParams struct {
	ViewerID         int32
	ViewerUserID     sql.NullInt32
	Idlinkercategory int32
	Limit            int32
	Offset           int32
}

type GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRowRow struct {
	Idlinker           int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	ForumthreadID      int32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Listed             sql.NullTime
	Comments           sql.NullInt32
	CategoryTitle      sql.NullString
	Posterusername     sql.NullString
}

func (q *Queries) GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRow(ctx context.Context, arg GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRowParams) ([]*GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRowRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRow,
		arg.ViewerID,
		arg.ViewerUserID,
		arg.Idlinkercategory,
		arg.Idlinkercategory,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRowRow
	for rows.Next() {
		var i GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingForUserPaginatedRowRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.ForumthreadID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Comments,
			&i.CategoryTitle,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingPaginated = `-- name: GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingPaginated :many
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.forumthread_id, l.title, l.url, l.description, l.listed, th.Comments, lc.title as Category_Title, u.Username as PosterUsername
FROM linker l
LEFT JOIN users u ON l.users_idusers = u.idusers
LEFT JOIN linker_category lc ON l.linker_category_id = lc.idlinkerCategory
LEFT JOIN forumthread th ON l.forumthread_id = th.idforumthread
WHERE (lc.idlinkerCategory = ? OR ? = 0)
ORDER BY l.listed DESC
LIMIT ? OFFSET ?
`

type GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingPaginatedParams struct {
	Idlinkercategory int32
	Limit            int32
	Offset           int32
}

type GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingPaginatedRow struct {
	Idlinker           int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	ForumthreadID      int32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Listed             sql.NullTime
	Comments           sql.NullInt32
	CategoryTitle      sql.NullString
	Posterusername     sql.NullString
}

func (q *Queries) GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingPaginated(ctx context.Context, arg GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingPaginatedParams) ([]*GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingPaginated,
		arg.Idlinkercategory,
		arg.Idlinkercategory,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingPaginatedRow
	for rows.Next() {
		var i GetAllLinkerItemsByCategoryIdWitherPosterUsernameAndCategoryTitleDescendingPaginatedRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.ForumthreadID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Comments,
			&i.CategoryTitle,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLinkerQueuedItemsWithUserAndLinkerCategoryDetails = `-- name: GetAllLinkerQueuedItemsWithUserAndLinkerCategoryDetails :many
SELECT l.idlinkerqueue, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.title, l.url, l.description, u.username, c.title as category_title, c.idlinkerCategory
FROM linker_queue l
JOIN users u ON l.users_idusers = u.idusers
JOIN linker_category c ON l.linker_category_id = c.idlinkerCategory
`

type GetAllLinkerQueuedItemsWithUserAndLinkerCategoryDetailsRow struct {
	Idlinkerqueue      int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Username           sql.NullString
	CategoryTitle      sql.NullString
	Idlinkercategory   int32
}

func (q *Queries) GetAllLinkerQueuedItemsWithUserAndLinkerCategoryDetails(ctx context.Context) ([]*GetAllLinkerQueuedItemsWithUserAndLinkerCategoryDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllLinkerQueuedItemsWithUserAndLinkerCategoryDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllLinkerQueuedItemsWithUserAndLinkerCategoryDetailsRow
	for rows.Next() {
		var i GetAllLinkerQueuedItemsWithUserAndLinkerCategoryDetailsRow
		if err := rows.Scan(
			&i.Idlinkerqueue,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Username,
			&i.CategoryTitle,
			&i.Idlinkercategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLinkersForIndex = `-- name: GetAllLinkersForIndex :many
SELECT idlinker, title, description FROM linker WHERE deleted_at IS NULL AND listed IS NOT NULL
`

type GetAllLinkersForIndexRow struct {
	Idlinker    int32
	Title       sql.NullString
	Description sql.NullString
}

func (q *Queries) GetAllLinkersForIndex(ctx context.Context) ([]*GetAllLinkersForIndexRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllLinkersForIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllLinkersForIndexRow
	for rows.Next() {
		var i GetAllLinkersForIndexRow
		if err := rows.Scan(&i.Idlinker, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkerCategoriesWithCount = `-- name: GetLinkerCategoriesWithCount :many
SELECT c.idlinkerCategory, c.title, c.sortorder, COUNT(l.idlinker) AS linkcount
FROM linker_category c
LEFT JOIN linker l ON l.linker_category_id = c.idlinkerCategory AND l.listed IS NOT NULL AND l.deleted_at IS NULL
GROUP BY c.idlinkerCategory
ORDER BY c.sortorder
`

type GetLinkerCategoriesWithCountRow struct {
	Idlinkercategory int32
	Title            sql.NullString
	Sortorder        int32
	Linkcount        int64
}

func (q *Queries) GetLinkerCategoriesWithCount(ctx context.Context) ([]*GetLinkerCategoriesWithCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getLinkerCategoriesWithCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetLinkerCategoriesWithCountRow
	for rows.Next() {
		var i GetLinkerCategoriesWithCountRow
		if err := rows.Scan(
			&i.Idlinkercategory,
			&i.Title,
			&i.Sortorder,
			&i.Linkcount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkerCategoryById = `-- name: GetLinkerCategoryById :one
SELECT idlinkercategory, position, title, sortorder FROM linker_category WHERE idlinkerCategory = ?
`

func (q *Queries) GetLinkerCategoryById(ctx context.Context, idlinkercategory int32) (*LinkerCategory, error) {
	row := q.db.QueryRowContext(ctx, getLinkerCategoryById, idlinkercategory)
	var i LinkerCategory
	err := row.Scan(
		&i.Idlinkercategory,
		&i.Position,
		&i.Title,
		&i.Sortorder,
	)
	return &i, err
}

const getLinkerCategoryLinkCounts = `-- name: GetLinkerCategoryLinkCounts :many
SELECT c.idlinkerCategory, c.title, c.position, COUNT(l.idlinker) as LinkCount
FROM linker_category c
LEFT JOIN linker l ON c.idlinkerCategory = l.linker_category_id AND l.listed IS NOT NULL AND l.deleted_at IS NULL
GROUP BY c.idlinkerCategory
ORDER BY c.position
`

type GetLinkerCategoryLinkCountsRow struct {
	Idlinkercategory int32
	Title            sql.NullString
	Position         int32
	Linkcount        int64
}

func (q *Queries) GetLinkerCategoryLinkCounts(ctx context.Context) ([]*GetLinkerCategoryLinkCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLinkerCategoryLinkCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetLinkerCategoryLinkCountsRow
	for rows.Next() {
		var i GetLinkerCategoryLinkCountsRow
		if err := rows.Scan(
			&i.Idlinkercategory,
			&i.Title,
			&i.Position,
			&i.Linkcount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkerItemByIdWithPosterUsernameAndCategoryTitleDescending = `-- name: GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescending :one
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.forumthread_id, l.title, l.url, l.description, l.listed, u.username, lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linker_category lc ON l.linker_category_id = lc.idlinkerCategory
WHERE l.idlinker = ?
`

type GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingRow struct {
	Idlinker           int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	ForumthreadID      int32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Listed             sql.NullTime
	Username           sql.NullString
	Title_2            sql.NullString
}

func (q *Queries) GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescending(ctx context.Context, idlinker int32) (*GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingRow, error) {
	row := q.db.QueryRowContext(ctx, getLinkerItemByIdWithPosterUsernameAndCategoryTitleDescending, idlinker)
	var i GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingRow
	err := row.Scan(
		&i.Idlinker,
		&i.LanguageIdlanguage,
		&i.UsersIdusers,
		&i.LinkerCategoryID,
		&i.ForumthreadID,
		&i.Title,
		&i.Url,
		&i.Description,
		&i.Listed,
		&i.Username,
		&i.Title_2,
	)
	return &i, err
}

const getLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingForUser = `-- name: GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingForUser :one
WITH role_ids AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur
    WHERE ur.users_idusers = ?
),
grants_for_viewer AS (
    SELECT g.section, g.item, g.action, g.item_id
    FROM grants g
    WHERE g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.forumthread_id, l.title, l.url, l.description, l.listed, u.username, lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linker_category lc ON l.linker_category_id = lc.idlinkerCategory
WHERE l.idlinker = ?
  AND l.listed IS NOT NULL
  AND l.deleted_at IS NULL
  AND EXISTS (
    SELECT 1
    FROM grants_for_viewer g
    WHERE g.section = 'linker'
      AND (g.item = 'link' OR g.item IS NULL)
      AND g.action IN ('view')
      AND (g.item_id = l.idlinker OR g.item_id IS NULL)
  )
LIMIT 1
`

type GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingForUserParams struct {
	ViewerID     int32
	ViewerUserID sql.NullInt32
	Idlinker     int32
}

type GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingForUserRow struct {
	Idlinker           int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	ForumthreadID      int32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Listed             sql.NullTime
	Username           sql.NullString
	Title_2            sql.NullString
}

func (q *Queries) GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingForUser(ctx context.Context, arg GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingForUserParams) (*GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingForUserRow, error) {
	row := q.db.QueryRowContext(ctx, getLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingForUser, arg.ViewerID, arg.ViewerUserID, arg.Idlinker)
	var i GetLinkerItemByIdWithPosterUsernameAndCategoryTitleDescendingForUserRow
	err := row.Scan(
		&i.Idlinker,
		&i.LanguageIdlanguage,
		&i.UsersIdusers,
		&i.LinkerCategoryID,
		&i.ForumthreadID,
		&i.Title,
		&i.Url,
		&i.Description,
		&i.Listed,
		&i.Username,
		&i.Title_2,
	)
	return &i, err
}

const getLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescending = `-- name: GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescending :many
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.forumthread_id, l.title, l.url, l.description, l.listed, u.username, lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linker_category lc ON l.linker_category_id = lc.idlinkerCategory
WHERE l.idlinker IN (/*SLICE:linkerids*/?)
`

type GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingRow struct {
	Idlinker           int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	ForumthreadID      int32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Listed             sql.NullTime
	Username           sql.NullString
	Title_2            sql.NullString
}

func (q *Queries) GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescending(ctx context.Context, linkerids []int32) ([]*GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingRow, error) {
	query := getLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescending
	var queryParams []interface{}
	if len(linkerids) > 0 {
		for _, v := range linkerids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:linkerids*/?", strings.Repeat(",?", len(linkerids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:linkerids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingRow
	for rows.Next() {
		var i GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.ForumthreadID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Username,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingForUser = `-- name: GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingForUser :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur
    WHERE ur.users_idusers = ?
),
grants_for_viewer AS (
    SELECT g.section, g.item, g.action, g.item_id
    FROM grants g
    WHERE g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.forumthread_id, l.title, l.url, l.description, l.listed, u.username, lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linker_category lc ON l.linker_category_id = lc.idlinkerCategory
WHERE l.idlinker IN (/*SLICE:linkerids*/?)
  AND l.listed IS NOT NULL
  AND l.deleted_at IS NULL
  AND EXISTS (
    SELECT 1
    FROM grants_for_viewer g
    WHERE g.section = 'linker'
      AND (g.item = 'link' OR g.item IS NULL)
      AND g.action = 'view'
      AND (g.item_id = l.idlinker OR g.item_id IS NULL)
  )
`

type GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingForUserParams struct {
	ViewerID     int32
	ViewerUserID sql.NullInt32
	Linkerids    []int32
}

type GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingForUserRow struct {
	Idlinker           int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	ForumthreadID      int32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Listed             sql.NullTime
	Username           sql.NullString
	Title_2            sql.NullString
}

func (q *Queries) GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingForUser(ctx context.Context, arg GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingForUserParams) ([]*GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingForUserRow, error) {
	query := getLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingForUser
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ViewerID)
	queryParams = append(queryParams, arg.ViewerUserID)
	if len(arg.Linkerids) > 0 {
		for _, v := range arg.Linkerids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:linkerids*/?", strings.Repeat(",?", len(arg.Linkerids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:linkerids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingForUserRow
	for rows.Next() {
		var i GetLinkerItemsByIdsWithPosterUsernameAndCategoryTitleDescendingForUserRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.ForumthreadID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Username,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkerItemsByUserDescending = `-- name: GetLinkerItemsByUserDescending :many
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.forumthread_id, l.title, l.url, l.description, l.listed, th.comments, lc.title as Category_Title, u.username as PosterUsername
FROM linker l
LEFT JOIN users u ON l.users_idusers = u.idusers
LEFT JOIN linker_category lc ON l.linker_category_id = lc.idlinkerCategory
LEFT JOIN forumthread th ON l.forumthread_id = th.idforumthread
WHERE l.users_idusers = ?
ORDER BY l.listed DESC
LIMIT ? OFFSET ?
`

type GetLinkerItemsByUserDescendingParams struct {
	UsersIdusers int32
	Limit        int32
	Offset       int32
}

type GetLinkerItemsByUserDescendingRow struct {
	Idlinker           int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	ForumthreadID      int32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Listed             sql.NullTime
	Comments           sql.NullInt32
	CategoryTitle      sql.NullString
	Posterusername     sql.NullString
}

func (q *Queries) GetLinkerItemsByUserDescending(ctx context.Context, arg GetLinkerItemsByUserDescendingParams) ([]*GetLinkerItemsByUserDescendingRow, error) {
	rows, err := q.db.QueryContext(ctx, getLinkerItemsByUserDescending, arg.UsersIdusers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetLinkerItemsByUserDescendingRow
	for rows.Next() {
		var i GetLinkerItemsByUserDescendingRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.ForumthreadID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Comments,
			&i.CategoryTitle,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinkerItemsByUserDescendingForUser = `-- name: GetLinkerItemsByUserDescendingForUser :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur
    WHERE ur.users_idusers = ?
),
grants_for_viewer AS (
    SELECT g.section, g.item, g.action, g.item_id
    FROM grants g
    WHERE g.active = 1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linker_category_id, l.forumthread_id, l.title, l.url, l.description, l.listed, th.comments, lc.title as Category_Title, u.username as PosterUsername
FROM linker l
LEFT JOIN users u ON l.users_idusers = u.idusers
LEFT JOIN linker_category lc ON l.linker_category_id = lc.idlinkerCategory
LEFT JOIN forumthread th ON l.forumthread_id = th.idforumthread
WHERE l.users_idusers = ?
  AND l.listed IS NOT NULL
  AND l.deleted_at IS NULL
  AND EXISTS (
    SELECT 1
    FROM grants_for_viewer g
    WHERE g.section = 'linker'
      AND (g.item = 'link' OR g.item IS NULL)
      AND g.action = 'see'
      AND (g.item_id = l.idlinker OR g.item_id IS NULL)
  )
ORDER BY l.listed DESC
LIMIT ? OFFSET ?
`

type GetLinkerItemsByUserDescendingForUserParams struct {
	ViewerID     int32
	ViewerUserID sql.NullInt32
	UserID       int32
	Limit        int32
	Offset       int32
}

type GetLinkerItemsByUserDescendingForUserRow struct {
	Idlinker           int32
	LanguageIdlanguage sql.NullInt32
	UsersIdusers       int32
	LinkerCategoryID   sql.NullInt32
	ForumthreadID      int32
	Title              sql.NullString
	Url                sql.NullString
	Description        sql.NullString
	Listed             sql.NullTime
	Comments           sql.NullInt32
	CategoryTitle      sql.NullString
	Posterusername     sql.NullString
}

func (q *Queries) GetLinkerItemsByUserDescendingForUser(ctx context.Context, arg GetLinkerItemsByUserDescendingForUserParams) ([]*GetLinkerItemsByUserDescendingForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getLinkerItemsByUserDescendingForUser,
		arg.ViewerID,
		arg.ViewerUserID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetLinkerItemsByUserDescendingForUserRow
	for rows.Next() {
		var i GetLinkerItemsByUserDescendingForUserRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.ForumthreadID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Comments,
			&i.CategoryTitle,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkerCategoryPath = `-- name: ListLinkerCategoryPath :many
WITH RECURSIVE category_path AS (
    SELECT lc.idlinkerCategory, NULL AS parent_id, lc.title, 0 AS depth
    FROM linker_category lc
    WHERE lc.idlinkerCategory = ?
)
SELECT category_path.idlinkerCategory, category_path.title
FROM category_path
`

type ListLinkerCategoryPathRow struct {
	Idlinkercategory int32
	Title            sql.NullString
}

func (q *Queries) ListLinkerCategoryPath(ctx context.Context, categoryID int32) ([]*ListLinkerCategoryPathRow, error) {
	rows, err := q.db.QueryContext(ctx, listLinkerCategoryPath, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListLinkerCategoryPathRow
	for rows.Next() {
		var i ListLinkerCategoryPathRow
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemAssignLinkerThreadID = `-- name: SystemAssignLinkerThreadID :exec
UPDATE linker SET forumthread_id = ? WHERE idlinker = ?
`

type SystemAssignLinkerThreadIDParams struct {
	ForumthreadID int32
	Idlinker      int32
}

func (q *Queries) SystemAssignLinkerThreadID(ctx context.Context, arg SystemAssignLinkerThreadIDParams) error {
	_, err := q.db.ExecContext(ctx, systemAssignLinkerThreadID, arg.ForumthreadID, arg.Idlinker)
	return err
}

const systemSetLinkerLastIndex = `-- name: SystemSetLinkerLastIndex :exec
UPDATE linker SET last_index = NOW() WHERE idlinker = ?
`

func (q *Queries) SystemSetLinkerLastIndex(ctx context.Context, idlinker int32) error {
	_, err := q.db.ExecContext(ctx, systemSetLinkerLastIndex, idlinker)
	return err
}
