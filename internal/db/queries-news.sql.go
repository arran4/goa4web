// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-news.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const assignNewsThisThreadId = `-- name: AssignNewsThisThreadId :exec
UPDATE site_news SET forumthread_id = ? WHERE idsiteNews = ?
`

type AssignNewsThisThreadIdParams struct {
	ForumthreadID int32
	Idsitenews    int32
}

func (q *Queries) AssignNewsThisThreadId(ctx context.Context, arg AssignNewsThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignNewsThisThreadId, arg.ForumthreadID, arg.Idsitenews)
	return err
}

const createNewsPost = `-- name: CreateNewsPost :execlastid
INSERT INTO site_news (news, users_idusers, occurred, language_idlanguage)
VALUES (?, ?, NOW(), ?)
`

type CreateNewsPostParams struct {
	News               sql.NullString
	UsersIdusers       int32
	LanguageIdlanguage int32
}

func (q *Queries) CreateNewsPost(ctx context.Context, arg CreateNewsPostParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createNewsPost, arg.News, arg.UsersIdusers, arg.LanguageIdlanguage)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deactivateNewsPost = `-- name: DeactivateNewsPost :exec
UPDATE site_news SET deleted_at = NOW() WHERE idsiteNews = ?
`

func (q *Queries) DeactivateNewsPost(ctx context.Context, idsitenews int32) error {
	_, err := q.db.ExecContext(ctx, deactivateNewsPost, idsitenews)
	return err
}

const getForumThreadIdByNewsPostId = `-- name: GetForumThreadIdByNewsPostId :one
SELECT s.forumthread_id, u.idusers
FROM site_news s
LEFT JOIN users u ON s.users_idusers = u.idusers
WHERE s.idsiteNews = ?
`

type GetForumThreadIdByNewsPostIdRow struct {
	ForumthreadID int32
	Idusers       sql.NullInt32
}

func (q *Queries) GetForumThreadIdByNewsPostId(ctx context.Context, idsitenews int32) (*GetForumThreadIdByNewsPostIdRow, error) {
	row := q.db.QueryRowContext(ctx, getForumThreadIdByNewsPostId, idsitenews)
	var i GetForumThreadIdByNewsPostIdRow
	err := row.Scan(&i.ForumthreadID, &i.Idusers)
	return &i, err
}

const getNewsPostByIdWithWriterIdAndThreadCommentCount = `-- name: GetNewsPostByIdWithWriterIdAndThreadCommentCount :one

WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT u.username AS writerName, u.idusers as writerId, s.idsitenews, s.forumthread_id, s.language_idlanguage, s.users_idusers, s.news, s.occurred, th.comments as Comments
FROM site_news s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_id = th.idforumthread
WHERE s.idsiteNews = ? AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='news'
      AND g.item='post'
      AND g.action='view'
      AND g.active=1
      AND g.item_id = s.idsiteNews
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
LIMIT 1
`

type GetNewsPostByIdWithWriterIdAndThreadCommentCountParams struct {
	ViewerID int32
	ID       int32
	UserID   sql.NullInt32
}

type GetNewsPostByIdWithWriterIdAndThreadCommentCountRow struct {
	Writername         sql.NullString
	Writerid           sql.NullInt32
	Idsitenews         int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	UsersIdusers       int32
	News               sql.NullString
	Occurred           sql.NullTime
	Comments           sql.NullInt32
}

func (q *Queries) GetNewsPostByIdWithWriterIdAndThreadCommentCount(ctx context.Context, arg GetNewsPostByIdWithWriterIdAndThreadCommentCountParams) (*GetNewsPostByIdWithWriterIdAndThreadCommentCountRow, error) {
	row := q.db.QueryRowContext(ctx, getNewsPostByIdWithWriterIdAndThreadCommentCount, arg.ViewerID, arg.ID, arg.UserID)
	var i GetNewsPostByIdWithWriterIdAndThreadCommentCountRow
	err := row.Scan(
		&i.Writername,
		&i.Writerid,
		&i.Idsitenews,
		&i.ForumthreadID,
		&i.LanguageIdlanguage,
		&i.UsersIdusers,
		&i.News,
		&i.Occurred,
		&i.Comments,
	)
	return &i, err
}

const getNewsPostsByIdsForUserWithWriterIdAndThreadCommentCount = `-- name: GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCount :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT u.username AS writerName, u.idusers as writerId, s.idsitenews, s.forumthread_id, s.language_idlanguage, s.users_idusers, s.news, s.occurred, th.comments as Comments
FROM site_news s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_id = th.idforumthread
WHERE s.Idsitenews IN (/*SLICE:newsids*/?) AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='news'
      AND g.item='post'
      AND g.action='view'
      AND g.active=1
      AND g.item_id = s.idsiteNews
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
ORDER BY s.occurred DESC
`

type GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountParams struct {
	ViewerID int32
	Newsids  []int32
	UserID   sql.NullInt32
}

type GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountRow struct {
	Writername         sql.NullString
	Writerid           sql.NullInt32
	Idsitenews         int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	UsersIdusers       int32
	News               sql.NullString
	Occurred           sql.NullTime
	Comments           sql.NullInt32
}

func (q *Queries) GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCount(ctx context.Context, arg GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountParams) ([]*GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountRow, error) {
	query := getNewsPostsByIdsForUserWithWriterIdAndThreadCommentCount
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ViewerID)
	if len(arg.Newsids) > 0 {
		for _, v := range arg.Newsids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:newsids*/?", strings.Repeat(",?", len(arg.Newsids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:newsids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountRow
	for rows.Next() {
		var i GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountRow
		if err := rows.Scan(
			&i.Writername,
			&i.Writerid,
			&i.Idsitenews,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.News,
			&i.Occurred,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsPostsByIdsWithWriterIdAndThreadCommentCount = `-- name: GetNewsPostsByIdsWithWriterIdAndThreadCommentCount :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT u.username AS writerName, u.idusers as writerId, s.idsitenews, s.forumthread_id, s.language_idlanguage, s.users_idusers, s.news, s.occurred, th.comments as Comments
FROM site_news s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_id = th.idforumthread
WHERE s.Idsitenews IN (/*SLICE:newsids*/?) AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='news'
      AND g.item='post'
      AND g.action='see'
      AND g.active=1
      AND g.item_id = s.idsiteNews
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
ORDER BY s.occurred DESC
`

type GetNewsPostsByIdsWithWriterIdAndThreadCommentCountParams struct {
	ViewerID int32
	Newsids  []int32
	UserID   sql.NullInt32
}

type GetNewsPostsByIdsWithWriterIdAndThreadCommentCountRow struct {
	Writername         sql.NullString
	Writerid           sql.NullInt32
	Idsitenews         int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	UsersIdusers       int32
	News               sql.NullString
	Occurred           sql.NullTime
	Comments           sql.NullInt32
}

func (q *Queries) GetNewsPostsByIdsWithWriterIdAndThreadCommentCount(ctx context.Context, arg GetNewsPostsByIdsWithWriterIdAndThreadCommentCountParams) ([]*GetNewsPostsByIdsWithWriterIdAndThreadCommentCountRow, error) {
	query := getNewsPostsByIdsWithWriterIdAndThreadCommentCount
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ViewerID)
	if len(arg.Newsids) > 0 {
		for _, v := range arg.Newsids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:newsids*/?", strings.Repeat(",?", len(arg.Newsids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:newsids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNewsPostsByIdsWithWriterIdAndThreadCommentCountRow
	for rows.Next() {
		var i GetNewsPostsByIdsWithWriterIdAndThreadCommentCountRow
		if err := rows.Scan(
			&i.Writername,
			&i.Writerid,
			&i.Idsitenews,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.News,
			&i.Occurred,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsPostsWithWriterUsernameAndThreadCommentCountDescending = `-- name: GetNewsPostsWithWriterUsernameAndThreadCommentCountDescending :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT u.username AS writerName, u.idusers as writerId, s.idsitenews, s.forumthread_id, s.language_idlanguage, s.users_idusers, s.news, s.occurred, th.comments as Comments
FROM site_news s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_id = th.idforumthread
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='news'
      AND g.item='post'
      AND g.action='see'
      AND g.active=1
      AND g.item_id = s.idsiteNews
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
ORDER BY s.occurred DESC
LIMIT ? OFFSET ?
`

type GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingParams struct {
	ViewerID int32
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow struct {
	Writername         sql.NullString
	Writerid           sql.NullInt32
	Idsitenews         int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	UsersIdusers       int32
	News               sql.NullString
	Occurred           sql.NullTime
	Comments           sql.NullInt32
}

func (q *Queries) GetNewsPostsWithWriterUsernameAndThreadCommentCountDescending(ctx context.Context, arg GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingParams) ([]*GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow, error) {
	rows, err := q.db.QueryContext(ctx, getNewsPostsWithWriterUsernameAndThreadCommentCountDescending,
		arg.ViewerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow
	for rows.Next() {
		var i GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow
		if err := rows.Scan(
			&i.Writername,
			&i.Writerid,
			&i.Idsitenews,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.News,
			&i.Occurred,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setSiteNewsLastIndex = `-- name: SetSiteNewsLastIndex :exec
UPDATE site_news SET last_index = NOW() WHERE idsiteNews = ?
`

func (q *Queries) SetSiteNewsLastIndex(ctx context.Context, idsitenews int32) error {
	_, err := q.db.ExecContext(ctx, setSiteNewsLastIndex, idsitenews)
	return err
}

const updateNewsPost = `-- name: UpdateNewsPost :exec
UPDATE site_news SET news = ?, language_idlanguage = ? WHERE idsiteNews = ?
`

type UpdateNewsPostParams struct {
	News               sql.NullString
	LanguageIdlanguage int32
	Idsitenews         int32
}

func (q *Queries) UpdateNewsPost(ctx context.Context, arg UpdateNewsPostParams) error {
	_, err := q.db.ExecContext(ctx, updateNewsPost, arg.News, arg.LanguageIdlanguage, arg.Idsitenews)
	return err
}
