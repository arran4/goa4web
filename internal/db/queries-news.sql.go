// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries-news.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const adminListNewsPostsWithWriterUsernameAndThreadCommentCountDescending = `-- name: AdminListNewsPostsWithWriterUsernameAndThreadCommentCountDescending :many
SELECT u.username AS writerName, u.idusers as writerId, s.idsiteNews, s.forumthread_id, s.language_id, s.users_idusers,
s.news, s.occurred, s.timezone, th.comments as Comments
FROM site_news s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_id = th.idforumthread
ORDER BY s.occurred DESC
LIMIT ? OFFSET ?
`

type AdminListNewsPostsWithWriterUsernameAndThreadCommentCountDescendingParams struct {
	Limit  int32
	Offset int32
}

type AdminListNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow struct {
	Writername    sql.NullString
	Writerid      sql.NullInt32
	Idsitenews    int32
	ForumthreadID int32
	LanguageID    sql.NullInt32
	UsersIdusers  int32
	News          sql.NullString
	Occurred      sql.NullTime
	Timezone      sql.NullString
	Comments      sql.NullInt32
}

func (q *Queries) AdminListNewsPostsWithWriterUsernameAndThreadCommentCountDescending(ctx context.Context, arg AdminListNewsPostsWithWriterUsernameAndThreadCommentCountDescendingParams) ([]*AdminListNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListNewsPostsWithWriterUsernameAndThreadCommentCountDescending, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow
	for rows.Next() {
		var i AdminListNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow
		if err := rows.Scan(
			&i.Writername,
			&i.Writerid,
			&i.Idsitenews,
			&i.ForumthreadID,
			&i.LanguageID,
			&i.UsersIdusers,
			&i.News,
			&i.Occurred,
			&i.Timezone,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminReplaceSiteNewsURL = `-- name: AdminReplaceSiteNewsURL :exec
UPDATE site_news SET news = REPLACE(news, ?, ?) WHERE idsiteNews = ?
`

type AdminReplaceSiteNewsURLParams struct {
	OldUrl string
	NewUrl string
	ID     int32
}

func (q *Queries) AdminReplaceSiteNewsURL(ctx context.Context, arg AdminReplaceSiteNewsURLParams) error {
	_, err := q.db.ExecContext(ctx, adminReplaceSiteNewsURL, arg.OldUrl, arg.NewUrl, arg.ID)
	return err
}

const createNewsPostForWriter = `-- name: CreateNewsPostForWriter :execlastid
INSERT INTO site_news (news, users_idusers, occurred, timezone, language_id)
SELECT ?, ?, ?, ?, ?
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='news'
      AND (g.item='post' OR g.item IS NULL)
      AND g.action='post'
      AND g.active=1
      AND (g.item_id = 0 OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
)
`

type CreateNewsPostForWriterParams struct {
	News       sql.NullString
	WriterID   int32
	Occurred   sql.NullTime
	Timezone   sql.NullString
	LanguageID sql.NullInt32
	GranteeID  sql.NullInt32
}

func (q *Queries) CreateNewsPostForWriter(ctx context.Context, arg CreateNewsPostForWriterParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createNewsPostForWriter,
		arg.News,
		arg.WriterID,
		arg.Occurred,
		arg.Timezone,
		arg.LanguageID,
		arg.GranteeID,
		arg.WriterID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deactivateNewsPost = `-- name: DeactivateNewsPost :exec
UPDATE site_news SET deleted_at = NOW() WHERE idsiteNews = ?
`

func (q *Queries) DeactivateNewsPost(ctx context.Context, idsitenews int32) error {
	_, err := q.db.ExecContext(ctx, deactivateNewsPost, idsitenews)
	return err
}

const getAllSiteNewsForIndex = `-- name: GetAllSiteNewsForIndex :many
SELECT idsiteNews, news FROM site_news WHERE deleted_at IS NULL
`

type GetAllSiteNewsForIndexRow struct {
	Idsitenews int32
	News       sql.NullString
}

func (q *Queries) GetAllSiteNewsForIndex(ctx context.Context) ([]*GetAllSiteNewsForIndexRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSiteNewsForIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllSiteNewsForIndexRow
	for rows.Next() {
		var i GetAllSiteNewsForIndexRow
		if err := rows.Scan(&i.Idsitenews, &i.News); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForumThreadIdByNewsPostId = `-- name: GetForumThreadIdByNewsPostId :one
SELECT s.forumthread_id, u.idusers
FROM site_news s
LEFT JOIN users u ON s.users_idusers = u.idusers
WHERE s.idsiteNews = ?
`

type GetForumThreadIdByNewsPostIdRow struct {
	ForumthreadID int32
	Idusers       sql.NullInt32
}

func (q *Queries) GetForumThreadIdByNewsPostId(ctx context.Context, idsitenews int32) (*GetForumThreadIdByNewsPostIdRow, error) {
	row := q.db.QueryRowContext(ctx, getForumThreadIdByNewsPostId, idsitenews)
	var i GetForumThreadIdByNewsPostIdRow
	err := row.Scan(&i.ForumthreadID, &i.Idusers)
	return &i, err
}

const getNewsPostByIdWithWriterIdAndThreadCommentCount = `-- name: GetNewsPostByIdWithWriterIdAndThreadCommentCount :one
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT u.username AS writerName, u.idusers as writerId, s.idsiteNews, s.forumthread_id, s.language_id, s.users_idusers, s.news, s.occurred, s.timezone, th.comments as Comments
FROM site_news s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_id = th.idforumthread
WHERE s.idsiteNews = ? AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='news'
      AND (g.item='post' OR g.item IS NULL)
      AND g.action='view'
      AND g.active=1
      AND (g.item_id = s.idsiteNews OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
LIMIT 1
`

type GetNewsPostByIdWithWriterIdAndThreadCommentCountParams struct {
	ViewerID int32
	ID       int32
	UserID   sql.NullInt32
}

type GetNewsPostByIdWithWriterIdAndThreadCommentCountRow struct {
	Writername    sql.NullString
	Writerid      sql.NullInt32
	Idsitenews    int32
	ForumthreadID int32
	LanguageID    sql.NullInt32
	UsersIdusers  int32
	News          sql.NullString
	Occurred      sql.NullTime
	Timezone      sql.NullString
	Comments      sql.NullInt32
}

func (q *Queries) GetNewsPostByIdWithWriterIdAndThreadCommentCount(ctx context.Context, arg GetNewsPostByIdWithWriterIdAndThreadCommentCountParams) (*GetNewsPostByIdWithWriterIdAndThreadCommentCountRow, error) {
	row := q.db.QueryRowContext(ctx, getNewsPostByIdWithWriterIdAndThreadCommentCount, arg.ViewerID, arg.ID, arg.UserID)
	var i GetNewsPostByIdWithWriterIdAndThreadCommentCountRow
	err := row.Scan(
		&i.Writername,
		&i.Writerid,
		&i.Idsitenews,
		&i.ForumthreadID,
		&i.LanguageID,
		&i.UsersIdusers,
		&i.News,
		&i.Occurred,
		&i.Timezone,
		&i.Comments,
	)
	return &i, err
}

const getNewsPostsByIdsForUserWithWriterIdAndThreadCommentCount = `-- name: GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCount :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT u.username AS writerName, u.idusers as writerId, s.idsiteNews, s.forumthread_id, s.language_id, s.users_idusers, s.news, s.occurred, s.timezone, th.comments as Comments
FROM site_news s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_id = th.idforumthread
WHERE s.Idsitenews IN (/*SLICE:newsids*/?)
  AND (
      NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
      OR s.language_id = 0
      OR s.language_id IS NULL
      OR s.language_id IN (
          SELECT ul.language_id
          FROM user_language ul
          WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='news'
      AND (g.item='post' OR g.item IS NULL)
      AND g.action='view'
      AND g.active=1
      AND (g.item_id = s.idsiteNews OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
ORDER BY s.occurred DESC
`

type GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountParams struct {
	ViewerID int32
	Newsids  []int32
	UserID   sql.NullInt32
}

type GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountRow struct {
	Writername    sql.NullString
	Writerid      sql.NullInt32
	Idsitenews    int32
	ForumthreadID int32
	LanguageID    sql.NullInt32
	UsersIdusers  int32
	News          sql.NullString
	Occurred      sql.NullTime
	Timezone      sql.NullString
	Comments      sql.NullInt32
}

func (q *Queries) GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCount(ctx context.Context, arg GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountParams) ([]*GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountRow, error) {
	query := getNewsPostsByIdsForUserWithWriterIdAndThreadCommentCount
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ViewerID)
	if len(arg.Newsids) > 0 {
		for _, v := range arg.Newsids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:newsids*/?", strings.Repeat(",?", len(arg.Newsids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:newsids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ViewerID)
	queryParams = append(queryParams, arg.ViewerID)
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountRow
	for rows.Next() {
		var i GetNewsPostsByIdsForUserWithWriterIdAndThreadCommentCountRow
		if err := rows.Scan(
			&i.Writername,
			&i.Writerid,
			&i.Idsitenews,
			&i.ForumthreadID,
			&i.LanguageID,
			&i.UsersIdusers,
			&i.News,
			&i.Occurred,
			&i.Timezone,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsPostsWithWriterUsernameAndThreadCommentCountDescending = `-- name: GetNewsPostsWithWriterUsernameAndThreadCommentCountDescending :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT u.username AS writerName, u.idusers as writerId, s.idsiteNews, s.forumthread_id, s.language_id, s.users_idusers, s.news, s.occurred, s.timezone, th.comments as Comments
FROM site_news s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_id = th.idforumthread
WHERE (
    NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
    OR s.language_id = 0
    OR s.language_id IS NULL
    OR s.language_id IN (
        SELECT ul.language_id FROM user_language ul WHERE ul.users_idusers = ?
    )
)
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='news'
      AND (g.item='post' OR g.item IS NULL)
      AND g.action='see'
      AND g.active=1
      AND (g.item_id = s.idsiteNews OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
ORDER BY s.occurred DESC
LIMIT ? OFFSET ?
`

type GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingParams struct {
	ViewerID int32
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow struct {
	Writername    sql.NullString
	Writerid      sql.NullInt32
	Idsitenews    int32
	ForumthreadID int32
	LanguageID    sql.NullInt32
	UsersIdusers  int32
	News          sql.NullString
	Occurred      sql.NullTime
	Timezone      sql.NullString
	Comments      sql.NullInt32
}

func (q *Queries) GetNewsPostsWithWriterUsernameAndThreadCommentCountDescending(ctx context.Context, arg GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingParams) ([]*GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow, error) {
	rows, err := q.db.QueryContext(ctx, getNewsPostsWithWriterUsernameAndThreadCommentCountDescending,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow
	for rows.Next() {
		var i GetNewsPostsWithWriterUsernameAndThreadCommentCountDescendingRow
		if err := rows.Scan(
			&i.Writername,
			&i.Writerid,
			&i.Idsitenews,
			&i.ForumthreadID,
			&i.LanguageID,
			&i.UsersIdusers,
			&i.News,
			&i.Occurred,
			&i.Timezone,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemAssignNewsThreadID = `-- name: SystemAssignNewsThreadID :exec
UPDATE site_news SET forumthread_id = ? WHERE idsiteNews = ?
`

type SystemAssignNewsThreadIDParams struct {
	ForumthreadID int32
	Idsitenews    int32
}

func (q *Queries) SystemAssignNewsThreadID(ctx context.Context, arg SystemAssignNewsThreadIDParams) error {
	_, err := q.db.ExecContext(ctx, systemAssignNewsThreadID, arg.ForumthreadID, arg.Idsitenews)
	return err
}

const systemGetNewsPostByID = `-- name: SystemGetNewsPostByID :one
SELECT forumthread_id
FROM site_news
WHERE idsiteNews = ?
`

func (q *Queries) SystemGetNewsPostByID(ctx context.Context, idsitenews int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, systemGetNewsPostByID, idsitenews)
	var forumthread_id int32
	err := row.Scan(&forumthread_id)
	return forumthread_id, err
}

const systemSetSiteNewsLastIndex = `-- name: SystemSetSiteNewsLastIndex :exec
UPDATE site_news SET last_index = NOW() WHERE idsiteNews = ?
`

func (q *Queries) SystemSetSiteNewsLastIndex(ctx context.Context, idsitenews int32) error {
	_, err := q.db.ExecContext(ctx, systemSetSiteNewsLastIndex, idsitenews)
	return err
}

const updateNewsPostForWriter = `-- name: UpdateNewsPostForWriter :exec
UPDATE site_news s
SET news = ?, language_id = ?
WHERE s.idsiteNews = ?
  AND s.users_idusers = ?
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='news'
      AND (g.item='post' OR g.item IS NULL)
      AND g.action='post'
      AND g.active=1
      AND (g.item_id = ? OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
  )
`

type UpdateNewsPostForWriterParams struct {
	News        sql.NullString
	LanguageID  sql.NullInt32
	PostID      int32
	WriterID    int32
	GrantPostID sql.NullInt32
	GranteeID   sql.NullInt32
}

func (q *Queries) UpdateNewsPostForWriter(ctx context.Context, arg UpdateNewsPostForWriterParams) error {
	_, err := q.db.ExecContext(ctx, updateNewsPostForWriter,
		arg.News,
		arg.LanguageID,
		arg.PostID,
		arg.WriterID,
		arg.GrantPostID,
		arg.GranteeID,
		arg.WriterID,
	)
	return err
}
