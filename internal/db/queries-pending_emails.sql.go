// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries-pending_emails.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const adminDeletePendingEmail = `-- name: AdminDeletePendingEmail :exec
DELETE FROM pending_emails WHERE id = ?
`

// admin task
func (q *Queries) AdminDeletePendingEmail(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, adminDeletePendingEmail, id)
	return err
}

const adminGetPendingEmailByID = `-- name: AdminGetPendingEmailByID :one
SELECT id, to_user_id, body, error_count, direct_email
FROM pending_emails
WHERE id = ?
`

type AdminGetPendingEmailByIDRow struct {
	ID          int32
	ToUserID    sql.NullInt32
	Body        string
	ErrorCount  int32
	DirectEmail bool
}

// admin task
func (q *Queries) AdminGetPendingEmailByID(ctx context.Context, id int32) (*AdminGetPendingEmailByIDRow, error) {
	row := q.db.QueryRowContext(ctx, adminGetPendingEmailByID, id)
	var i AdminGetPendingEmailByIDRow
	err := row.Scan(
		&i.ID,
		&i.ToUserID,
		&i.Body,
		&i.ErrorCount,
		&i.DirectEmail,
	)
	return &i, err
}

const adminListFailedEmailIDs = `-- name: AdminListFailedEmailIDs :many
SELECT pe.id
FROM pending_emails pe
LEFT JOIN preferences p ON pe.to_user_id = p.users_idusers
LEFT JOIN user_roles ur ON pe.to_user_id = ur.users_idusers
LEFT JOIN roles r ON ur.role_id = r.id
WHERE pe.sent_at IS NULL AND pe.error_count > 0
  AND (? IS NULL OR p.language_id = ?)
  AND (? IS NULL OR r.name = ?)
ORDER BY pe.id
`

type AdminListFailedEmailIDsParams struct {
	LanguageID sql.NullInt32
	RoleName   string
}

// admin task
func (q *Queries) AdminListFailedEmailIDs(ctx context.Context, arg AdminListFailedEmailIDsParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, adminListFailedEmailIDs,
		arg.LanguageID,
		arg.LanguageID,
		arg.RoleName,
		arg.RoleName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListFailedEmails = `-- name: AdminListFailedEmails :many
SELECT pe.id, pe.to_user_id, pe.body, pe.error_count, pe.created_at, pe.direct_email
FROM pending_emails pe
LEFT JOIN preferences p ON pe.to_user_id = p.users_idusers
LEFT JOIN user_roles ur ON pe.to_user_id = ur.users_idusers
LEFT JOIN roles r ON ur.role_id = r.id
WHERE pe.sent_at IS NULL AND pe.error_count > 0
  AND (? IS NULL OR p.language_id = ?)
  AND (? IS NULL OR r.name = ?)
ORDER BY pe.id
LIMIT ? OFFSET ?
`

type AdminListFailedEmailsParams struct {
	LanguageID sql.NullInt32
	RoleName   string
	Limit      int32
	Offset     int32
}

type AdminListFailedEmailsRow struct {
	ID          int32
	ToUserID    sql.NullInt32
	Body        string
	ErrorCount  int32
	CreatedAt   time.Time
	DirectEmail bool
}

// admin task
func (q *Queries) AdminListFailedEmails(ctx context.Context, arg AdminListFailedEmailsParams) ([]*AdminListFailedEmailsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListFailedEmails,
		arg.LanguageID,
		arg.LanguageID,
		arg.RoleName,
		arg.RoleName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListFailedEmailsRow
	for rows.Next() {
		var i AdminListFailedEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ToUserID,
			&i.Body,
			&i.ErrorCount,
			&i.CreatedAt,
			&i.DirectEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListSentEmailIDs = `-- name: AdminListSentEmailIDs :many
SELECT pe.id
FROM pending_emails pe
LEFT JOIN preferences p ON pe.to_user_id = p.users_idusers
LEFT JOIN user_roles ur ON pe.to_user_id = ur.users_idusers
LEFT JOIN roles r ON ur.role_id = r.id
WHERE pe.sent_at IS NOT NULL
  AND (? IS NULL OR p.language_id = ?)
  AND (? IS NULL OR r.name = ?)
ORDER BY pe.sent_at DESC
`

type AdminListSentEmailIDsParams struct {
	LanguageID sql.NullInt32
	RoleName   string
}

// admin task
func (q *Queries) AdminListSentEmailIDs(ctx context.Context, arg AdminListSentEmailIDsParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, adminListSentEmailIDs,
		arg.LanguageID,
		arg.LanguageID,
		arg.RoleName,
		arg.RoleName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListSentEmails = `-- name: AdminListSentEmails :many
SELECT pe.id, pe.to_user_id, pe.body, pe.error_count, pe.created_at, pe.sent_at, pe.direct_email
FROM pending_emails pe
LEFT JOIN preferences p ON pe.to_user_id = p.users_idusers
LEFT JOIN user_roles ur ON pe.to_user_id = ur.users_idusers
LEFT JOIN roles r ON ur.role_id = r.id
WHERE pe.sent_at IS NOT NULL
  AND (? IS NULL OR p.language_id = ?)
  AND (? IS NULL OR r.name = ?)
ORDER BY pe.sent_at DESC
LIMIT ? OFFSET ?
`

type AdminListSentEmailsParams struct {
	LanguageID sql.NullInt32
	RoleName   string
	Limit      int32
	Offset     int32
}

type AdminListSentEmailsRow struct {
	ID          int32
	ToUserID    sql.NullInt32
	Body        string
	ErrorCount  int32
	CreatedAt   time.Time
	SentAt      sql.NullTime
	DirectEmail bool
}

// admin task
func (q *Queries) AdminListSentEmails(ctx context.Context, arg AdminListSentEmailsParams) ([]*AdminListSentEmailsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListSentEmails,
		arg.LanguageID,
		arg.LanguageID,
		arg.RoleName,
		arg.RoleName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListSentEmailsRow
	for rows.Next() {
		var i AdminListSentEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ToUserID,
			&i.Body,
			&i.ErrorCount,
			&i.CreatedAt,
			&i.SentAt,
			&i.DirectEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListUnsentPendingEmails = `-- name: AdminListUnsentPendingEmails :many
SELECT pe.id, pe.to_user_id, pe.body, pe.error_count, pe.created_at, pe.direct_email
FROM pending_emails pe
LEFT JOIN preferences p ON pe.to_user_id = p.users_idusers
LEFT JOIN user_roles ur ON pe.to_user_id = ur.users_idusers
LEFT JOIN roles r ON ur.role_id = r.id
WHERE pe.sent_at IS NULL
  AND (? IS NULL
    OR (? = 'pending' AND pe.error_count = 0)
    OR (? = 'failed' AND pe.error_count > 0))
  AND (? IS NULL
    OR (? = 'direct' AND pe.direct_email = 1)
    OR (? = 'user' AND pe.direct_email = 0 AND pe.to_user_id IS NOT NULL AND pe.to_user_id <> 0)
    OR (? = 'userless' AND pe.direct_email = 0 AND (pe.to_user_id IS NULL OR pe.to_user_id = 0)))
  AND (? IS NULL OR pe.created_at <= ?)
  AND (? IS NULL OR p.language_id = ?)
  AND (? IS NULL OR r.name = ?)
ORDER BY pe.id
`

type AdminListUnsentPendingEmailsParams struct {
	Status        interface{}
	Provider      interface{}
	CreatedBefore sql.NullTime
	LanguageID    sql.NullInt32
	RoleName      string
}

type AdminListUnsentPendingEmailsRow struct {
	ID          int32
	ToUserID    sql.NullInt32
	Body        string
	ErrorCount  int32
	CreatedAt   time.Time
	DirectEmail bool
}

// admin task
func (q *Queries) AdminListUnsentPendingEmails(ctx context.Context, arg AdminListUnsentPendingEmailsParams) ([]*AdminListUnsentPendingEmailsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListUnsentPendingEmails,
		arg.Status,
		arg.Status,
		arg.Status,
		arg.Provider,
		arg.Provider,
		arg.Provider,
		arg.Provider,
		arg.CreatedBefore,
		arg.CreatedBefore,
		arg.LanguageID,
		arg.LanguageID,
		arg.RoleName,
		arg.RoleName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListUnsentPendingEmailsRow
	for rows.Next() {
		var i AdminListUnsentPendingEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ToUserID,
			&i.Body,
			&i.ErrorCount,
			&i.CreatedAt,
			&i.DirectEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingEmailErrorCount = `-- name: GetPendingEmailErrorCount :one
SELECT error_count FROM pending_emails WHERE id = ?
`

func (q *Queries) GetPendingEmailErrorCount(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getPendingEmailErrorCount, id)
	var error_count int32
	err := row.Scan(&error_count)
	return error_count, err
}

const insertPendingEmail = `-- name: InsertPendingEmail :exec
INSERT INTO pending_emails (to_user_id, body, direct_email)
VALUES (?, ?, ?)
`

type InsertPendingEmailParams struct {
	ToUserID    sql.NullInt32
	Body        string
	DirectEmail bool
}

func (q *Queries) InsertPendingEmail(ctx context.Context, arg InsertPendingEmailParams) error {
	_, err := q.db.ExecContext(ctx, insertPendingEmail, arg.ToUserID, arg.Body, arg.DirectEmail)
	return err
}

const systemIncrementPendingEmailError = `-- name: SystemIncrementPendingEmailError :exec
UPDATE pending_emails SET error_count = error_count + 1 WHERE id = ?
`

func (q *Queries) SystemIncrementPendingEmailError(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, systemIncrementPendingEmailError, id)
	return err
}

const systemListPendingEmails = `-- name: SystemListPendingEmails :many
SELECT id, to_user_id, body, error_count, direct_email
FROM pending_emails
WHERE sent_at IS NULL
ORDER BY id
LIMIT ? OFFSET ?
`

type SystemListPendingEmailsParams struct {
	Limit  int32
	Offset int32
}

type SystemListPendingEmailsRow struct {
	ID          int32
	ToUserID    sql.NullInt32
	Body        string
	ErrorCount  int32
	DirectEmail bool
}

func (q *Queries) SystemListPendingEmails(ctx context.Context, arg SystemListPendingEmailsParams) ([]*SystemListPendingEmailsRow, error) {
	rows, err := q.db.QueryContext(ctx, systemListPendingEmails, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SystemListPendingEmailsRow
	for rows.Next() {
		var i SystemListPendingEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ToUserID,
			&i.Body,
			&i.ErrorCount,
			&i.DirectEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemMarkPendingEmailSent = `-- name: SystemMarkPendingEmailSent :exec
UPDATE pending_emails SET sent_at = NOW() WHERE id = ?
`

func (q *Queries) SystemMarkPendingEmailSent(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, systemMarkPendingEmailSent, id)
	return err
}
