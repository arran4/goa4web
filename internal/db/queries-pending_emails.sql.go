// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-pending_emails.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const deletePendingEmail = `-- name: DeletePendingEmail :exec
DELETE FROM pending_emails WHERE id = ?
`

func (q *Queries) DeletePendingEmail(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePendingEmail, id)
	return err
}

const fetchPendingEmails = `-- name: FetchPendingEmails :many
SELECT id, to_user_id, body, error_count, direct_email
FROM pending_emails
WHERE sent_at IS NULL
ORDER BY id
LIMIT ?
`

type FetchPendingEmailsRow struct {
	ID          int32
	ToUserID    sql.NullInt32
	Body        string
	ErrorCount  int32
	DirectEmail bool
}

func (q *Queries) FetchPendingEmails(ctx context.Context, limit int32) ([]*FetchPendingEmailsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPendingEmails, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchPendingEmailsRow
	for rows.Next() {
		var i FetchPendingEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ToUserID,
			&i.Body,
			&i.ErrorCount,
			&i.DirectEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingEmailByID = `-- name: GetPendingEmailByID :one
SELECT id, to_user_id, body, error_count, direct_email
FROM pending_emails
WHERE id = ?
`

type GetPendingEmailByIDRow struct {
	ID          int32
	ToUserID    sql.NullInt32
	Body        string
	ErrorCount  int32
	DirectEmail bool
}

func (q *Queries) GetPendingEmailByID(ctx context.Context, id int32) (*GetPendingEmailByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPendingEmailByID, id)
	var i GetPendingEmailByIDRow
	err := row.Scan(
		&i.ID,
		&i.ToUserID,
		&i.Body,
		&i.ErrorCount,
		&i.DirectEmail,
	)
	return &i, err
}

const getPendingEmailErrorCount = `-- name: GetPendingEmailErrorCount :one
SELECT error_count FROM pending_emails WHERE id = ?
`

func (q *Queries) GetPendingEmailErrorCount(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getPendingEmailErrorCount, id)
	var error_count int32
	err := row.Scan(&error_count)
	return error_count, err
}

const incrementEmailError = `-- name: IncrementEmailError :exec
UPDATE pending_emails SET error_count = error_count + 1 WHERE id = ?
`

func (q *Queries) IncrementEmailError(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, incrementEmailError, id)
	return err
}

const insertPendingEmail = `-- name: InsertPendingEmail :exec
INSERT INTO pending_emails (to_user_id, body, direct_email)
VALUES (?, ?, ?)
`

type InsertPendingEmailParams struct {
	ToUserID    sql.NullInt32
	Body        string
	DirectEmail bool
}

func (q *Queries) InsertPendingEmail(ctx context.Context, arg InsertPendingEmailParams) error {
	_, err := q.db.ExecContext(ctx, insertPendingEmail, arg.ToUserID, arg.Body, arg.DirectEmail)
	return err
}

const listSentEmails = `-- name: ListSentEmails :many
SELECT id, to_user_id, body, error_count, created_at, sent_at, direct_email
FROM pending_emails
WHERE sent_at IS NOT NULL
ORDER BY sent_at DESC
LIMIT ? OFFSET ?
`

type ListSentEmailsParams struct {
	Limit  int32
	Offset int32
}

type ListSentEmailsRow struct {
	ID          int32
	ToUserID    sql.NullInt32
	Body        string
	ErrorCount  int32
	CreatedAt   time.Time
	SentAt      sql.NullTime
	DirectEmail bool
}

func (q *Queries) ListSentEmails(ctx context.Context, arg ListSentEmailsParams) ([]*ListSentEmailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listSentEmails, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListSentEmailsRow
	for rows.Next() {
		var i ListSentEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ToUserID,
			&i.Body,
			&i.ErrorCount,
			&i.CreatedAt,
			&i.SentAt,
			&i.DirectEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnsentPendingEmails = `-- name: ListUnsentPendingEmails :many
SELECT id, to_user_id, body, error_count, created_at, direct_email
FROM pending_emails
WHERE sent_at IS NULL
ORDER BY id
`

type ListUnsentPendingEmailsRow struct {
	ID          int32
	ToUserID    sql.NullInt32
	Body        string
	ErrorCount  int32
	CreatedAt   time.Time
	DirectEmail bool
}

func (q *Queries) ListUnsentPendingEmails(ctx context.Context) ([]*ListUnsentPendingEmailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUnsentPendingEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUnsentPendingEmailsRow
	for rows.Next() {
		var i ListUnsentPendingEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ToUserID,
			&i.Body,
			&i.ErrorCount,
			&i.CreatedAt,
			&i.DirectEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailSent = `-- name: MarkEmailSent :exec
UPDATE pending_emails SET sent_at = NOW() WHERE id = ?
`

func (q *Queries) MarkEmailSent(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markEmailSent, id)
	return err
}
