// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-pending_emails.sql

package db

import (
	"context"
	"time"
)

const deletePendingEmail = `-- name: DeletePendingEmail :exec
DELETE FROM pending_emails WHERE id = ?
`

func (q *Queries) DeletePendingEmail(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePendingEmail, id)
	return err
}

const fetchPendingEmails = `-- name: FetchPendingEmails :many
SELECT id, to_user_id, body, error_count
FROM pending_emails
WHERE sent_at IS NULL
ORDER BY id
LIMIT ?
`

type FetchPendingEmailsRow struct {
	ID         int32
	ToUserID   int32
	Body       string
	ErrorCount int32
}

func (q *Queries) FetchPendingEmails(ctx context.Context, limit int32) ([]*FetchPendingEmailsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPendingEmails, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchPendingEmailsRow
	for rows.Next() {
		var i FetchPendingEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ToUserID,
			&i.Body,
			&i.ErrorCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingEmailByID = `-- name: GetPendingEmailByID :one
SELECT id, to_user_id, body, error_count
FROM pending_emails
WHERE id = ?
`

type GetPendingEmailByIDRow struct {
	ID         int32
	ToUserID   int32
	Body       string
	ErrorCount int32
}

func (q *Queries) GetPendingEmailByID(ctx context.Context, id int32) (*GetPendingEmailByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPendingEmailByID, id)
	var i GetPendingEmailByIDRow
	err := row.Scan(
		&i.ID,
		&i.ToUserID,
		&i.Body,
		&i.ErrorCount,
	)
	return &i, err
}

const getPendingEmailErrorCount = `-- name: GetPendingEmailErrorCount :one
SELECT error_count FROM pending_emails WHERE id = ?
`

func (q *Queries) GetPendingEmailErrorCount(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getPendingEmailErrorCount, id)
	var error_count int32
	err := row.Scan(&error_count)
	return error_count, err
}

const incrementEmailError = `-- name: IncrementEmailError :exec
UPDATE pending_emails SET error_count = error_count + 1 WHERE id = ?
`

func (q *Queries) IncrementEmailError(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, incrementEmailError, id)
	return err
}

const insertPendingEmail = `-- name: InsertPendingEmail :exec
INSERT INTO pending_emails (to_user_id, body)
VALUES (?, ?)
`

type InsertPendingEmailParams struct {
	ToUserID int32
	Body     string
}

func (q *Queries) InsertPendingEmail(ctx context.Context, arg InsertPendingEmailParams) error {
	_, err := q.db.ExecContext(ctx, insertPendingEmail, arg.ToUserID, arg.Body)
	return err
}

const listUnsentPendingEmails = `-- name: ListUnsentPendingEmails :many
SELECT id, to_user_id, body, error_count, created_at
FROM pending_emails
WHERE sent_at IS NULL
ORDER BY id
`

type ListUnsentPendingEmailsRow struct {
	ID         int32
	ToUserID   int32
	Body       string
	ErrorCount int32
	CreatedAt  time.Time
}

func (q *Queries) ListUnsentPendingEmails(ctx context.Context) ([]*ListUnsentPendingEmailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUnsentPendingEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUnsentPendingEmailsRow
	for rows.Next() {
		var i ListUnsentPendingEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ToUserID,
			&i.Body,
			&i.ErrorCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailSent = `-- name: MarkEmailSent :exec
UPDATE pending_emails SET sent_at = NOW() WHERE id = ?
`

func (q *Queries) MarkEmailSent(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markEmailSent, id)
	return err
}
