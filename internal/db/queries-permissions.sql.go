// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-permissions.sql

package db

import (
	"context"
	"database/sql"
)

const checkGrant = `-- name: CheckGrant :one
WITH RECURSIVE role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT 1 FROM grants g
WHERE g.section = ?
  AND (g.item = ? OR g.item IS NULL)
  AND g.action = ?
  AND g.active = 1
  AND (g.item_id = ? OR g.item_id IS NULL)
  AND (g.user_id = ? OR g.user_id IS NULL)
  AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
LIMIT 1
`

type CheckGrantParams struct {
	ViewerID int32
	Section  string
	Item     sql.NullString
	Action   string
	ItemID   sql.NullInt32
	UserID   sql.NullInt32
}

func (q *Queries) CheckGrant(ctx context.Context, arg CheckGrantParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, checkGrant,
		arg.ViewerID,
		arg.Section,
		arg.Item,
		arg.Action,
		arg.ItemID,
		arg.UserID,
	)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const checkRoleGrant = `-- name: CheckRoleGrant :one
SELECT 1
FROM grants g
JOIN roles r ON g.role_id = r.id
WHERE g.section = 'role'
  AND r.name = ?
  AND g.action = ?
  AND g.active = 1
LIMIT 1
`

type CheckRoleGrantParams struct {
	Name   string
	Action string
}

func (q *Queries) CheckRoleGrant(ctx context.Context, arg CheckRoleGrantParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, checkRoleGrant, arg.Name, arg.Action)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createGrant = `-- name: CreateGrant :execlastid
INSERT INTO grants (
    created_at, user_id, role_id, section, item, rule_type, item_id, item_rule, action, extra, active
) VALUES (NOW(), ?, ?, ?, ?, ?, ?, ?, ?, ?, 1)
`

type CreateGrantParams struct {
	UserID   sql.NullInt32
	RoleID   sql.NullInt32
	Section  string
	Item     sql.NullString
	RuleType string
	ItemID   sql.NullInt32
	ItemRule sql.NullString
	Action   string
	Extra    sql.NullString
}

func (q *Queries) CreateGrant(ctx context.Context, arg CreateGrantParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createGrant,
		arg.UserID,
		arg.RoleID,
		arg.Section,
		arg.Item,
		arg.RuleType,
		arg.ItemID,
		arg.ItemRule,
		arg.Action,
		arg.Extra,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createUserRole = `-- name: CreateUserRole :exec
INSERT INTO user_roles (users_idusers, role_id)
SELECT ?, r.id FROM roles r WHERE r.name = ?
`

type CreateUserRoleParams struct {
	UsersIdusers int32
	Name         string
}

// This query inserts a new permission into the "permissions" table.
// Parameters:
//
//	? - User ID to be associated with the permission (int)
//	? - Role of the permission (string)
func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, createUserRole, arg.UsersIdusers, arg.Name)
	return err
}

const deleteGrant = `-- name: DeleteGrant :exec
DELETE FROM grants WHERE id = ?
`

func (q *Queries) DeleteGrant(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteGrant, id)
	return err
}

const deleteUserRole = `-- name: DeleteUserRole :exec
DELETE FROM user_roles
WHERE iduser_roles = ?
`

// This query deletes a permission from the "permissions" table based on the provided "permid".
// Parameters:
//
//	? - Permission ID to be deleted (int)
func (q *Queries) DeleteUserRole(ctx context.Context, iduserRoles int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserRole, iduserRoles)
	return err
}

const getAdministratorUserRole = `-- name: GetAdministratorUserRole :one
SELECT ur.iduser_roles, ur.users_idusers, ur.role_id
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.users_idusers = ? AND r.is_admin = 1
`

func (q *Queries) GetAdministratorUserRole(ctx context.Context, usersIdusers int32) (*UserRole, error) {
	row := q.db.QueryRowContext(ctx, getAdministratorUserRole, usersIdusers)
	var i UserRole
	err := row.Scan(&i.IduserRoles, &i.UsersIdusers, &i.RoleID)
	return &i, err
}

const getHasLoginRoleForUser = `-- name: GetHasLoginRoleForUser :one
SELECT 1
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.users_idusers = ? AND r.can_login = 1
LIMIT 1
`

// Check whether a user is permitted to log in.
func (q *Queries) GetHasLoginRoleForUser(ctx context.Context, userid int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getHasLoginRoleForUser, userid)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getHasPublicProfileRoleForUser = `-- name: GetHasPublicProfileRoleForUser :one
SELECT 1
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.users_idusers = ? AND r.public_profile_allowed_at IS NOT NULL
LIMIT 1
`

// Check whether a user can enable a public profile.
func (q *Queries) GetHasPublicProfileRoleForUser(ctx context.Context, userid int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getHasPublicProfileRoleForUser, userid)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getHasRoleForUser = `-- name: GetHasRoleForUser :one
SELECT 1
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.users_idusers = ? AND r.name = ?
LIMIT 1
`

type GetHasRoleForUserParams struct {
	Userid int32
	Role   string
}

// Check whether a user possesses the specified role.
func (q *Queries) GetHasRoleForUser(ctx context.Context, arg GetHasRoleForUserParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getHasRoleForUser, arg.Userid, arg.Role)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getPermissionsByUserID = `-- name: GetPermissionsByUserID :many
SELECT ur.iduser_roles, ur.users_idusers, ur.role_id, r.name
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.users_idusers = ?
`

type GetPermissionsByUserIDRow struct {
	IduserRoles  int32
	UsersIdusers int32
	RoleID       int32
	Name         string
}

// Lists the role names granted to a user.
func (q *Queries) GetPermissionsByUserID(ctx context.Context, usersIdusers int32) ([]*GetPermissionsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsByUserID, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPermissionsByUserIDRow
	for rows.Next() {
		var i GetPermissionsByUserIDRow
		if err := rows.Scan(
			&i.IduserRoles,
			&i.UsersIdusers,
			&i.RoleID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsWithUsers = `-- name: GetPermissionsWithUsers :many
SELECT ur.iduser_roles, ur.users_idusers, r.name, u.username,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers ORDER BY ue.id LIMIT 1) AS email
FROM user_roles ur
JOIN users u ON u.idusers = ur.users_idusers
JOIN roles r ON ur.role_id = r.id
WHERE (? = '' OR u.username = ?)
`

type GetPermissionsWithUsersParams struct {
	Username sql.NullString
}

type GetPermissionsWithUsersRow struct {
	IduserRoles  int32
	UsersIdusers int32
	Name         string
	Username     sql.NullString
	Email        string
}

func (q *Queries) GetPermissionsWithUsers(ctx context.Context, arg GetPermissionsWithUsersParams) ([]*GetPermissionsWithUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsWithUsers, arg.Username, arg.Username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPermissionsWithUsersRow
	for rows.Next() {
		var i GetPermissionsWithUsersRow
		if err := rows.Scan(
			&i.IduserRoles,
			&i.UsersIdusers,
			&i.Name,
			&i.Username,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRole = `-- name: GetUserRole :one
SELECT r.name as role
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.users_idusers = ?
LIMIT 1
`

// This query returns the role for a user.
// Result:
//
//	role (string)
func (q *Queries) GetUserRole(ctx context.Context, usersIdusers int32) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserRole, usersIdusers)
	var role string
	err := row.Scan(&role)
	return role, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT ur.iduser_roles, ur.users_idusers, r.name AS role,
       u.username,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers ORDER BY ue.id LIMIT 1) AS email
FROM user_roles ur
JOIN users u ON u.idusers = ur.users_idusers
JOIN roles r ON ur.role_id = r.id
`

type GetUserRolesRow struct {
	IduserRoles  int32
	UsersIdusers int32
	Role         string
	Username     sql.NullString
	Email        string
}

// This query selects permissions information for admin users.
//
//	iduser_roles (int)
//	role (string)
//	username (string)
//	email (string)
func (q *Queries) GetUserRoles(ctx context.Context) ([]*GetUserRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserRolesRow
	for rows.Next() {
		var i GetUserRolesRow
		if err := rows.Scan(
			&i.IduserRoles,
			&i.UsersIdusers,
			&i.Role,
			&i.Username,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEffectiveRoleIDsByUserID = `-- name: ListEffectiveRoleIDsByUserID :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT DISTINCT id FROM role_ids
`

func (q *Queries) ListEffectiveRoleIDsByUserID(ctx context.Context, usersIdusers int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, listEffectiveRoleIDsByUserID, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGrants = `-- name: ListGrants :many
SELECT id, created_at, updated_at, user_id, role_id, section, item, rule_type, item_id, item_rule, action, extra, active FROM grants ORDER BY id
`

func (q *Queries) ListGrants(ctx context.Context) ([]*Grant, error) {
	rows, err := q.db.QueryContext(ctx, listGrants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Grant
	for rows.Next() {
		var i Grant
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.RoleID,
			&i.Section,
			&i.Item,
			&i.RuleType,
			&i.ItemID,
			&i.ItemRule,
			&i.Action,
			&i.Extra,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGrantsByUserID = `-- name: ListGrantsByUserID :many
SELECT id, created_at, updated_at, user_id, role_id, section, item, rule_type, item_id, item_rule, action, extra, active FROM grants WHERE user_id = ? ORDER BY id
`

func (q *Queries) ListGrantsByUserID(ctx context.Context, userID sql.NullInt32) ([]*Grant, error) {
	rows, err := q.db.QueryContext(ctx, listGrantsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Grant
	for rows.Next() {
		var i Grant
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.RoleID,
			&i.Section,
			&i.Item,
			&i.RuleType,
			&i.ItemID,
			&i.ItemRule,
			&i.Action,
			&i.Extra,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithRoles = `-- name: ListUsersWithRoles :many
SELECT u.idusers, u.username, GROUP_CONCAT(r.name ORDER BY r.name) AS roles
FROM users u
LEFT JOIN user_roles ur ON u.idusers = ur.users_idusers
LEFT JOIN roles r ON r.id = ur.role_id
GROUP BY u.idusers
ORDER BY u.idusers
`

type ListUsersWithRolesRow struct {
	Idusers  int32
	Username sql.NullString
	Roles    sql.NullString
}

func (q *Queries) ListUsersWithRoles(ctx context.Context) ([]*ListUsersWithRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersWithRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersWithRolesRow
	for rows.Next() {
		var i ListUsersWithRolesRow
		if err := rows.Scan(&i.Idusers, &i.Username, &i.Roles); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePermission = `-- name: UpdatePermission :exec
UPDATE user_roles SET role_id = (SELECT id FROM roles WHERE name = ?) WHERE iduser_roles = ?
`

type UpdatePermissionParams struct {
	Name        string
	IduserRoles int32
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) error {
	_, err := q.db.ExecContext(ctx, updatePermission, arg.Name, arg.IduserRoles)
	return err
}
