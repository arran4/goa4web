// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-permissions.sql

package db

import (
	"context"
	"database/sql"
)

const countPermissionSections = `-- name: CountPermissionSections :many
SELECT section, COUNT(*) AS SectionCount
FROM permissions
GROUP BY section
`

type CountPermissionSectionsRow struct {
	Section      sql.NullString
	Sectioncount int64
}

func (q *Queries) CountPermissionSections(ctx context.Context) ([]*CountPermissionSectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, countPermissionSections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*CountPermissionSectionsRow
	for rows.Next() {
		var i CountPermissionSectionsRow
		if err := rows.Scan(&i.Section, &i.Sectioncount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteTopicRestrictionsByForumTopicId = `-- name: DeleteTopicRestrictionsByForumTopicId :exec
DELETE FROM topicrestrictions WHERE forumtopic_idforumtopic = ?
`

func (q *Queries) DeleteTopicRestrictionsByForumTopicId(ctx context.Context, forumtopicIdforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, deleteTopicRestrictionsByForumTopicId, forumtopicIdforumtopic)
	return err
}

const getAdministratorPermissionByUserId = `-- name: GetAdministratorPermissionByUserId :one
SELECT idpermissions, users_idusers, section, level
FROM permissions
WHERE users_idusers = ? AND section = 'all' AND level = 'administrator'
`

func (q *Queries) GetAdministratorPermissionByUserId(ctx context.Context, usersIdusers int32) (*Permission, error) {
	row := q.db.QueryRowContext(ctx, getAdministratorPermissionByUserId, usersIdusers)
	var i Permission
	err := row.Scan(
		&i.Idpermissions,
		&i.UsersIdusers,
		&i.Section,
		&i.Level,
	)
	return &i, err
}

const getAllForumTopicRestrictionsWithForumTopicTitle = `-- name: GetAllForumTopicRestrictionsWithForumTopicTitle :many
SELECT t.idforumtopic, r.forumtopic_idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, r.modlevel, r.adminlevel
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
`

type GetAllForumTopicRestrictionsWithForumTopicTitleRow struct {
	Idforumtopic           int32
	ForumtopicIdforumtopic sql.NullInt32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) GetAllForumTopicRestrictionsWithForumTopicTitle(ctx context.Context) ([]*GetAllForumTopicRestrictionsWithForumTopicTitleRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumTopicRestrictionsWithForumTopicTitle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllForumTopicRestrictionsWithForumTopicTitleRow
	for rows.Next() {
		var i GetAllForumTopicRestrictionsWithForumTopicTitleRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.ForumtopicIdforumtopic,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForumTopicRestrictionsByForumTopicId = `-- name: GetForumTopicRestrictionsByForumTopicId :many
SELECT t.idforumtopic, r.forumtopic_idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, r.modlevel, r.adminlevel
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
WHERE idforumtopic = ?
`

type GetForumTopicRestrictionsByForumTopicIdRow struct {
	Idforumtopic           int32
	ForumtopicIdforumtopic sql.NullInt32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) GetForumTopicRestrictionsByForumTopicId(ctx context.Context, idforumtopic int32) ([]*GetForumTopicRestrictionsByForumTopicIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getForumTopicRestrictionsByForumTopicId, idforumtopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetForumTopicRestrictionsByForumTopicIdRow
	for rows.Next() {
		var i GetForumTopicRestrictionsByForumTopicIdRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.ForumtopicIdforumtopic,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsByUserIdAndSectionAndSectionAll = `-- name: GetPermissionsByUserIdAndSectionAndSectionAll :one
SELECT idpermissions, users_idusers, section, level
FROM permissions
WHERE
    users_idusers = ? AND (section = ? OR section = 'all')
`

type GetPermissionsByUserIdAndSectionAndSectionAllParams struct {
	UsersIdusers int32
	Section      sql.NullString
}

func (q *Queries) GetPermissionsByUserIdAndSectionAndSectionAll(ctx context.Context, arg GetPermissionsByUserIdAndSectionAndSectionAllParams) (*Permission, error) {
	row := q.db.QueryRowContext(ctx, getPermissionsByUserIdAndSectionAndSectionAll, arg.UsersIdusers, arg.Section)
	var i Permission
	err := row.Scan(
		&i.Idpermissions,
		&i.UsersIdusers,
		&i.Section,
		&i.Level,
	)
	return &i, err
}

const getPermissionsByUserIdAndSectionBlogs = `-- name: GetPermissionsByUserIdAndSectionBlogs :many
SELECT p.idpermissions, p.users_idusers, p.section, p.level, u.idusers, u.username, u.deleted_at
FROM permissions p, users u
WHERE u.idusers = p.users_idusers AND p.section = "blogs"
ORDER BY p.level
`

type GetPermissionsByUserIdAndSectionBlogsRow struct {
	Idpermissions int32
	UsersIdusers  int32
	Section       sql.NullString
	Level         sql.NullString
	Idusers       int32
	Username      sql.NullString
	DeletedAt     sql.NullTime
}

func (q *Queries) GetPermissionsByUserIdAndSectionBlogs(ctx context.Context) ([]*GetPermissionsByUserIdAndSectionBlogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsByUserIdAndSectionBlogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPermissionsByUserIdAndSectionBlogsRow
	for rows.Next() {
		var i GetPermissionsByUserIdAndSectionBlogsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.UsersIdusers,
			&i.Section,
			&i.Level,
			&i.Idusers,
			&i.Username,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsByUserIdAndSectionNews = `-- name: GetPermissionsByUserIdAndSectionNews :many
SELECT p.idpermissions, p.users_idusers, p.section, p.level, u.idusers, u.username, u.deleted_at
FROM permissions p, users u
WHERE u.idusers = p.users_idusers AND p.section = "news"
ORDER BY p.level
`

type GetPermissionsByUserIdAndSectionNewsRow struct {
	Idpermissions int32
	UsersIdusers  int32
	Section       sql.NullString
	Level         sql.NullString
	Idusers       int32
	Username      sql.NullString
	DeletedAt     sql.NullTime
}

func (q *Queries) GetPermissionsByUserIdAndSectionNews(ctx context.Context) ([]*GetPermissionsByUserIdAndSectionNewsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsByUserIdAndSectionNews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPermissionsByUserIdAndSectionNewsRow
	for rows.Next() {
		var i GetPermissionsByUserIdAndSectionNewsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.UsersIdusers,
			&i.Section,
			&i.Level,
			&i.Idusers,
			&i.Username,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsByUserIdAndSectionWritings = `-- name: GetPermissionsByUserIdAndSectionWritings :many
SELECT p.idpermissions, p.users_idusers, p.section, p.level, u.idusers, u.username, u.deleted_at
FROM permissions p, users u
WHERE u.idusers = p.users_idusers AND (p.section = "writing" OR p.section = "writings")
ORDER BY p.level
`

type GetPermissionsByUserIdAndSectionWritingsRow struct {
	Idpermissions int32
	UsersIdusers  int32
	Section       sql.NullString
	Level         sql.NullString
	Idusers       int32
	Username      sql.NullString
	DeletedAt     sql.NullTime
}

func (q *Queries) GetPermissionsByUserIdAndSectionWritings(ctx context.Context) ([]*GetPermissionsByUserIdAndSectionWritingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionsByUserIdAndSectionWritings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPermissionsByUserIdAndSectionWritingsRow
	for rows.Next() {
		var i GetPermissionsByUserIdAndSectionWritingsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.UsersIdusers,
			&i.Section,
			&i.Level,
			&i.Idusers,
			&i.Username,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPermissions = `-- name: GetUserPermissions :one
SELECT p.idpermissions, p.users_idusers, p.section, p.level
FROM permissions p
WHERE p.users_idusers = ?
`

// This query selects permissions information for admin users.
// Result:
//
//	idpermissions (int)
//	level (int)
//	username (string)
//	email (string)
//	section (string)
func (q *Queries) GetUserPermissions(ctx context.Context, usersIdusers int32) (*Permission, error) {
	row := q.db.QueryRowContext(ctx, getUserPermissions, usersIdusers)
	var i Permission
	err := row.Scan(
		&i.Idpermissions,
		&i.UsersIdusers,
		&i.Section,
		&i.Level,
	)
	return &i, err
}

const getUsersPermissions = `-- name: GetUsersPermissions :many
SELECT p.idpermissions, p.users_idusers, p.section, p.level
FROM permissions p
`

// This query selects permissions information for admin users.
// Result:
//
//	idpermissions (int)
//	level (int)
//	username (string)
//	email (string)
//	section (string)
func (q *Queries) GetUsersPermissions(ctx context.Context) ([]*Permission, error) {
	rows, err := q.db.QueryContext(ctx, getUsersPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.Idpermissions,
			&i.UsersIdusers,
			&i.Section,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersTopicLevelByUserIdAndThreadId = `-- name: GetUsersTopicLevelByUserIdAndThreadId :one
SELECT utl.users_idusers, utl.forumtopic_idforumtopic, utl.level, utl.invitemax, utl.expires_at
FROM userstopiclevel utl
WHERE utl.users_idusers = ? AND utl.forumtopic_idforumtopic = ?
`

type GetUsersTopicLevelByUserIdAndThreadIdParams struct {
	UsersIdusers           int32
	ForumtopicIdforumtopic int32
}

func (q *Queries) GetUsersTopicLevelByUserIdAndThreadId(ctx context.Context, arg GetUsersTopicLevelByUserIdAndThreadIdParams) (*Userstopiclevel, error) {
	row := q.db.QueryRowContext(ctx, getUsersTopicLevelByUserIdAndThreadId, arg.UsersIdusers, arg.ForumtopicIdforumtopic)
	var i Userstopiclevel
	err := row.Scan(
		&i.UsersIdusers,
		&i.ForumtopicIdforumtopic,
		&i.Level,
		&i.Invitemax,
		&i.ExpiresAt,
	)
	return &i, err
}

const permissionUserAllow = `-- name: PermissionUserAllow :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES (?, ?, ?)
`

type PermissionUserAllowParams struct {
	UsersIdusers int32
	Section      sql.NullString
	Level        sql.NullString
}

// This query inserts a new permission into the "permissions" table.
// Parameters:
//
//	? - User ID to be associated with the permission (int)
//	? - Section for which the permission is granted (string)
//	? - Level of the permission (string)
func (q *Queries) PermissionUserAllow(ctx context.Context, arg PermissionUserAllowParams) error {
	_, err := q.db.ExecContext(ctx, permissionUserAllow, arg.UsersIdusers, arg.Section, arg.Level)
	return err
}

const permissionUserDisallow = `-- name: PermissionUserDisallow :exec
DELETE FROM permissions
WHERE idpermissions = ?
`

// This query deletes a permission from the "permissions" table based on the provided "permid".
// Parameters:
//
//	? - Permission ID to be deleted (int)
func (q *Queries) PermissionUserDisallow(ctx context.Context, idpermissions int32) error {
	_, err := q.db.ExecContext(ctx, permissionUserDisallow, idpermissions)
	return err
}

const renamePermissionSection = `-- name: RenamePermissionSection :exec
UPDATE permissions
SET section = ?
WHERE section = ?
`

type RenamePermissionSectionParams struct {
	Section   sql.NullString
	Section_2 sql.NullString
}

func (q *Queries) RenamePermissionSection(ctx context.Context, arg RenamePermissionSectionParams) error {
	_, err := q.db.ExecContext(ctx, renamePermissionSection, arg.Section, arg.Section_2)
	return err
}

const upsertForumTopicRestrictions = `-- name: UpsertForumTopicRestrictions :exec
INSERT INTO topicrestrictions (forumtopic_idforumtopic, viewlevel, replylevel, newthreadlevel, seelevel, invitelevel, readlevel, modlevel, adminlevel)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    viewlevel = VALUES(viewlevel),
    replylevel = VALUES(replylevel),
    newthreadlevel = VALUES(newthreadlevel),
    seelevel = VALUES(seelevel),
    invitelevel = VALUES(invitelevel),
    readlevel = VALUES(readlevel),
    modlevel = VALUES(modlevel),
    adminlevel = VALUES(adminlevel)
`

type UpsertForumTopicRestrictionsParams struct {
	ForumtopicIdforumtopic int32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) UpsertForumTopicRestrictions(ctx context.Context, arg UpsertForumTopicRestrictionsParams) error {
	_, err := q.db.ExecContext(ctx, upsertForumTopicRestrictions,
		arg.ForumtopicIdforumtopic,
		arg.Viewlevel,
		arg.Replylevel,
		arg.Newthreadlevel,
		arg.Seelevel,
		arg.Invitelevel,
		arg.Readlevel,
		arg.Modlevel,
		arg.Adminlevel,
	)
	return err
}
