// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-permissions.sql

package db

import (
	"context"
	"database/sql"
)

const checkGrant = `-- name: CheckGrant :one
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT 1 FROM grants g
WHERE g.section = ?
  AND (g.item = ? OR g.item IS NULL)
  AND g.action = ?
  AND g.active = 1
  AND (g.item_id = ? OR g.item_id IS NULL)
  AND (g.user_id = ? OR g.user_id IS NULL)
  AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
LIMIT 1
`

type CheckGrantParams struct {
	ViewerID int32
	Section  string
	Item     sql.NullString
	Action   string
	ItemID   sql.NullInt32
	UserID   sql.NullInt32
}

func (q *Queries) CheckGrant(ctx context.Context, arg CheckGrantParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, checkGrant,
		arg.ViewerID,
		arg.Section,
		arg.Item,
		arg.Action,
		arg.ItemID,
		arg.UserID,
	)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const checkRoleGrant = `-- name: CheckRoleGrant :one
SELECT 1
FROM grants g
JOIN roles r ON g.role_id = r.id
WHERE g.section = 'role'
  AND r.name = ?
  AND g.action = ?
  AND g.active = 1
LIMIT 1
`

type CheckRoleGrantParams struct {
	Name   string
	Action string
}

func (q *Queries) CheckRoleGrant(ctx context.Context, arg CheckRoleGrantParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, checkRoleGrant, arg.Name, arg.Action)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createGrant = `-- name: CreateGrant :execlastid
INSERT INTO grants (
    created_at, user_id, role_id, section, item, rule_type, item_id, item_rule, action, extra, active
) VALUES (NOW(), ?, ?, ?, ?, ?, ?, ?, ?, ?, 1)
`

type CreateGrantParams struct {
	UserID   sql.NullInt32
	RoleID   sql.NullInt32
	Section  string
	Item     sql.NullString
	RuleType string
	ItemID   sql.NullInt32
	ItemRule sql.NullString
	Action   string
	Extra    sql.NullString
}

func (q *Queries) CreateGrant(ctx context.Context, arg CreateGrantParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createGrant,
		arg.UserID,
		arg.RoleID,
		arg.Section,
		arg.Item,
		arg.RuleType,
		arg.ItemID,
		arg.ItemRule,
		arg.Action,
		arg.Extra,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createUserRole = `-- name: CreateUserRole :exec
INSERT INTO user_roles (users_idusers, role_id)
SELECT ?, r.id FROM roles r WHERE r.name = ?
`

type CreateUserRoleParams struct {
	UsersIdusers int32
	Name         string
}

// This query inserts a new permission into the "permissions" table.
// Parameters:
//
//	? - User ID to be associated with the permission (int)
//	? - Role of the permission (string)
func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, createUserRole, arg.UsersIdusers, arg.Name)
	return err
}

const deleteGrant = `-- name: DeleteGrant :exec
DELETE FROM grants WHERE id = ?
`

func (q *Queries) DeleteGrant(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteGrant, id)
	return err
}

const deleteTopicRestrictionsByForumTopicId = `-- name: DeleteTopicRestrictionsByForumTopicId :exec
DELETE FROM topic_permissions WHERE forumtopic_idforumtopic = ?
`

func (q *Queries) DeleteTopicRestrictionsByForumTopicId(ctx context.Context, forumtopicIdforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, deleteTopicRestrictionsByForumTopicId, forumtopicIdforumtopic)
	return err
}

const deleteUserRole = `-- name: DeleteUserRole :exec
DELETE FROM user_roles
WHERE iduser_roles = ?
`

// This query deletes a permission from the "permissions" table based on the provided "permid".
// Parameters:
//
//	? - Permission ID to be deleted (int)
func (q *Queries) DeleteUserRole(ctx context.Context, iduserRoles int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserRole, iduserRoles)
	return err
}

const getAdministratorUserRole = `-- name: GetAdministratorUserRole :one
SELECT ur.iduser_roles, ur.users_idusers, ur.role_id
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.users_idusers = ? AND r.name = 'administrator'
`

func (q *Queries) GetAdministratorUserRole(ctx context.Context, usersIdusers int32) (*UserRole, error) {
	row := q.db.QueryRowContext(ctx, getAdministratorUserRole, usersIdusers)
	var i UserRole
	err := row.Scan(&i.IduserRoles, &i.UsersIdusers, &i.RoleID)
	return &i, err
}

const getAllForumTopicRestrictionsWithForumTopicTitle = `-- name: GetAllForumTopicRestrictionsWithForumTopicTitle :many
SELECT t.idforumtopic, r.forumtopic_idforumtopic, r.view_role_id, r.reply_role_id, r.newthread_role_id, r.see_role_id, r.invite_role_id, r.read_role_id, r.mod_role_id, r.admin_role_id
FROM forumtopic t
LEFT JOIN topic_permissions r ON t.idforumtopic = r.forumtopic_idforumtopic
`

type GetAllForumTopicRestrictionsWithForumTopicTitleRow struct {
	Idforumtopic           int32
	ForumtopicIdforumtopic sql.NullInt32
	ViewRoleID             sql.NullInt32
	ReplyRoleID            sql.NullInt32
	NewthreadRoleID        sql.NullInt32
	SeeRoleID              sql.NullInt32
	InviteRoleID           sql.NullInt32
	ReadRoleID             sql.NullInt32
	ModRoleID              sql.NullInt32
	AdminRoleID            sql.NullInt32
}

func (q *Queries) GetAllForumTopicRestrictionsWithForumTopicTitle(ctx context.Context) ([]*GetAllForumTopicRestrictionsWithForumTopicTitleRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllForumTopicRestrictionsWithForumTopicTitle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllForumTopicRestrictionsWithForumTopicTitleRow
	for rows.Next() {
		var i GetAllForumTopicRestrictionsWithForumTopicTitleRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.ForumtopicIdforumtopic,
			&i.ViewRoleID,
			&i.ReplyRoleID,
			&i.NewthreadRoleID,
			&i.SeeRoleID,
			&i.InviteRoleID,
			&i.ReadRoleID,
			&i.ModRoleID,
			&i.AdminRoleID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForumTopicRestrictionsByForumTopicId = `-- name: GetForumTopicRestrictionsByForumTopicId :many
SELECT t.idforumtopic, r.forumtopic_idforumtopic, r.view_role_id, r.reply_role_id, r.newthread_role_id, r.see_role_id, r.invite_role_id, r.read_role_id, r.mod_role_id, r.admin_role_id
FROM forumtopic t
LEFT JOIN topic_permissions r ON t.idforumtopic = r.forumtopic_idforumtopic
WHERE idforumtopic = ?
`

type GetForumTopicRestrictionsByForumTopicIdRow struct {
	Idforumtopic           int32
	ForumtopicIdforumtopic sql.NullInt32
	ViewRoleID             sql.NullInt32
	ReplyRoleID            sql.NullInt32
	NewthreadRoleID        sql.NullInt32
	SeeRoleID              sql.NullInt32
	InviteRoleID           sql.NullInt32
	ReadRoleID             sql.NullInt32
	ModRoleID              sql.NullInt32
	AdminRoleID            sql.NullInt32
}

func (q *Queries) GetForumTopicRestrictionsByForumTopicId(ctx context.Context, idforumtopic int32) ([]*GetForumTopicRestrictionsByForumTopicIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getForumTopicRestrictionsByForumTopicId, idforumtopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetForumTopicRestrictionsByForumTopicIdRow
	for rows.Next() {
		var i GetForumTopicRestrictionsByForumTopicIdRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.ForumtopicIdforumtopic,
			&i.ViewRoleID,
			&i.ReplyRoleID,
			&i.NewthreadRoleID,
			&i.SeeRoleID,
			&i.InviteRoleID,
			&i.ReadRoleID,
			&i.ModRoleID,
			&i.AdminRoleID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRole = `-- name: GetUserRole :one
SELECT r.name as role
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.users_idusers = ?
LIMIT 1
`

// This query returns the role for a user.
// Result:
//
//	role (string)
func (q *Queries) GetUserRole(ctx context.Context, usersIdusers int32) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserRole, usersIdusers)
	var role string
	err := row.Scan(&role)
	return role, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT ur.iduser_roles, ur.users_idusers, r.name AS role
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
`

type GetUserRolesRow struct {
	IduserRoles  int32
	UsersIdusers int32
	Role         string
}

// This query selects permissions information for admin users.
//
//	iduser_roles (int)
//	role (string)
//	username (string)
//	email (string)
func (q *Queries) GetUserRoles(ctx context.Context) ([]*GetUserRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserRolesRow
	for rows.Next() {
		var i GetUserRolesRow
		if err := rows.Scan(&i.IduserRoles, &i.UsersIdusers, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersTopicLevelByUserIdAndThreadId = `-- name: GetUsersTopicLevelByUserIdAndThreadId :one
SELECT utl.users_idusers, utl.forumtopic_idforumtopic, utl.role_id, utl.invitemax, utl.expires_at
FROM user_topic_permissions utl
WHERE utl.users_idusers = ? AND utl.forumtopic_idforumtopic = ?
`

type GetUsersTopicLevelByUserIdAndThreadIdParams struct {
	UsersIdusers           int32
	ForumtopicIdforumtopic int32
}

func (q *Queries) GetUsersTopicLevelByUserIdAndThreadId(ctx context.Context, arg GetUsersTopicLevelByUserIdAndThreadIdParams) (*UserTopicPermission, error) {
	row := q.db.QueryRowContext(ctx, getUsersTopicLevelByUserIdAndThreadId, arg.UsersIdusers, arg.ForumtopicIdforumtopic)
	var i UserTopicPermission
	err := row.Scan(
		&i.UsersIdusers,
		&i.ForumtopicIdforumtopic,
		&i.RoleID,
		&i.Invitemax,
		&i.ExpiresAt,
	)
	return &i, err
}

const listEffectiveRoleIDsByUserID = `-- name: ListEffectiveRoleIDsByUserID :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT DISTINCT id FROM role_ids
`

func (q *Queries) ListEffectiveRoleIDsByUserID(ctx context.Context, usersIdusers int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, listEffectiveRoleIDsByUserID, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGrants = `-- name: ListGrants :many
SELECT id, created_at, updated_at, user_id, role_id, section, item, rule_type, item_id, item_rule, action, extra, active FROM grants ORDER BY id
`

func (q *Queries) ListGrants(ctx context.Context) ([]*Grant, error) {
	rows, err := q.db.QueryContext(ctx, listGrants)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Grant
	for rows.Next() {
		var i Grant
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.RoleID,
			&i.Section,
			&i.Item,
			&i.RuleType,
			&i.ItemID,
			&i.ItemRule,
			&i.Action,
			&i.Extra,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertForumTopicRestrictions = `-- name: UpsertForumTopicRestrictions :exec
INSERT INTO topic_permissions (forumtopic_idforumtopic, view_role_id, reply_role_id, newthread_role_id, see_role_id, invite_role_id, read_role_id, mod_role_id, admin_role_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    view_role_id = VALUES(view_role_id),
    reply_role_id = VALUES(reply_role_id),
    newthread_role_id = VALUES(newthread_role_id),
    see_role_id = VALUES(see_role_id),
    invite_role_id = VALUES(invite_role_id),
    read_role_id = VALUES(read_role_id),
    mod_role_id = VALUES(mod_role_id),
    admin_role_id = VALUES(admin_role_id)
`

type UpsertForumTopicRestrictionsParams struct {
	ForumtopicIdforumtopic int32
	ViewRoleID             sql.NullInt32
	ReplyRoleID            sql.NullInt32
	NewthreadRoleID        sql.NullInt32
	SeeRoleID              sql.NullInt32
	InviteRoleID           sql.NullInt32
	ReadRoleID             sql.NullInt32
	ModRoleID              sql.NullInt32
	AdminRoleID            sql.NullInt32
}

func (q *Queries) UpsertForumTopicRestrictions(ctx context.Context, arg UpsertForumTopicRestrictionsParams) error {
	_, err := q.db.ExecContext(ctx, upsertForumTopicRestrictions,
		arg.ForumtopicIdforumtopic,
		arg.ViewRoleID,
		arg.ReplyRoleID,
		arg.NewthreadRoleID,
		arg.SeeRoleID,
		arg.InviteRoleID,
		arg.ReadRoleID,
		arg.ModRoleID,
		arg.AdminRoleID,
	)
	return err
}
