// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries-private_forum.sql

package db

import (
	"context"
	"database/sql"
)

const adminGetSubsequentCommentID = `-- name: AdminGetSubsequentCommentID :one
SELECT idcomments
FROM comments
WHERE forumthread_id = ? AND idcomments > ?
ORDER BY idcomments ASC
LIMIT 1
`

type AdminGetSubsequentCommentIDParams struct {
	ForumthreadID int32
	Idcomments    int32
}

func (q *Queries) AdminGetSubsequentCommentID(ctx context.Context, arg AdminGetSubsequentCommentIDParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, adminGetSubsequentCommentID, arg.ForumthreadID, arg.Idcomments)
	var idcomments int32
	err := row.Scan(&idcomments)
	return idcomments, err
}

const adminListAllPrivateForumThreads = `-- name: AdminListAllPrivateForumThreads :many
SELECT
    t.idforumthread,
    t.forumtopic_idforumtopic as idforumtopic,
    CAST(COALESCE(SUBSTRING(fp.text, 1, 100), 'unknown') AS CHAR) AS title,
    fp.written as created_at,
    fp.users_idusers as created_by,
    t.lastposter as last_post_by,
    t.lastaddition as last_post_at,
    t.comments as post_count,
    COALESCE(ft.title, '') as topic_title,
    CAST(COUNT(c.idcomments) AS SIGNED) AS total_comments,
    CAST(COALESCE(SUM(CASE WHEN c.text IS NOT NULL THEN 1 ELSE 0 END), 0) AS SIGNED) AS valid_comments,
    CAST(COALESCE(SUM(CASE WHEN c.text IS NULL THEN 1 ELSE 0 END), 0) AS SIGNED) AS invalid_comments
FROM
    forumthread t
JOIN
    forumtopic ft ON t.forumtopic_idforumtopic = ft.idforumtopic
LEFT JOIN
    comments fp ON t.firstpost = fp.idcomments
LEFT JOIN
    comments c ON c.forumthread_id = t.idforumthread
WHERE
    ft.handler = 'private'
GROUP BY
    t.idforumthread,
    t.forumtopic_idforumtopic,
    fp.text,
    fp.written,
    fp.users_idusers,
    t.lastposter,
    t.lastaddition,
    t.comments,
    ft.title
`

type AdminListAllPrivateForumThreadsRow struct {
	Idforumthread   int32
	Idforumtopic    int32
	Title           interface{}
	CreatedAt       sql.NullTime
	CreatedBy       sql.NullInt32
	LastPostBy      int32
	LastPostAt      sql.NullTime
	PostCount       sql.NullInt32
	TopicTitle      string
	TotalComments   int64
	ValidComments   int64
	InvalidComments int64
}

func (q *Queries) AdminListAllPrivateForumThreads(ctx context.Context) ([]*AdminListAllPrivateForumThreadsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListAllPrivateForumThreads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListAllPrivateForumThreadsRow
	for rows.Next() {
		var i AdminListAllPrivateForumThreadsRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Idforumtopic,
			&i.Title,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.LastPostBy,
			&i.LastPostAt,
			&i.PostCount,
			&i.TopicTitle,
			&i.TotalComments,
			&i.ValidComments,
			&i.InvalidComments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListAllPrivateTopics = `-- name: AdminListAllPrivateTopics :many
SELECT
    idforumtopic,
    COALESCE(title, '') AS title,
    lastposter AS last_post_by,
    lastaddition AS last_post_at,
    comments AS post_count
FROM
    forumtopic
WHERE
    handler = 'private'
`

type AdminListAllPrivateTopicsRow struct {
	Idforumtopic int32
	Title        string
	LastPostBy   int32
	LastPostAt   sql.NullTime
	PostCount    sql.NullInt32
}

func (q *Queries) AdminListAllPrivateTopics(ctx context.Context) ([]*AdminListAllPrivateTopicsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListAllPrivateTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListAllPrivateTopicsRow
	for rows.Next() {
		var i AdminListAllPrivateTopicsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Title,
			&i.LastPostBy,
			&i.LastPostAt,
			&i.PostCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListGrantsByThreadID = `-- name: AdminListGrantsByThreadID :many
SELECT
    g.id,
    g.section,
    g.action,
    r.name AS role_name,
    u.username
FROM
    grants g
LEFT JOIN
    roles r ON g.role_id = r.id
LEFT JOIN
    users u ON g.user_id = u.idusers
WHERE
    g.section = 'privateforum_thread' AND g.item_id = ?
`

type AdminListGrantsByThreadIDRow struct {
	ID       int32
	Section  string
	Action   string
	RoleName sql.NullString
	Username sql.NullString
}

func (q *Queries) AdminListGrantsByThreadID(ctx context.Context, itemID sql.NullInt32) ([]*AdminListGrantsByThreadIDRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListGrantsByThreadID, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListGrantsByThreadIDRow
	for rows.Next() {
		var i AdminListGrantsByThreadIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Section,
			&i.Action,
			&i.RoleName,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListGrantsByTopicID = `-- name: AdminListGrantsByTopicID :many
SELECT
    g.id,
    g.section,
    g.action,
    r.name AS role_name,
    u.username
FROM
    grants g
LEFT JOIN
    roles r ON g.role_id = r.id
LEFT JOIN
    users u ON g.user_id = u.idusers
WHERE
    g.section = 'privateforum' AND g.item_id = ?
`

type AdminListGrantsByTopicIDRow struct {
	ID       int32
	Section  string
	Action   string
	RoleName sql.NullString
	Username sql.NullString
}

func (q *Queries) AdminListGrantsByTopicID(ctx context.Context, itemID sql.NullInt32) ([]*AdminListGrantsByTopicIDRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListGrantsByTopicID, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListGrantsByTopicIDRow
	for rows.Next() {
		var i AdminListGrantsByTopicIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Section,
			&i.Action,
			&i.RoleName,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListPrivateForumComments = `-- name: AdminListPrivateForumComments :many
SELECT c.idcomments, c.written, c.text, c.deleted_at,
       th.idforumthread, t.idforumtopic, t.title AS forumtopic_title, t.handler AS topic_handler,
       u.idusers, u.username AS posterusername
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_id = th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic = t.idforumtopic
LEFT JOIN users u ON u.idusers = c.users_idusers
WHERE t.handler = 'private'
ORDER BY c.written DESC
LIMIT ? OFFSET ?
`

type AdminListPrivateForumCommentsParams struct {
	Limit  int32
	Offset int32
}

type AdminListPrivateForumCommentsRow struct {
	Idcomments      int32
	Written         sql.NullTime
	Text            sql.NullString
	DeletedAt       sql.NullTime
	Idforumthread   sql.NullInt32
	Idforumtopic    sql.NullInt32
	ForumtopicTitle sql.NullString
	TopicHandler    sql.NullString
	Idusers         sql.NullInt32
	Posterusername  sql.NullString
}

func (q *Queries) AdminListPrivateForumComments(ctx context.Context, arg AdminListPrivateForumCommentsParams) ([]*AdminListPrivateForumCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListPrivateForumComments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListPrivateForumCommentsRow
	for rows.Next() {
		var i AdminListPrivateForumCommentsRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.Written,
			&i.Text,
			&i.DeletedAt,
			&i.Idforumthread,
			&i.Idforumtopic,
			&i.ForumtopicTitle,
			&i.TopicHandler,
			&i.Idusers,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListPrivateForumInvalidCommentsByThread = `-- name: AdminListPrivateForumInvalidCommentsByThread :many
SELECT
    idcomments
FROM
    comments
WHERE
    forumthread_id = ?
    AND text IS NULL
`

func (q *Queries) AdminListPrivateForumInvalidCommentsByThread(ctx context.Context, forumthreadID int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, adminListPrivateForumInvalidCommentsByThread, forumthreadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var idcomments int32
		if err := rows.Scan(&idcomments); err != nil {
			return nil, err
		}
		items = append(items, idcomments)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListPrivateForumThreads = `-- name: AdminListPrivateForumThreads :many
SELECT
    t.idforumthread,
    t.forumtopic_idforumtopic as idforumtopic,
    SUBSTRING(c.text, 1, 100) AS title,
    c.written as created_at,
    c.users_idusers as created_by,
    t.lastposter as last_post_by,
    t.lastaddition as last_post_at,
    t.comments as post_count,
    ft.title as topic_title,
    ft.handler as topic_handler
FROM
    forumthread t
JOIN
    forumtopic ft ON t.forumtopic_idforumtopic = ft.idforumtopic
JOIN
    comments c ON t.firstpost = c.idcomments
WHERE
    ft.handler = 'private'
ORDER BY t.idforumthread
LIMIT ? OFFSET ?
`

type AdminListPrivateForumThreadsParams struct {
	Limit  int32
	Offset int32
}

type AdminListPrivateForumThreadsRow struct {
	Idforumthread int32
	Idforumtopic  int32
	Title         string
	CreatedAt     sql.NullTime
	CreatedBy     int32
	LastPostBy    int32
	LastPostAt    sql.NullTime
	PostCount     sql.NullInt32
	TopicTitle    sql.NullString
	TopicHandler  string
}

func (q *Queries) AdminListPrivateForumThreads(ctx context.Context, arg AdminListPrivateForumThreadsParams) ([]*AdminListPrivateForumThreadsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListPrivateForumThreads, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListPrivateForumThreadsRow
	for rows.Next() {
		var i AdminListPrivateForumThreadsRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Idforumtopic,
			&i.Title,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.LastPostBy,
			&i.LastPostAt,
			&i.PostCount,
			&i.TopicTitle,
			&i.TopicHandler,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListPrivateForumTopics = `-- name: AdminListPrivateForumTopics :many
SELECT
    idforumtopic,
    COALESCE(title, '') AS title,
    handler,
    threads,
    comments,
    lastaddition
FROM
    forumtopic
WHERE
    handler = 'private'
ORDER BY idforumtopic
LIMIT ? OFFSET ?
`

type AdminListPrivateForumTopicsParams struct {
	Limit  int32
	Offset int32
}

type AdminListPrivateForumTopicsRow struct {
	Idforumtopic int32
	Title        string
	Handler      string
	Threads      sql.NullInt32
	Comments     sql.NullInt32
	Lastaddition sql.NullTime
}

func (q *Queries) AdminListPrivateForumTopics(ctx context.Context, arg AdminListPrivateForumTopicsParams) ([]*AdminListPrivateForumTopicsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListPrivateForumTopics, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListPrivateForumTopicsRow
	for rows.Next() {
		var i AdminListPrivateForumTopicsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Title,
			&i.Handler,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
