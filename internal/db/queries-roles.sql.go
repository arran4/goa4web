// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries-roles.sql

package db

import (
	"context"
	"database/sql"
)

const adminGetRoleByID = `-- name: AdminGetRoleByID :one
SELECT id, name, can_login, is_admin, private_labels, public_profile_allowed_at FROM roles WHERE id = ?
`

// admin task
func (q *Queries) AdminGetRoleByID(ctx context.Context, id int32) (*Role, error) {
	row := q.db.QueryRowContext(ctx, adminGetRoleByID, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CanLogin,
		&i.IsAdmin,
		&i.PrivateLabels,
		&i.PublicProfileAllowedAt,
	)
	return &i, err
}

const adminListGrantsByRoleID = `-- name: AdminListGrantsByRoleID :many
SELECT id, created_at, updated_at, user_id, role_id, section, item, rule_type, item_id, item_rule, action, extra, active FROM grants WHERE role_id = ? ORDER BY id
`

// admin task
func (q *Queries) AdminListGrantsByRoleID(ctx context.Context, roleID sql.NullInt32) ([]*Grant, error) {
	rows, err := q.db.QueryContext(ctx, adminListGrantsByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Grant
	for rows.Next() {
		var i Grant
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.RoleID,
			&i.Section,
			&i.Item,
			&i.RuleType,
			&i.ItemID,
			&i.ItemRule,
			&i.Action,
			&i.Extra,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListRoles = `-- name: AdminListRoles :many
SELECT id, name, can_login, is_admin, private_labels, public_profile_allowed_at FROM roles ORDER BY id
`

// admin task
func (q *Queries) AdminListRoles(ctx context.Context) ([]*Role, error) {
	rows, err := q.db.QueryContext(ctx, adminListRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CanLogin,
			&i.IsAdmin,
			&i.PrivateLabels,
			&i.PublicProfileAllowedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListRolesWithUsers = `-- name: AdminListRolesWithUsers :many
SELECT r.id, r.name, GROUP_CONCAT(u.username ORDER BY u.username) AS users
FROM roles r
LEFT JOIN user_roles ur ON ur.role_id = r.id
LEFT JOIN users u ON u.idusers = ur.users_idusers
GROUP BY r.id
ORDER BY r.id
`

type AdminListRolesWithUsersRow struct {
	ID    int32
	Name  string
	Users sql.NullString
}

// admin task
func (q *Queries) AdminListRolesWithUsers(ctx context.Context) ([]*AdminListRolesWithUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListRolesWithUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListRolesWithUsersRow
	for rows.Next() {
		var i AdminListRolesWithUsersRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Users); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListUsersByRoleID = `-- name: AdminListUsersByRoleID :many
SELECT u.idusers, u.username
FROM users u
JOIN user_roles ur ON ur.users_idusers = u.idusers
WHERE ur.role_id = ?
ORDER BY u.username
`

type AdminListUsersByRoleIDRow struct {
	Idusers  int32
	Username sql.NullString
}

// admin task
func (q *Queries) AdminListUsersByRoleID(ctx context.Context, roleID int32) ([]*AdminListUsersByRoleIDRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListUsersByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListUsersByRoleIDRow
	for rows.Next() {
		var i AdminListUsersByRoleIDRow
		if err := rows.Scan(&i.Idusers, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUpdateRole = `-- name: AdminUpdateRole :exec
UPDATE roles SET name = ?, can_login = ?, is_admin = ?, private_labels = ?, public_profile_allowed_at = ? WHERE id = ?
`

type AdminUpdateRoleParams struct {
	Name                   string
	CanLogin               bool
	IsAdmin                bool
	PrivateLabels          bool
	PublicProfileAllowedAt sql.NullTime
	ID                     int32
}

// admin task
func (q *Queries) AdminUpdateRole(ctx context.Context, arg AdminUpdateRoleParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateRole,
		arg.Name,
		arg.CanLogin,
		arg.IsAdmin,
		arg.PrivateLabels,
		arg.PublicProfileAllowedAt,
		arg.ID,
	)
	return err
}

const adminUpdateRolePublicProfileAllowed = `-- name: AdminUpdateRolePublicProfileAllowed :exec
UPDATE roles SET public_profile_allowed_at = ? WHERE id = ?
`

type AdminUpdateRolePublicProfileAllowedParams struct {
	PublicProfileAllowedAt sql.NullTime
	ID                     int32
}

// admin task
func (q *Queries) AdminUpdateRolePublicProfileAllowed(ctx context.Context, arg AdminUpdateRolePublicProfileAllowedParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateRolePublicProfileAllowed, arg.PublicProfileAllowedAt, arg.ID)
	return err
}

const createGrant = `-- name: CreateGrant :exec
INSERT INTO grants (role_id, section, item, rule_type, item_id, item_rule, action, extra, active)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateGrantParams struct {
	RoleID   sql.NullInt32
	Section  string
	Item     sql.NullString
	RuleType string
	ItemID   sql.NullInt32
	ItemRule sql.NullString
	Action   string
	Extra    sql.NullString
	Active   bool
}

func (q *Queries) CreateGrant(ctx context.Context, arg CreateGrantParams) error {
	_, err := q.db.ExecContext(ctx, createGrant,
		arg.RoleID,
		arg.Section,
		arg.Item,
		arg.RuleType,
		arg.ItemID,
		arg.ItemRule,
		arg.Action,
		arg.Extra,
		arg.Active,
	)
	return err
}

const deleteGrantByProperties = `-- name: DeleteGrantByProperties :exec
DELETE FROM grants
WHERE role_id = ?
  AND section = ?
  AND item = ?
  AND action = ?
`

type DeleteGrantByPropertiesParams struct {
	RoleID  sql.NullInt32
	Section string
	Item    sql.NullString
	Action  string
}

func (q *Queries) DeleteGrantByProperties(ctx context.Context, arg DeleteGrantByPropertiesParams) error {
	_, err := q.db.ExecContext(ctx, deleteGrantByProperties,
		arg.RoleID,
		arg.Section,
		arg.Item,
		arg.Action,
	)
	return err
}

const deleteGrantsByRoleID = `-- name: DeleteGrantsByRoleID :exec
DELETE FROM grants WHERE role_id = ?
`

func (q *Queries) DeleteGrantsByRoleID(ctx context.Context, roleID sql.NullInt32) error {
	_, err := q.db.ExecContext(ctx, deleteGrantsByRoleID, roleID)
	return err
}

const getGrantsByRoleID = `-- name: GetGrantsByRoleID :many
SELECT id, created_at, updated_at, user_id, role_id, section, item, rule_type, item_id, item_rule, action, extra, active FROM grants WHERE role_id = ?
`

func (q *Queries) GetGrantsByRoleID(ctx context.Context, roleID sql.NullInt32) ([]*Grant, error) {
	rows, err := q.db.QueryContext(ctx, getGrantsByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Grant
	for rows.Next() {
		var i Grant
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.RoleID,
			&i.Section,
			&i.Item,
			&i.RuleType,
			&i.ItemID,
			&i.ItemRule,
			&i.Action,
			&i.Extra,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT id, name, can_login, is_admin, private_labels, public_profile_allowed_at FROM roles WHERE name = ?
`

func (q *Queries) GetRoleByName(ctx context.Context, name string) (*Role, error) {
	row := q.db.QueryRowContext(ctx, getRoleByName, name)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CanLogin,
		&i.IsAdmin,
		&i.PrivateLabels,
		&i.PublicProfileAllowedAt,
	)
	return &i, err
}
