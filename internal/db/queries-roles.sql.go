// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-roles.sql

package db

import (
	"context"
	"database/sql"
)

const adminGetRoleByID = `-- name: AdminGetRoleByID :one
SELECT id, name, can_login, is_admin, public_profile_allowed_at FROM roles WHERE id = ?
`

// admin task
func (q *Queries) AdminGetRoleByID(ctx context.Context, id int32) (*Role, error) {
	row := q.db.QueryRowContext(ctx, adminGetRoleByID, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CanLogin,
		&i.IsAdmin,
		&i.PublicProfileAllowedAt,
	)
	return &i, err
}

const adminListGrantsByRoleID = `-- name: AdminListGrantsByRoleID :many
SELECT id, created_at, updated_at, user_id, role_id, section, item, rule_type, item_id, item_rule, action, extra, active FROM grants WHERE role_id = ? ORDER BY id
`

// admin task
func (q *Queries) AdminListGrantsByRoleID(ctx context.Context, roleID sql.NullInt32) ([]*Grant, error) {
	rows, err := q.db.QueryContext(ctx, adminListGrantsByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Grant
	for rows.Next() {
		var i Grant
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.RoleID,
			&i.Section,
			&i.Item,
			&i.RuleType,
			&i.ItemID,
			&i.ItemRule,
			&i.Action,
			&i.Extra,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListRoles = `-- name: AdminListRoles :many
SELECT id, name, can_login, is_admin, public_profile_allowed_at FROM roles ORDER BY id
`

// admin task
func (q *Queries) AdminListRoles(ctx context.Context) ([]*Role, error) {
	rows, err := q.db.QueryContext(ctx, adminListRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CanLogin,
			&i.IsAdmin,
			&i.PublicProfileAllowedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListRolesWithUsers = `-- name: AdminListRolesWithUsers :many
SELECT r.id, r.name, GROUP_CONCAT(u.username ORDER BY u.username) AS users
FROM roles r
LEFT JOIN user_roles ur ON ur.role_id = r.id
LEFT JOIN users u ON u.idusers = ur.users_idusers
GROUP BY r.id
ORDER BY r.id
`

type AdminListRolesWithUsersRow struct {
	ID    int32
	Name  string
	Users sql.NullString
}

// admin task
func (q *Queries) AdminListRolesWithUsers(ctx context.Context) ([]*AdminListRolesWithUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListRolesWithUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListRolesWithUsersRow
	for rows.Next() {
		var i AdminListRolesWithUsersRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Users); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListUsersByRoleID = `-- name: AdminListUsersByRoleID :many
SELECT u.idusers, u.username, (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers ORDER BY ue.id LIMIT 1) AS email
FROM users u
JOIN user_roles ur ON ur.users_idusers = u.idusers
WHERE ur.role_id = ?
ORDER BY u.username
`

type AdminListUsersByRoleIDRow struct {
	Idusers  int32
	Username sql.NullString
	Email    string
}

// admin task
func (q *Queries) AdminListUsersByRoleID(ctx context.Context, roleID int32) ([]*AdminListUsersByRoleIDRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListUsersByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListUsersByRoleIDRow
	for rows.Next() {
		var i AdminListUsersByRoleIDRow
		if err := rows.Scan(&i.Idusers, &i.Username, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUpdateRole = `-- name: AdminUpdateRole :exec
UPDATE roles SET name = ?, can_login = ?, is_admin = ? WHERE id = ?
`

type AdminUpdateRoleParams struct {
	Name     string
	CanLogin bool
	IsAdmin  bool
	ID       int32
}

// admin task
func (q *Queries) AdminUpdateRole(ctx context.Context, arg AdminUpdateRoleParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateRole,
		arg.Name,
		arg.CanLogin,
		arg.IsAdmin,
		arg.ID,
	)
	return err
}

const adminUpdateRolePublicProfileAllowed = `-- name: AdminUpdateRolePublicProfileAllowed :exec
UPDATE roles SET public_profile_allowed_at = ? WHERE id = ?
`

type AdminUpdateRolePublicProfileAllowedParams struct {
	PublicProfileAllowedAt sql.NullTime
	ID                     int32
}

// admin task
func (q *Queries) AdminUpdateRolePublicProfileAllowed(ctx context.Context, arg AdminUpdateRolePublicProfileAllowedParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateRolePublicProfileAllowed, arg.PublicProfileAllowedAt, arg.ID)
	return err
}
