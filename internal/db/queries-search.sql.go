// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries-search.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const adminCompleteWordList = `-- name: AdminCompleteWordList :many
SELECT word
FROM searchwordlist
`

// This query selects all words from the "searchwordlist" table and prints them.
func (q *Queries) AdminCompleteWordList(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, adminCompleteWordList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var word sql.NullString
		if err := rows.Scan(&word); err != nil {
			return nil, err
		}
		items = append(items, word)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminCountWordList = `-- name: AdminCountWordList :one
SELECT COUNT(*)
FROM searchwordlist
`

func (q *Queries) AdminCountWordList(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, adminCountWordList)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminCountWordListByPrefix = `-- name: AdminCountWordListByPrefix :one
SELECT COUNT(*)
FROM searchwordlist
WHERE word LIKE CONCAT(?, '%')
`

func (q *Queries) AdminCountWordListByPrefix(ctx context.Context, prefix interface{}) (int64, error) {
	row := q.db.QueryRowContext(ctx, adminCountWordListByPrefix, prefix)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminWordListWithCounts = `-- name: AdminWordListWithCounts :many
SELECT swl.word,
       (SELECT IFNULL(SUM(cs.word_count),0) FROM comments_search cs WHERE cs.searchwordlist_idsearchwordlist=swl.idsearchwordlist)
       + (SELECT IFNULL(SUM(ns.word_count),0) FROM site_news_search ns WHERE ns.searchwordlist_idsearchwordlist=swl.idsearchwordlist)
       + (SELECT IFNULL(SUM(bs.word_count),0) FROM blogs_search bs WHERE bs.searchwordlist_idsearchwordlist=swl.idsearchwordlist)
       + (SELECT IFNULL(SUM(ls.word_count),0) FROM linker_search ls WHERE ls.searchwordlist_idsearchwordlist=swl.idsearchwordlist)
       + (SELECT IFNULL(SUM(ws.word_count),0) FROM writing_search ws WHERE ws.searchwordlist_idsearchwordlist=swl.idsearchwordlist)
       + (SELECT IFNULL(SUM(ips.word_count),0) FROM imagepost_search ips WHERE ips.searchwordlist_idsearchwordlist=swl.idsearchwordlist) AS count
FROM searchwordlist swl
ORDER BY swl.word
LIMIT ? OFFSET ?
`

type AdminWordListWithCountsParams struct {
	Limit  int32
	Offset int32
}

type AdminWordListWithCountsRow struct {
	Word  sql.NullString
	Count int32
}

// Show each search word with total usage counts across all search tables.
func (q *Queries) AdminWordListWithCounts(ctx context.Context, arg AdminWordListWithCountsParams) ([]*AdminWordListWithCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminWordListWithCounts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminWordListWithCountsRow
	for rows.Next() {
		var i AdminWordListWithCountsRow
		if err := rows.Scan(&i.Word, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminWordListWithCountsByPrefix = `-- name: AdminWordListWithCountsByPrefix :many
SELECT swl.word,
       (SELECT IFNULL(SUM(cs.word_count),0) FROM comments_search cs WHERE cs.searchwordlist_idsearchwordlist=swl.idsearchwordlist)
       + (SELECT IFNULL(SUM(ns.word_count),0) FROM site_news_search ns WHERE ns.searchwordlist_idsearchwordlist=swl.idsearchwordlist)
       + (SELECT IFNULL(SUM(bs.word_count),0) FROM blogs_search bs WHERE bs.searchwordlist_idsearchwordlist=swl.idsearchwordlist)
       + (SELECT IFNULL(SUM(ls.word_count),0) FROM linker_search ls WHERE ls.searchwordlist_idsearchwordlist=swl.idsearchwordlist)
       + (SELECT IFNULL(SUM(ws.word_count),0) FROM writing_search ws WHERE ws.searchwordlist_idsearchwordlist=swl.idsearchwordlist)
       + (SELECT IFNULL(SUM(ips.word_count),0) FROM imagepost_search ips WHERE ips.searchwordlist_idsearchwordlist=swl.idsearchwordlist) AS count
FROM searchwordlist swl
WHERE swl.word LIKE CONCAT(?, '%')
ORDER BY swl.word
LIMIT ? OFFSET ?
`

type AdminWordListWithCountsByPrefixParams struct {
	Prefix interface{}
	Limit  int32
	Offset int32
}

type AdminWordListWithCountsByPrefixRow struct {
	Word  sql.NullString
	Count int32
}

func (q *Queries) AdminWordListWithCountsByPrefix(ctx context.Context, arg AdminWordListWithCountsByPrefixParams) ([]*AdminWordListWithCountsByPrefixRow, error) {
	rows, err := q.db.QueryContext(ctx, adminWordListWithCountsByPrefix, arg.Prefix, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminWordListWithCountsByPrefixRow
	for rows.Next() {
		var i AdminWordListWithCountsByPrefixRow
		if err := rows.Scan(&i.Word, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkerSearchFirst = `-- name: LinkerSearchFirst :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT DISTINCT cs.linker_id
FROM linker_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist = cs.searchwordlist_idsearchwordlist
JOIN linker l ON l.id = cs.linker_id
WHERE swl.word = ?
  AND (
      l.language_id = 0
      OR l.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = l.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='linker'
        AND (g.item='link' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = l.id OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type LinkerSearchFirstParams struct {
	ListerID int32
	Word     sql.NullString
	UserID   sql.NullInt32
}

func (q *Queries) LinkerSearchFirst(ctx context.Context, arg LinkerSearchFirstParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, linkerSearchFirst,
		arg.ListerID,
		arg.Word,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var linker_id int32
		if err := rows.Scan(&linker_id); err != nil {
			return nil, err
		}
		items = append(items, linker_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkerSearchNext = `-- name: LinkerSearchNext :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT DISTINCT cs.linker_id
FROM linker_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist = cs.searchwordlist_idsearchwordlist
JOIN linker l ON l.id = cs.linker_id
WHERE swl.word = ?
  AND cs.linker_id IN (/*SLICE:ids*/?)
  AND (
      l.language_id = 0
      OR l.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = l.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='linker'
        AND (g.item='link' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = l.id OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type LinkerSearchNextParams struct {
	ListerID int32
	Word     sql.NullString
	Ids      []int32
	UserID   sql.NullInt32
}

func (q *Queries) LinkerSearchNext(ctx context.Context, arg LinkerSearchNextParams) ([]int32, error) {
	query := linkerSearchNext
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var linker_id int32
		if err := rows.Scan(&linker_id); err != nil {
			return nil, err
		}
		items = append(items, linker_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommentIDsBySearchWordFirstForListerInRestrictedTopic = `-- name: ListCommentIDsBySearchWordFirstForListerInRestrictedTopic :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT DISTINCT cs.comment_id
FROM comments_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
LEFT JOIN comments c ON c.idcomments=cs.comment_id
LEFT JOIN forumthread fth ON fth.idforumthread=c.forumthread_id
LEFT JOIN forumtopic ft ON ft.idforumtopic=fth.forumtopic_idforumtopic
WHERE swl.word=?
  AND fth.forumtopic_idforumtopic IN (/*SLICE:ftids*/?)
  AND (
      c.language_id = 0
      OR c.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = c.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE (g.section='forum' OR g.section='privateforum')
        AND (g.item='topic' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = ft.idforumtopic OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type ListCommentIDsBySearchWordFirstForListerInRestrictedTopicParams struct {
	ListerID int32
	Word     sql.NullString
	Ftids    []int32
	UserID   sql.NullInt32
}

func (q *Queries) ListCommentIDsBySearchWordFirstForListerInRestrictedTopic(ctx context.Context, arg ListCommentIDsBySearchWordFirstForListerInRestrictedTopicParams) ([]int32, error) {
	query := listCommentIDsBySearchWordFirstForListerInRestrictedTopic
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ftids) > 0 {
		for _, v := range arg.Ftids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ftids*/?", strings.Repeat(",?", len(arg.Ftids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ftids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var comment_id int32
		if err := rows.Scan(&comment_id); err != nil {
			return nil, err
		}
		items = append(items, comment_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommentIDsBySearchWordFirstForListerNotInRestrictedTopic = `-- name: ListCommentIDsBySearchWordFirstForListerNotInRestrictedTopic :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT DISTINCT cs.comment_id
FROM comments_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
LEFT JOIN comments c ON c.idcomments=cs.comment_id
LEFT JOIN forumthread fth ON fth.idforumthread=c.forumthread_id
LEFT JOIN forumtopic ft ON ft.idforumtopic=fth.forumtopic_idforumtopic
WHERE swl.word=?
  AND ft.forumcategory_idforumcategory!=0
  AND (
      c.language_id = 0
      OR c.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = c.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE (g.section='forum' OR g.section='privateforum')
        AND (g.item='topic' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = ft.idforumtopic OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type ListCommentIDsBySearchWordFirstForListerNotInRestrictedTopicParams struct {
	ListerID int32
	Word     sql.NullString
	UserID   sql.NullInt32
}

func (q *Queries) ListCommentIDsBySearchWordFirstForListerNotInRestrictedTopic(ctx context.Context, arg ListCommentIDsBySearchWordFirstForListerNotInRestrictedTopicParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, listCommentIDsBySearchWordFirstForListerNotInRestrictedTopic,
		arg.ListerID,
		arg.Word,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var comment_id int32
		if err := rows.Scan(&comment_id); err != nil {
			return nil, err
		}
		items = append(items, comment_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommentIDsBySearchWordNextForListerInRestrictedTopic = `-- name: ListCommentIDsBySearchWordNextForListerInRestrictedTopic :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT DISTINCT cs.comment_id
FROM comments_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
LEFT JOIN comments c ON c.idcomments=cs.comment_id
LEFT JOIN forumthread fth ON fth.idforumthread=c.forumthread_id
LEFT JOIN forumtopic ft ON ft.idforumtopic=fth.forumtopic_idforumtopic
WHERE swl.word=?
  AND cs.comment_id IN (/*SLICE:ids*/?)
  AND fth.forumtopic_idforumtopic IN (/*SLICE:ftids*/?)
  AND (
      c.language_id = 0
      OR c.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = c.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE (g.section='forum' OR g.section='privateforum')
        AND (g.item='topic' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = ft.idforumtopic OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type ListCommentIDsBySearchWordNextForListerInRestrictedTopicParams struct {
	ListerID int32
	Word     sql.NullString
	Ids      []int32
	Ftids    []int32
	UserID   sql.NullInt32
}

func (q *Queries) ListCommentIDsBySearchWordNextForListerInRestrictedTopic(ctx context.Context, arg ListCommentIDsBySearchWordNextForListerInRestrictedTopicParams) ([]int32, error) {
	query := listCommentIDsBySearchWordNextForListerInRestrictedTopic
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	if len(arg.Ftids) > 0 {
		for _, v := range arg.Ftids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ftids*/?", strings.Repeat(",?", len(arg.Ftids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ftids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var comment_id int32
		if err := rows.Scan(&comment_id); err != nil {
			return nil, err
		}
		items = append(items, comment_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommentIDsBySearchWordNextForListerNotInRestrictedTopic = `-- name: ListCommentIDsBySearchWordNextForListerNotInRestrictedTopic :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT DISTINCT cs.comment_id
FROM comments_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
LEFT JOIN comments c ON c.idcomments=cs.comment_id
LEFT JOIN forumthread fth ON fth.idforumthread=c.forumthread_id
LEFT JOIN forumtopic ft ON ft.idforumtopic=fth.forumtopic_idforumtopic
WHERE swl.word=?
  AND cs.comment_id IN (/*SLICE:ids*/?)
  AND ft.forumcategory_idforumcategory!=0
  AND (
      c.language_id = 0
      OR c.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = c.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE (g.section='forum' OR g.section='privateforum')
        AND (g.item='topic' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = ft.idforumtopic OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type ListCommentIDsBySearchWordNextForListerNotInRestrictedTopicParams struct {
	ListerID int32
	Word     sql.NullString
	Ids      []int32
	UserID   sql.NullInt32
}

func (q *Queries) ListCommentIDsBySearchWordNextForListerNotInRestrictedTopic(ctx context.Context, arg ListCommentIDsBySearchWordNextForListerNotInRestrictedTopicParams) ([]int32, error) {
	query := listCommentIDsBySearchWordNextForListerNotInRestrictedTopic
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var comment_id int32
		if err := rows.Scan(&comment_id); err != nil {
			return nil, err
		}
		items = append(items, comment_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteNewsSearchFirstForLister = `-- name: ListSiteNewsSearchFirstForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT DISTINCT cs.site_news_id
FROM site_news_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist = cs.searchwordlist_idsearchwordlist
JOIN site_news sn ON sn.idsiteNews = cs.site_news_id
WHERE swl.word = ?
  AND (
      sn.language_id = 0
      OR sn.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = sn.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='news'
        AND (g.item='post' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = sn.idsiteNews OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type ListSiteNewsSearchFirstForListerParams struct {
	ListerID int32
	Word     sql.NullString
	UserID   sql.NullInt32
}

func (q *Queries) ListSiteNewsSearchFirstForLister(ctx context.Context, arg ListSiteNewsSearchFirstForListerParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, listSiteNewsSearchFirstForLister,
		arg.ListerID,
		arg.Word,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var site_news_id int32
		if err := rows.Scan(&site_news_id); err != nil {
			return nil, err
		}
		items = append(items, site_news_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteNewsSearchNextForLister = `-- name: ListSiteNewsSearchNextForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT DISTINCT cs.site_news_id
FROM site_news_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist = cs.searchwordlist_idsearchwordlist
JOIN site_news sn ON sn.idsiteNews = cs.site_news_id
WHERE swl.word = ?
  AND cs.site_news_id IN (/*SLICE:ids*/?)
  AND (
      sn.language_id = 0
      OR sn.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = sn.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='news'
        AND (g.item='post' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = sn.idsiteNews OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type ListSiteNewsSearchNextForListerParams struct {
	ListerID int32
	Word     sql.NullString
	Ids      []int32
	UserID   sql.NullInt32
}

func (q *Queries) ListSiteNewsSearchNextForLister(ctx context.Context, arg ListSiteNewsSearchNextForListerParams) ([]int32, error) {
	query := listSiteNewsSearchNextForLister
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var site_news_id int32
		if err := rows.Scan(&site_news_id); err != nil {
			return nil, err
		}
		items = append(items, site_news_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWritingSearchFirstForLister = `-- name: ListWritingSearchFirstForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT DISTINCT cs.writing_id
FROM writing_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist = cs.searchwordlist_idsearchwordlist
JOIN writing w ON w.idwriting = cs.writing_id
WHERE swl.word = ?
  AND (
      w.language_id = 0
      OR w.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = w.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='writing'
        AND (g.item='article' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = w.idwriting OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type ListWritingSearchFirstForListerParams struct {
	ListerID int32
	Word     sql.NullString
	UserID   sql.NullInt32
}

func (q *Queries) ListWritingSearchFirstForLister(ctx context.Context, arg ListWritingSearchFirstForListerParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, listWritingSearchFirstForLister,
		arg.ListerID,
		arg.Word,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var writing_id int32
		if err := rows.Scan(&writing_id); err != nil {
			return nil, err
		}
		items = append(items, writing_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWritingSearchNextForLister = `-- name: ListWritingSearchNextForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT DISTINCT cs.writing_id
FROM writing_search cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist = cs.searchwordlist_idsearchwordlist
JOIN writing w ON w.idwriting = cs.writing_id
WHERE swl.word = ?
  AND cs.writing_id IN (/*SLICE:ids*/?)
  AND (
      w.language_id = 0
      OR w.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = w.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='writing'
        AND (g.item='article' OR g.item IS NULL)
        AND g.action='see'
        AND g.active=1
        AND (g.item_id = w.idwriting OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type ListWritingSearchNextForListerParams struct {
	ListerID int32
	Word     sql.NullString
	Ids      []int32
	UserID   sql.NullInt32
}

func (q *Queries) ListWritingSearchNextForLister(ctx context.Context, arg ListWritingSearchNextForListerParams) ([]int32, error) {
	query := listWritingSearchNextForLister
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.ListerID)
	queryParams = append(queryParams, arg.UserID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var writing_id int32
		if err := rows.Scan(&writing_id); err != nil {
			return nil, err
		}
		items = append(items, writing_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemAddToBlogsSearch = `-- name: SystemAddToBlogsSearch :exec
INSERT INTO blogs_search
(blog_id, searchwordlist_idsearchwordlist, word_count)
VALUES (?, ?, ?)
ON DUPLICATE KEY UPDATE word_count=VALUES(word_count)
`

type SystemAddToBlogsSearchParams struct {
	BlogID                         int32
	SearchwordlistIdsearchwordlist int32
	WordCount                      int32
}

func (q *Queries) SystemAddToBlogsSearch(ctx context.Context, arg SystemAddToBlogsSearchParams) error {
	_, err := q.db.ExecContext(ctx, systemAddToBlogsSearch, arg.BlogID, arg.SearchwordlistIdsearchwordlist, arg.WordCount)
	return err
}

const systemAddToForumCommentSearch = `-- name: SystemAddToForumCommentSearch :exec
INSERT INTO comments_search
(comment_id, searchwordlist_idsearchwordlist, word_count)
VALUES (?, ?, ?)
ON DUPLICATE KEY UPDATE word_count=VALUES(word_count)
`

type SystemAddToForumCommentSearchParams struct {
	CommentID                      int32
	SearchwordlistIdsearchwordlist int32
	WordCount                      int32
}

func (q *Queries) SystemAddToForumCommentSearch(ctx context.Context, arg SystemAddToForumCommentSearchParams) error {
	_, err := q.db.ExecContext(ctx, systemAddToForumCommentSearch, arg.CommentID, arg.SearchwordlistIdsearchwordlist, arg.WordCount)
	return err
}

const systemAddToForumWritingSearch = `-- name: SystemAddToForumWritingSearch :exec
INSERT INTO writing_search
(writing_id, searchwordlist_idsearchwordlist, word_count)
VALUES (?, ?, ?)
ON DUPLICATE KEY UPDATE word_count=VALUES(word_count)
`

type SystemAddToForumWritingSearchParams struct {
	WritingID                      int32
	SearchwordlistIdsearchwordlist int32
	WordCount                      int32
}

func (q *Queries) SystemAddToForumWritingSearch(ctx context.Context, arg SystemAddToForumWritingSearchParams) error {
	_, err := q.db.ExecContext(ctx, systemAddToForumWritingSearch, arg.WritingID, arg.SearchwordlistIdsearchwordlist, arg.WordCount)
	return err
}

const systemAddToImagePostSearch = `-- name: SystemAddToImagePostSearch :exec
INSERT INTO imagepost_search
(image_post_id, searchwordlist_idsearchwordlist, word_count)
VALUES (?, ?, ?)
ON DUPLICATE KEY UPDATE word_count=VALUES(word_count)
`

type SystemAddToImagePostSearchParams struct {
	ImagePostID                    int32
	SearchwordlistIdsearchwordlist int32
	WordCount                      int32
}

func (q *Queries) SystemAddToImagePostSearch(ctx context.Context, arg SystemAddToImagePostSearchParams) error {
	_, err := q.db.ExecContext(ctx, systemAddToImagePostSearch, arg.ImagePostID, arg.SearchwordlistIdsearchwordlist, arg.WordCount)
	return err
}

const systemAddToLinkerSearch = `-- name: SystemAddToLinkerSearch :exec
INSERT INTO linker_search
(linker_id, searchwordlist_idsearchwordlist, word_count)
VALUES (?, ?, ?)
ON DUPLICATE KEY UPDATE word_count=VALUES(word_count)
`

type SystemAddToLinkerSearchParams struct {
	LinkerID                       int32
	SearchwordlistIdsearchwordlist int32
	WordCount                      int32
}

func (q *Queries) SystemAddToLinkerSearch(ctx context.Context, arg SystemAddToLinkerSearchParams) error {
	_, err := q.db.ExecContext(ctx, systemAddToLinkerSearch, arg.LinkerID, arg.SearchwordlistIdsearchwordlist, arg.WordCount)
	return err
}

const systemAddToSiteNewsSearch = `-- name: SystemAddToSiteNewsSearch :exec
INSERT INTO site_news_search
(site_news_id, searchwordlist_idsearchwordlist, word_count)
VALUES (?, ?, ?)
ON DUPLICATE KEY UPDATE word_count=VALUES(word_count)
`

type SystemAddToSiteNewsSearchParams struct {
	SiteNewsID                     int32
	SearchwordlistIdsearchwordlist int32
	WordCount                      int32
}

func (q *Queries) SystemAddToSiteNewsSearch(ctx context.Context, arg SystemAddToSiteNewsSearchParams) error {
	_, err := q.db.ExecContext(ctx, systemAddToSiteNewsSearch, arg.SiteNewsID, arg.SearchwordlistIdsearchwordlist, arg.WordCount)
	return err
}

const systemCreateSearchWord = `-- name: SystemCreateSearchWord :execlastid
INSERT INTO searchwordlist (word)
VALUES (lcase(?))
ON DUPLICATE KEY UPDATE idsearchwordlist=LAST_INSERT_ID(idsearchwordlist)
`

func (q *Queries) SystemCreateSearchWord(ctx context.Context, word string) (int64, error) {
	result, err := q.db.ExecContext(ctx, systemCreateSearchWord, word)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const systemDeleteBlogsSearch = `-- name: SystemDeleteBlogsSearch :exec
DELETE FROM blogs_search
`

// This query deletes all data from the "blogs_search" table.
func (q *Queries) SystemDeleteBlogsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, systemDeleteBlogsSearch)
	return err
}

const systemDeleteCommentsSearch = `-- name: SystemDeleteCommentsSearch :exec
DELETE FROM comments_search
`

// This query deletes all data from the "comments_search" table.
func (q *Queries) SystemDeleteCommentsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, systemDeleteCommentsSearch)
	return err
}

const systemDeleteImagePostSearch = `-- name: SystemDeleteImagePostSearch :exec
DELETE FROM imagepost_search
`

func (q *Queries) SystemDeleteImagePostSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, systemDeleteImagePostSearch)
	return err
}

const systemDeleteLinkerSearch = `-- name: SystemDeleteLinkerSearch :exec
DELETE FROM linker_search
`

// This query deletes all data from the "linker_search" table.
func (q *Queries) SystemDeleteLinkerSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, systemDeleteLinkerSearch)
	return err
}

const systemDeleteSiteNewsSearch = `-- name: SystemDeleteSiteNewsSearch :exec
DELETE FROM site_news_search
`

// This query deletes all data from the "site_news_search" table.
func (q *Queries) SystemDeleteSiteNewsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, systemDeleteSiteNewsSearch)
	return err
}

const systemDeleteWritingSearch = `-- name: SystemDeleteWritingSearch :exec
DELETE FROM writing_search
`

// This query deletes all data from the "writing_search" table.
func (q *Queries) SystemDeleteWritingSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, systemDeleteWritingSearch)
	return err
}

const systemDeleteWritingSearchByWritingID = `-- name: SystemDeleteWritingSearchByWritingID :exec
DELETE FROM writing_search
WHERE writing_id = ?
`

func (q *Queries) SystemDeleteWritingSearchByWritingID(ctx context.Context, writingID int32) error {
	_, err := q.db.ExecContext(ctx, systemDeleteWritingSearchByWritingID, writingID)
	return err
}

const systemGetSearchWordByWordLowercased = `-- name: SystemGetSearchWordByWordLowercased :one
SELECT idsearchwordlist, word
FROM searchwordlist
WHERE word = lcase(?)
`

func (q *Queries) SystemGetSearchWordByWordLowercased(ctx context.Context, lcase string) (*Searchwordlist, error) {
	row := q.db.QueryRowContext(ctx, systemGetSearchWordByWordLowercased, lcase)
	var i Searchwordlist
	err := row.Scan(&i.Idsearchwordlist, &i.Word)
	return &i, err
}
