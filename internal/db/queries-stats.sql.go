// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-stats.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const adminCountThreadsByBoard = `-- name: AdminCountThreadsByBoard :one
SELECT COUNT(DISTINCT forumthread_id)
FROM imagepost
WHERE imageboard_idimageboard = ?
`

func (q *Queries) AdminCountThreadsByBoard(ctx context.Context, imageboardIdimageboard int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, adminCountThreadsByBoard, imageboardIdimageboard)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminDeleteTemplateOverride = `-- name: AdminDeleteTemplateOverride :exec
DELETE FROM template_overrides WHERE name = ?
`

func (q *Queries) AdminDeleteTemplateOverride(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, adminDeleteTemplateOverride, name)
	return err
}

const adminForumCategoryThreadCounts = `-- name: AdminForumCategoryThreadCounts :many
SELECT c.idforumcategory, c.title, COUNT(th.idforumthread) AS count
FROM forumcategory c
LEFT JOIN forumtopic t ON c.idforumcategory = t.forumcategory_idforumcategory
LEFT JOIN forumthread th ON th.forumtopic_idforumtopic = t.idforumtopic
GROUP BY c.idforumcategory
ORDER BY c.title
`

type AdminForumCategoryThreadCountsRow struct {
	Idforumcategory int32
	Title           sql.NullString
	Count           int64
}

func (q *Queries) AdminForumCategoryThreadCounts(ctx context.Context) ([]*AdminForumCategoryThreadCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminForumCategoryThreadCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminForumCategoryThreadCountsRow
	for rows.Next() {
		var i AdminForumCategoryThreadCountsRow
		if err := rows.Scan(&i.Idforumcategory, &i.Title, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminForumTopicThreadCounts = `-- name: AdminForumTopicThreadCounts :many
SELECT t.idforumtopic, t.title, COUNT(th.idforumthread) AS count
FROM forumtopic t
LEFT JOIN forumthread th ON th.forumtopic_idforumtopic = t.idforumtopic
GROUP BY t.idforumtopic
ORDER BY t.title
`

type AdminForumTopicThreadCountsRow struct {
	Idforumtopic int32
	Title        sql.NullString
	Count        int64
}

func (q *Queries) AdminForumTopicThreadCounts(ctx context.Context) ([]*AdminForumTopicThreadCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminForumTopicThreadCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminForumTopicThreadCountsRow
	for rows.Next() {
		var i AdminForumTopicThreadCountsRow
		if err := rows.Scan(&i.Idforumtopic, &i.Title, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetRecentAuditLogs = `-- name: AdminGetRecentAuditLogs :many
SELECT a.id, a.users_idusers, u.username, a.action, a.path, a.details, a.data, a.created_at
FROM audit_log a LEFT JOIN users u ON a.users_idusers = u.idusers
ORDER BY a.id DESC LIMIT ?
`

type AdminGetRecentAuditLogsRow struct {
	ID           int32
	UsersIdusers int32
	Username     sql.NullString
	Action       string
	Path         string
	Details      sql.NullString
	Data         sql.NullString
	CreatedAt    time.Time
}

func (q *Queries) AdminGetRecentAuditLogs(ctx context.Context, limit int32) ([]*AdminGetRecentAuditLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetRecentAuditLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminGetRecentAuditLogsRow
	for rows.Next() {
		var i AdminGetRecentAuditLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UsersIdusers,
			&i.Username,
			&i.Action,
			&i.Path,
			&i.Details,
			&i.Data,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminImageboardPostCounts = `-- name: AdminImageboardPostCounts :many
SELECT ib.idimageboard, ib.title, COUNT(ip.idimagepost) AS count
FROM imageboard ib
LEFT JOIN imagepost ip ON ip.imageboard_idimageboard = ib.idimageboard
GROUP BY ib.idimageboard
ORDER BY ib.title
`

type AdminImageboardPostCountsRow struct {
	Idimageboard int32
	Title        sql.NullString
	Count        int64
}

func (q *Queries) AdminImageboardPostCounts(ctx context.Context) ([]*AdminImageboardPostCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminImageboardPostCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminImageboardPostCountsRow
	for rows.Next() {
		var i AdminImageboardPostCountsRow
		if err := rows.Scan(&i.Idimageboard, &i.Title, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminSetTemplateOverride = `-- name: AdminSetTemplateOverride :exec
INSERT INTO template_overrides (name, body)
VALUES (?, ?)
ON DUPLICATE KEY UPDATE body = VALUES(body)
`

type AdminSetTemplateOverrideParams struct {
	Name string
	Body string
}

func (q *Queries) AdminSetTemplateOverride(ctx context.Context, arg AdminSetTemplateOverrideParams) error {
	_, err := q.db.ExecContext(ctx, adminSetTemplateOverride, arg.Name, arg.Body)
	return err
}

const adminUserPostCounts = `-- name: AdminUserPostCounts :many
SELECT u.idusers, u.username,
       COALESCE(b.blogs, 0)     AS blogs,
       COALESCE(n.news, 0)      AS news,
       COALESCE(c.comments, 0)  AS comments,
       COALESCE(i.images, 0)    AS images,
       COALESCE(l.links, 0)     AS links,
       COALESCE(w.writings, 0)  AS writings
FROM users u
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS blogs FROM blogs GROUP BY users_idusers) b ON b.uid = u.idusers
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS news FROM site_news GROUP BY users_idusers) n ON n.uid = u.idusers
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS comments FROM comments GROUP BY users_idusers) c ON c.uid = u.idusers
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS images FROM imagepost GROUP BY users_idusers) i ON i.uid = u.idusers
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS links FROM linker GROUP BY users_idusers) l ON l.uid = u.idusers
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS writings FROM writing GROUP BY users_idusers) w ON w.uid = u.idusers
ORDER BY u.username
`

type AdminUserPostCountsRow struct {
	Idusers  int32
	Username sql.NullString
	Blogs    int64
	News     int64
	Comments int64
	Images   int64
	Links    int64
	Writings int64
}

func (q *Queries) AdminUserPostCounts(ctx context.Context) ([]*AdminUserPostCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminUserPostCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminUserPostCountsRow
	for rows.Next() {
		var i AdminUserPostCountsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Username,
			&i.Blogs,
			&i.News,
			&i.Comments,
			&i.Images,
			&i.Links,
			&i.Writings,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUserPostCountsByID = `-- name: AdminUserPostCountsByID :one
SELECT
  (SELECT COUNT(*) FROM blogs b WHERE b.users_idusers = u.idusers)      AS blogs,
  (SELECT COUNT(*) FROM site_news n WHERE n.users_idusers = u.idusers)  AS news,
  (SELECT COUNT(*) FROM comments c WHERE c.users_idusers = u.idusers)   AS comments,
  (SELECT COUNT(*) FROM imagepost i WHERE i.users_idusers = u.idusers)  AS images,
  (SELECT COUNT(*) FROM linker l WHERE l.users_idusers = u.idusers)     AS links,
  (SELECT COUNT(*) FROM writing w WHERE w.users_idusers = u.idusers)    AS writings
FROM users u
WHERE u.idusers = ?
`

type AdminUserPostCountsByIDRow struct {
	Blogs    int64
	News     int64
	Comments int64
	Images   int64
	Links    int64
	Writings int64
}

func (q *Queries) AdminUserPostCountsByID(ctx context.Context, idusers int32) (*AdminUserPostCountsByIDRow, error) {
	row := q.db.QueryRowContext(ctx, adminUserPostCountsByID, idusers)
	var i AdminUserPostCountsByIDRow
	err := row.Scan(
		&i.Blogs,
		&i.News,
		&i.Comments,
		&i.Images,
		&i.Links,
		&i.Writings,
	)
	return &i, err
}

const adminWritingCategoryCounts = `-- name: AdminWritingCategoryCounts :many
SELECT wc.idwritingCategory, wc.title, COUNT(w.idwriting) AS count
FROM writing_category wc
LEFT JOIN writing w ON w.writing_category_id = wc.idwritingCategory
GROUP BY wc.idwritingCategory
ORDER BY wc.title
`

type AdminWritingCategoryCountsRow struct {
	Idwritingcategory int32
	Title             sql.NullString
	Count             int64
}

func (q *Queries) AdminWritingCategoryCounts(ctx context.Context) ([]*AdminWritingCategoryCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminWritingCategoryCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminWritingCategoryCountsRow
	for rows.Next() {
		var i AdminWritingCategoryCountsRow
		if err := rows.Scan(&i.Idwritingcategory, &i.Title, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemGetTemplateOverride = `-- name: SystemGetTemplateOverride :one
SELECT body FROM template_overrides WHERE name = ?
`

func (q *Queries) SystemGetTemplateOverride(ctx context.Context, name string) (string, error) {
	row := q.db.QueryRowContext(ctx, systemGetTemplateOverride, name)
	var body string
	err := row.Scan(&body)
	return body, err
}

const systemListUserInfo = `-- name: SystemListUserInfo :many
SELECT u.idusers, u.username,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email,
       IF(r.id IS NULL, 0, 1) AS admin,
       MIN(s.created_at) AS created_at
FROM users u
LEFT JOIN user_roles ur ON ur.users_idusers = u.idusers
LEFT JOIN roles r ON ur.role_id = r.id AND r.is_admin = 1
LEFT JOIN sessions s ON s.users_idusers = u.idusers
GROUP BY u.idusers
ORDER BY u.idusers
`

type SystemListUserInfoRow struct {
	Idusers   int32
	Username  sql.NullString
	Email     string
	Admin     interface{}
	CreatedAt interface{}
}

func (q *Queries) SystemListUserInfo(ctx context.Context) ([]*SystemListUserInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, systemListUserInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SystemListUserInfoRow
	for rows.Next() {
		var i SystemListUserInfoRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Username,
			&i.Email,
			&i.Admin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
