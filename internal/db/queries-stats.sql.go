// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-stats.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countThreadsByBoard = `-- name: CountThreadsByBoard :one
SELECT COUNT(DISTINCT forumthread_id)
FROM imagepost
WHERE imageboard_idimageboard = ?
`

func (q *Queries) CountThreadsByBoard(ctx context.Context, imageboardIdimageboard int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countThreadsByBoard, imageboardIdimageboard)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteTemplateOverride = `-- name: DeleteTemplateOverride :exec
DELETE FROM template_overrides WHERE name = ?
`

func (q *Queries) DeleteTemplateOverride(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteTemplateOverride, name)
	return err
}

const forumCategoryThreadCounts = `-- name: ForumCategoryThreadCounts :many
SELECT c.title, COUNT(th.idforumthread) AS count
FROM forumcategory c
LEFT JOIN forumtopic t ON c.idforumcategory = t.forumcategory_idforumcategory
LEFT JOIN forumthread th ON th.forumtopic_idforumtopic = t.idforumtopic
GROUP BY c.idforumcategory
ORDER BY c.title
`

type ForumCategoryThreadCountsRow struct {
	Title sql.NullString
	Count int64
}

func (q *Queries) ForumCategoryThreadCounts(ctx context.Context) ([]*ForumCategoryThreadCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, forumCategoryThreadCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ForumCategoryThreadCountsRow
	for rows.Next() {
		var i ForumCategoryThreadCountsRow
		if err := rows.Scan(&i.Title, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const forumTopicThreadCounts = `-- name: ForumTopicThreadCounts :many
SELECT t.title, COUNT(th.idforumthread) AS count
FROM forumtopic t
LEFT JOIN forumthread th ON th.forumtopic_idforumtopic = t.idforumtopic
GROUP BY t.idforumtopic
ORDER BY t.title
`

type ForumTopicThreadCountsRow struct {
	Title sql.NullString
	Count int64
}

func (q *Queries) ForumTopicThreadCounts(ctx context.Context) ([]*ForumTopicThreadCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, forumTopicThreadCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ForumTopicThreadCountsRow
	for rows.Next() {
		var i ForumTopicThreadCountsRow
		if err := rows.Scan(&i.Title, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentAuditLogs = `-- name: GetRecentAuditLogs :many
SELECT a.id, a.users_idusers, u.username, a.action, a.path, a.details, a.data, a.created_at
FROM audit_log a LEFT JOIN users u ON a.users_idusers = u.idusers
ORDER BY a.id DESC LIMIT ?
`

type GetRecentAuditLogsRow struct {
	ID           int32
	UsersIdusers int32
	Username     sql.NullString
	Action       string
	Path         string
	Details      sql.NullString
	Data         sql.NullString
	CreatedAt    time.Time
}

func (q *Queries) GetRecentAuditLogs(ctx context.Context, limit int32) ([]*GetRecentAuditLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentAuditLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetRecentAuditLogsRow
	for rows.Next() {
		var i GetRecentAuditLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UsersIdusers,
			&i.Username,
			&i.Action,
			&i.Path,
			&i.Details,
			&i.Data,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTemplateOverride = `-- name: GetTemplateOverride :one
SELECT body FROM template_overrides WHERE name = ?
`

func (q *Queries) GetTemplateOverride(ctx context.Context, name string) (string, error) {
	row := q.db.QueryRowContext(ctx, getTemplateOverride, name)
	var body string
	err := row.Scan(&body)
	return body, err
}

const imageboardPostCounts = `-- name: ImageboardPostCounts :many
SELECT ib.title, COUNT(ip.idimagepost) AS count
FROM imageboard ib
LEFT JOIN imagepost ip ON ip.imageboard_idimageboard = ib.idimageboard
GROUP BY ib.idimageboard
ORDER BY ib.title
`

type ImageboardPostCountsRow struct {
	Title sql.NullString
	Count int64
}

func (q *Queries) ImageboardPostCounts(ctx context.Context) ([]*ImageboardPostCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, imageboardPostCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ImageboardPostCountsRow
	for rows.Next() {
		var i ImageboardPostCountsRow
		if err := rows.Scan(&i.Title, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserInfo = `-- name: ListUserInfo :many
SELECT u.idusers, u.username,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email,
       IF(r.id IS NULL, 0, 1) AS admin,
       MIN(s.created_at) AS created_at
FROM users u
LEFT JOIN user_roles ur ON ur.users_idusers = u.idusers
LEFT JOIN roles r ON ur.role_id = r.id AND r.is_admin = 1
LEFT JOIN sessions s ON s.users_idusers = u.idusers
GROUP BY u.idusers
ORDER BY u.idusers
`

type ListUserInfoRow struct {
	Idusers   int32
	Username  sql.NullString
	Email     string
	Admin     interface{}
	CreatedAt interface{}
}

func (q *Queries) ListUserInfo(ctx context.Context) ([]*ListUserInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUserInfoRow
	for rows.Next() {
		var i ListUserInfoRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Username,
			&i.Email,
			&i.Admin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTemplateOverride = `-- name: SetTemplateOverride :exec
INSERT INTO template_overrides (name, body)
VALUES (?, ?)
ON DUPLICATE KEY UPDATE body = VALUES(body)
`

type SetTemplateOverrideParams struct {
	Name string
	Body string
}

func (q *Queries) SetTemplateOverride(ctx context.Context, arg SetTemplateOverrideParams) error {
	_, err := q.db.ExecContext(ctx, setTemplateOverride, arg.Name, arg.Body)
	return err
}

const userPostCounts = `-- name: UserPostCounts :many
SELECT u.username,
       COALESCE(b.blogs, 0)     AS blogs,
       COALESCE(n.news, 0)      AS news,
       COALESCE(c.comments, 0)  AS comments,
       COALESCE(i.images, 0)    AS images,
       COALESCE(l.links, 0)     AS links,
       COALESCE(w.writings, 0)  AS writings
FROM users u
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS blogs FROM blogs GROUP BY users_idusers) b ON b.uid = u.idusers
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS news FROM site_news GROUP BY users_idusers) n ON n.uid = u.idusers
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS comments FROM comments GROUP BY users_idusers) c ON c.uid = u.idusers
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS images FROM imagepost GROUP BY users_idusers) i ON i.uid = u.idusers
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS links FROM linker GROUP BY users_idusers) l ON l.uid = u.idusers
LEFT JOIN (SELECT users_idusers AS uid, COUNT(*) AS writings FROM writing GROUP BY users_idusers) w ON w.uid = u.idusers
ORDER BY u.username
`

type UserPostCountsRow struct {
	Username sql.NullString
	Blogs    int64
	News     int64
	Comments int64
	Images   int64
	Links    int64
	Writings int64
}

func (q *Queries) UserPostCounts(ctx context.Context) ([]*UserPostCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, userPostCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserPostCountsRow
	for rows.Next() {
		var i UserPostCountsRow
		if err := rows.Scan(
			&i.Username,
			&i.Blogs,
			&i.News,
			&i.Comments,
			&i.Images,
			&i.Links,
			&i.Writings,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userPostCountsByID = `-- name: UserPostCountsByID :one
SELECT
  (SELECT COUNT(*) FROM blogs b WHERE b.users_idusers = u.idusers)      AS blogs,
  (SELECT COUNT(*) FROM site_news n WHERE n.users_idusers = u.idusers)  AS news,
  (SELECT COUNT(*) FROM comments c WHERE c.users_idusers = u.idusers)   AS comments,
  (SELECT COUNT(*) FROM imagepost i WHERE i.users_idusers = u.idusers)  AS images,
  (SELECT COUNT(*) FROM linker l WHERE l.users_idusers = u.idusers)     AS links,
  (SELECT COUNT(*) FROM writing w WHERE w.users_idusers = u.idusers)    AS writings
FROM users u
WHERE u.idusers = ?
`

type UserPostCountsByIDRow struct {
	Blogs    int64
	News     int64
	Comments int64
	Images   int64
	Links    int64
	Writings int64
}

func (q *Queries) UserPostCountsByID(ctx context.Context, idusers int32) (*UserPostCountsByIDRow, error) {
	row := q.db.QueryRowContext(ctx, userPostCountsByID, idusers)
	var i UserPostCountsByIDRow
	err := row.Scan(
		&i.Blogs,
		&i.News,
		&i.Comments,
		&i.Images,
		&i.Links,
		&i.Writings,
	)
	return &i, err
}

const writingCategoryCounts = `-- name: WritingCategoryCounts :many
SELECT wc.title, COUNT(w.idwriting) AS count
FROM writing_category wc
LEFT JOIN writing w ON w.writing_category_id = wc.idwritingCategory
GROUP BY wc.idwritingCategory
ORDER BY wc.title
`

type WritingCategoryCountsRow struct {
	Title sql.NullString
	Count int64
}

func (q *Queries) WritingCategoryCounts(ctx context.Context) ([]*WritingCategoryCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, writingCategoryCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WritingCategoryCountsRow
	for rows.Next() {
		var i WritingCategoryCountsRow
		if err := rows.Scan(&i.Title, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
