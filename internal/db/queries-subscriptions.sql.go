// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries-subscriptions.sql

package db

import (
	"context"
	"strings"
)

const deleteSubscriptionByIDForSubscriber = `-- name: DeleteSubscriptionByIDForSubscriber :exec
DELETE FROM subscriptions WHERE users_idusers = ? AND id = ?
`

type DeleteSubscriptionByIDForSubscriberParams struct {
	SubscriberID int32
	ID           int32
}

func (q *Queries) DeleteSubscriptionByIDForSubscriber(ctx context.Context, arg DeleteSubscriptionByIDForSubscriberParams) error {
	_, err := q.db.ExecContext(ctx, deleteSubscriptionByIDForSubscriber, arg.SubscriberID, arg.ID)
	return err
}

const deleteSubscriptionForSubscriber = `-- name: DeleteSubscriptionForSubscriber :exec
DELETE FROM subscriptions
WHERE users_idusers = ? AND pattern = ? AND method = ?
`

type DeleteSubscriptionForSubscriberParams struct {
	SubscriberID int32
	Pattern      string
	Method       string
}

func (q *Queries) DeleteSubscriptionForSubscriber(ctx context.Context, arg DeleteSubscriptionForSubscriberParams) error {
	_, err := q.db.ExecContext(ctx, deleteSubscriptionForSubscriber, arg.SubscriberID, arg.Pattern, arg.Method)
	return err
}

const insertSubscription = `-- name: InsertSubscription :exec
INSERT INTO subscriptions (users_idusers, pattern, method)
VALUES (?, ?, ?)
`

type InsertSubscriptionParams struct {
	UsersIdusers int32
	Pattern      string
	Method       string
}

func (q *Queries) InsertSubscription(ctx context.Context, arg InsertSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, insertSubscription, arg.UsersIdusers, arg.Pattern, arg.Method)
	return err
}

const listSubscribersForPattern = `-- name: ListSubscribersForPattern :many
SELECT users_idusers FROM subscriptions
WHERE pattern = ? AND method = ?
`

type ListSubscribersForPatternParams struct {
	Pattern string
	Method  string
}

func (q *Queries) ListSubscribersForPattern(ctx context.Context, arg ListSubscribersForPatternParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, listSubscribersForPattern, arg.Pattern, arg.Method)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var users_idusers int32
		if err := rows.Scan(&users_idusers); err != nil {
			return nil, err
		}
		items = append(items, users_idusers)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscribersForPatterns = `-- name: ListSubscribersForPatterns :many
SELECT DISTINCT users_idusers FROM subscriptions
WHERE pattern IN (/*SLICE:patterns*/?) AND method = ?
`

type ListSubscribersForPatternsParams struct {
	Patterns []string
	Method   string
}

func (q *Queries) ListSubscribersForPatterns(ctx context.Context, arg ListSubscribersForPatternsParams) ([]int32, error) {
	query := listSubscribersForPatterns
	var queryParams []interface{}
	if len(arg.Patterns) > 0 {
		for _, v := range arg.Patterns {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:patterns*/?", strings.Repeat(",?", len(arg.Patterns))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:patterns*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Method)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var users_idusers int32
		if err := rows.Scan(&users_idusers); err != nil {
			return nil, err
		}
		items = append(items, users_idusers)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubscriptionsByUser = `-- name: ListSubscriptionsByUser :many
SELECT id, pattern, method FROM subscriptions
WHERE users_idusers = ?
ORDER BY id
`

type ListSubscriptionsByUserRow struct {
	ID      int32
	Pattern string
	Method  string
}

func (q *Queries) ListSubscriptionsByUser(ctx context.Context, usersIdusers int32) ([]*ListSubscriptionsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listSubscriptionsByUser, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListSubscriptionsByUserRow
	for rows.Next() {
		var i ListSubscriptionsByUserRow
		if err := rows.Scan(&i.ID, &i.Pattern, &i.Method); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listThreadSubscriptionsByUser = `-- name: ListThreadSubscriptionsByUser :many
SELECT id, pattern, method FROM subscriptions
WHERE users_idusers = ?
  AND pattern LIKE 'reply:/forum/topic/%/thread/%'
  AND pattern NOT LIKE '%/topic/*/%'
  AND pattern NOT LIKE '%/thread/*%'
ORDER BY id
`

type ListThreadSubscriptionsByUserRow struct {
	ID      int32
	Pattern string
	Method  string
}

func (q *Queries) ListThreadSubscriptionsByUser(ctx context.Context, usersIdusers int32) ([]*ListThreadSubscriptionsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listThreadSubscriptionsByUser, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListThreadSubscriptionsByUserRow
	for rows.Next() {
		var i ListThreadSubscriptionsByUserRow
		if err := rows.Scan(&i.ID, &i.Pattern, &i.Method); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscriptionByIDForSubscriber = `-- name: UpdateSubscriptionByIDForSubscriber :exec
UPDATE subscriptions SET pattern = ?, method = ?
WHERE users_idusers = ? AND id = ?
`

type UpdateSubscriptionByIDForSubscriberParams struct {
	Pattern      string
	Method       string
	SubscriberID int32
	ID           int32
}

func (q *Queries) UpdateSubscriptionByIDForSubscriber(ctx context.Context, arg UpdateSubscriptionByIDForSubscriberParams) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionByIDForSubscriber,
		arg.Pattern,
		arg.Method,
		arg.SubscriberID,
		arg.ID,
	)
	return err
}
