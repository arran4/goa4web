// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries-threads.sql

package db

import (
	"context"
	"database/sql"
)

const adminDeleteForumThread = `-- name: AdminDeleteForumThread :exec
DELETE forumthread, comments, comments_search
FROM forumthread
LEFT JOIN comments ON comments.forumthread_id = forumthread.idforumthread
LEFT JOIN comments_search ON comments_search.comment_id = comments.idcomments
WHERE forumthread.idforumthread = ?
`

func (q *Queries) AdminDeleteForumThread(ctx context.Context, idforumthread int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteForumThread, idforumthread)
	return err
}

const adminGetForumThreadById = `-- name: AdminGetForumThreadById :one
SELECT
    t.idforumthread,
    t.forumtopic_idforumtopic as idforumtopic,
    SUBSTRING(c.text, 1, 100) AS title,
    c.written as created_at,
    c.users_idusers as created_by,
    t.lastposter as last_post_by,
    t.lastaddition as last_post_at,
    t.comments as post_count,
    ft.title as topic_title,
    ft.handler as topic_handler
FROM
    forumthread t
JOIN
    forumtopic ft ON t.forumtopic_idforumtopic = ft.idforumtopic
JOIN
    comments c ON t.firstpost = c.idcomments
WHERE t.idforumthread = ?
`

type AdminGetForumThreadByIdRow struct {
	Idforumthread int32
	Idforumtopic  int32
	Title         string
	CreatedAt     sql.NullTime
	CreatedBy     int32
	LastPostBy    int32
	LastPostAt    sql.NullTime
	PostCount     sql.NullInt32
	TopicTitle    sql.NullString
	TopicHandler  string
}

func (q *Queries) AdminGetForumThreadById(ctx context.Context, idforumthread int32) (*AdminGetForumThreadByIdRow, error) {
	row := q.db.QueryRowContext(ctx, adminGetForumThreadById, idforumthread)
	var i AdminGetForumThreadByIdRow
	err := row.Scan(
		&i.Idforumthread,
		&i.Idforumtopic,
		&i.Title,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.LastPostBy,
		&i.LastPostAt,
		&i.PostCount,
		&i.TopicTitle,
		&i.TopicHandler,
	)
	return &i, err
}

const adminGetThreadsStartedByUser = `-- name: AdminGetThreadsStartedByUser :many
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked
FROM forumthread th
JOIN comments c ON th.firstpost = c.idcomments
WHERE c.users_idusers = ?
ORDER BY th.lastaddition DESC
`

func (q *Queries) AdminGetThreadsStartedByUser(ctx context.Context, usersIdusers int32) ([]*Forumthread, error) {
	rows, err := q.db.QueryContext(ctx, adminGetThreadsStartedByUser, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumthread
	for rows.Next() {
		var i Forumthread
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Firstpost,
			&i.Lastposter,
			&i.ForumtopicIdforumtopic,
			&i.Comments,
			&i.Lastaddition,
			&i.Locked,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetThreadsStartedByUserWithTopic = `-- name: AdminGetThreadsStartedByUserWithTopic :many
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked, t.title AS topic_title, fc.idforumcategory AS category_id, fc.title AS category_title
FROM forumthread th
JOIN comments c ON th.firstpost = c.idcomments
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic = t.idforumtopic
LEFT JOIN forumcategory fc ON t.forumcategory_idforumcategory = fc.idforumcategory
WHERE c.users_idusers = ?
ORDER BY th.lastaddition DESC
`

type AdminGetThreadsStartedByUserWithTopicRow struct {
	Idforumthread          int32
	Firstpost              int32
	Lastposter             int32
	ForumtopicIdforumtopic int32
	Comments               sql.NullInt32
	Lastaddition           sql.NullTime
	Locked                 sql.NullBool
	TopicTitle             sql.NullString
	CategoryID             sql.NullInt32
	CategoryTitle          sql.NullString
}

func (q *Queries) AdminGetThreadsStartedByUserWithTopic(ctx context.Context, usersIdusers int32) ([]*AdminGetThreadsStartedByUserWithTopicRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetThreadsStartedByUserWithTopic, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminGetThreadsStartedByUserWithTopicRow
	for rows.Next() {
		var i AdminGetThreadsStartedByUserWithTopicRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Firstpost,
			&i.Lastposter,
			&i.ForumtopicIdforumtopic,
			&i.Comments,
			&i.Lastaddition,
			&i.Locked,
			&i.TopicTitle,
			&i.CategoryID,
			&i.CategoryTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListForumThreadGrantsByThreadID = `-- name: AdminListForumThreadGrantsByThreadID :many
SELECT
    g.id,
    g.section,
    g.action,
    r.name AS role_name,
    u.username
FROM
    grants g
LEFT JOIN
    roles r ON g.role_id = r.id
LEFT JOIN
    users u ON g.user_id = u.idusers
WHERE
    g.section = 'forum'
    AND g.item = 'thread'
    AND g.item_id = ?
`

type AdminListForumThreadGrantsByThreadIDRow struct {
	ID       int32
	Section  string
	Action   string
	RoleName sql.NullString
	Username sql.NullString
}

func (q *Queries) AdminListForumThreadGrantsByThreadID(ctx context.Context, itemID sql.NullInt32) ([]*AdminListForumThreadGrantsByThreadIDRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListForumThreadGrantsByThreadID, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListForumThreadGrantsByThreadIDRow
	for rows.Next() {
		var i AdminListForumThreadGrantsByThreadIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Section,
			&i.Action,
			&i.RoleName,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListForumThreads = `-- name: AdminListForumThreads :many
SELECT
    t.idforumthread,
    t.forumtopic_idforumtopic as idforumtopic,
    SUBSTRING(c.text, 1, 100) AS title,
    c.written as created_at,
    c.users_idusers as created_by,
    t.lastposter as last_post_by,
    t.lastaddition as last_post_at,
    t.comments as post_count,
    ft.title as topic_title,
    ft.handler as topic_handler
FROM
    forumthread t
JOIN
    forumtopic ft ON t.forumtopic_idforumtopic = ft.idforumtopic
JOIN
    comments c ON t.firstpost = c.idcomments
ORDER BY t.idforumthread
LIMIT ? OFFSET ?
`

type AdminListForumThreadsParams struct {
	Limit  int32
	Offset int32
}

type AdminListForumThreadsRow struct {
	Idforumthread int32
	Idforumtopic  int32
	Title         string
	CreatedAt     sql.NullTime
	CreatedBy     int32
	LastPostBy    int32
	LastPostAt    sql.NullTime
	PostCount     sql.NullInt32
	TopicTitle    sql.NullString
	TopicHandler  string
}

func (q *Queries) AdminListForumThreads(ctx context.Context, arg AdminListForumThreadsParams) ([]*AdminListForumThreadsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListForumThreads, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListForumThreadsRow
	for rows.Next() {
		var i AdminListForumThreadsRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Idforumtopic,
			&i.Title,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.LastPostBy,
			&i.LastPostAt,
			&i.PostCount,
			&i.TopicTitle,
			&i.TopicHandler,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminRecalculateAllForumThreadMetaData = `-- name: AdminRecalculateAllForumThreadMetaData :exec
UPDATE forumthread
SET lastaddition = (
    SELECT written
    FROM comments
    WHERE forumthread_id = idforumthread
    ORDER BY written DESC
    LIMIT 1
), comments = (
    SELECT COUNT(users_idusers) - 1
    FROM comments
    WHERE forumthread_id = idforumthread
), lastposter = (
    SELECT users_idusers
    FROM comments
    WHERE forumthread_id = idforumthread
    ORDER BY written DESC
    LIMIT 1
), firstpost = (
    SELECT idcomments
    FROM comments
    WHERE forumthread_id = idforumthread
    LIMIT 1
)
`

func (q *Queries) AdminRecalculateAllForumThreadMetaData(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, adminRecalculateAllForumThreadMetaData)
	return err
}

const adminRecalculateForumThreadByIdMetaData = `-- name: AdminRecalculateForumThreadByIdMetaData :exec
UPDATE forumthread
SET lastaddition = (
    SELECT written
    FROM comments
    WHERE forumthread_id = idforumthread
    ORDER BY written DESC
    LIMIT 1
), comments = (
    SELECT COUNT(users_idusers) - 1
    FROM comments
    WHERE forumthread_id = idforumthread
), lastposter = (
    SELECT users_idusers
    FROM comments
    WHERE forumthread_id = idforumthread
    ORDER BY written DESC
    LIMIT 1
), firstpost = (
    SELECT idcomments
    FROM comments
    WHERE forumthread_id = idforumthread
    LIMIT 1
)
WHERE idforumthread = ?
`

func (q *Queries) AdminRecalculateForumThreadByIdMetaData(ctx context.Context, idforumthread int32) error {
	_, err := q.db.ExecContext(ctx, adminRecalculateForumThreadByIdMetaData, idforumthread)
	return err
}

const getForumTopicIdByThreadId = `-- name: GetForumTopicIdByThreadId :one
SELECT forumtopic_idforumtopic FROM forumthread WHERE idforumthread = ?
`

func (q *Queries) GetForumTopicIdByThreadId(ctx context.Context, idforumthread int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getForumTopicIdByThreadId, idforumthread)
	var forumtopic_idforumtopic int32
	err := row.Scan(&forumtopic_idforumtopic)
	return forumtopic_idforumtopic, err
}

const getThreadBySectionThreadIDForReplier = `-- name: GetThreadBySectionThreadIDForReplier :one
WITH role_ids AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked
FROM forumthread th
LEFT JOIN comments fc ON th.firstpost = fc.idcomments
WHERE th.idforumthread = ?
  AND (
      fc.language_id = 0
      OR fc.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = fc.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = ?
      AND (g.item = ? OR g.item IS NULL)
      AND g.action = 'reply'
      AND g.active = 1
      AND (g.item_id = ? OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
`

type GetThreadBySectionThreadIDForReplierParams struct {
	ReplierID      int32
	ThreadID       int32
	Section        string
	ItemType       sql.NullString
	ItemID         sql.NullInt32
	ReplierMatchID sql.NullInt32
}

func (q *Queries) GetThreadBySectionThreadIDForReplier(ctx context.Context, arg GetThreadBySectionThreadIDForReplierParams) (*Forumthread, error) {
	row := q.db.QueryRowContext(ctx, getThreadBySectionThreadIDForReplier,
		arg.ReplierID,
		arg.ThreadID,
		arg.ReplierID,
		arg.ReplierID,
		arg.Section,
		arg.ItemType,
		arg.ItemID,
		arg.ReplierMatchID,
	)
	var i Forumthread
	err := row.Scan(
		&i.Idforumthread,
		&i.Firstpost,
		&i.Lastposter,
		&i.ForumtopicIdforumtopic,
		&i.Comments,
		&i.Lastaddition,
		&i.Locked,
	)
	return &i, err
}

const getThreadLastPosterAndPerms = `-- name: GetThreadLastPosterAndPerms :one
WITH role_ids AS (
    SELECT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked, lu.username AS LastPosterUsername, fcu.idusers AS firstpostuserid
FROM forumthread th
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN users lu ON lu.idusers = t.lastposter
LEFT JOIN comments fc ON th.firstpost = fc.idcomments
LEFT JOIN users fcu ON fc.users_idusers = fcu.idusers
WHERE th.idforumthread=?
  AND (
      fc.language_id = 0
      OR fc.language_id IS NULL
      OR EXISTS (
          SELECT 1 FROM user_language ul
          WHERE ul.users_idusers = ?
            AND ul.language_id = fc.language_id
      )
      OR NOT EXISTS (
          SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
      )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE (g.section='forum' OR g.section='privateforum')
      AND (g.item='topic' OR g.item IS NULL)
      AND g.action='view'
      AND g.active=1
      AND (g.item_id = t.idforumtopic OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  ) AND (t.handler IS NULL OR t.handler != 'private' OR EXISTS (
    SELECT 1 FROM grants g
    WHERE (g.section='privateforum')
      AND g.item='thread'
      AND g.action='view'
      AND g.active=1
      AND g.item_id = th.idforumthread
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  ))
ORDER BY t.lastaddition DESC
`

type GetThreadLastPosterAndPermsParams struct {
	ViewerID      int32
	ThreadID      int32
	ViewerMatchID sql.NullInt32
}

type GetThreadLastPosterAndPermsRow struct {
	Idforumthread          int32
	Firstpost              int32
	Lastposter             int32
	ForumtopicIdforumtopic int32
	Comments               sql.NullInt32
	Lastaddition           sql.NullTime
	Locked                 sql.NullBool
	Lastposterusername     sql.NullString
	Firstpostuserid        sql.NullInt32
}

func (q *Queries) GetThreadLastPosterAndPerms(ctx context.Context, arg GetThreadLastPosterAndPermsParams) (*GetThreadLastPosterAndPermsRow, error) {
	row := q.db.QueryRowContext(ctx, getThreadLastPosterAndPerms,
		arg.ViewerID,
		arg.ThreadID,
		arg.ViewerID,
		arg.ViewerID,
		arg.ViewerMatchID,
		arg.ViewerMatchID,
	)
	var i GetThreadLastPosterAndPermsRow
	err := row.Scan(
		&i.Idforumthread,
		&i.Firstpost,
		&i.Lastposter,
		&i.ForumtopicIdforumtopic,
		&i.Comments,
		&i.Lastaddition,
		&i.Locked,
		&i.Lastposterusername,
		&i.Firstpostuserid,
	)
	return &i, err
}

const systemCreateThread = `-- name: SystemCreateThread :execlastid
INSERT INTO forumthread (forumtopic_idforumtopic) VALUES (?)
`

func (q *Queries) SystemCreateThread(ctx context.Context, forumtopicIdforumtopic int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, systemCreateThread, forumtopicIdforumtopic)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}
