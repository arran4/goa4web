// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries-uploadimages.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const adminListAllUploadedImages = `-- name: AdminListAllUploadedImages :many
SELECT iduploadedimage, path FROM uploaded_images
`

type AdminListAllUploadedImagesRow struct {
	Iduploadedimage int32
	Path            sql.NullString
}

func (q *Queries) AdminListAllUploadedImages(ctx context.Context) ([]*AdminListAllUploadedImagesRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListAllUploadedImages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListAllUploadedImagesRow
	for rows.Next() {
		var i AdminListAllUploadedImagesRow
		if err := rows.Scan(&i.Iduploadedimage, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListUploadedImages = `-- name: AdminListUploadedImages :many
SELECT iduploadedimage, users_idusers, path, width, height, file_size, uploaded
FROM uploaded_images
ORDER BY uploaded DESC
LIMIT ? OFFSET ?
`

type AdminListUploadedImagesParams struct {
	Limit  int32
	Offset int32
}

// Admin
func (q *Queries) AdminListUploadedImages(ctx context.Context, arg AdminListUploadedImagesParams) ([]*UploadedImage, error) {
	rows, err := q.db.QueryContext(ctx, adminListUploadedImages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UploadedImage
	for rows.Next() {
		var i UploadedImage
		if err := rows.Scan(
			&i.Iduploadedimage,
			&i.UsersIdusers,
			&i.Path,
			&i.Width,
			&i.Height,
			&i.FileSize,
			&i.Uploaded,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUpdateUploadedImagePath = `-- name: AdminUpdateUploadedImagePath :exec
UPDATE uploaded_images
SET path = ?
WHERE iduploadedimage = ?
`

type AdminUpdateUploadedImagePathParams struct {
	Path            sql.NullString
	Iduploadedimage int32
}

func (q *Queries) AdminUpdateUploadedImagePath(ctx context.Context, arg AdminUpdateUploadedImagePathParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateUploadedImagePath, arg.Path, arg.Iduploadedimage)
	return err
}

const createUploadedImageForUploader = `-- name: CreateUploadedImageForUploader :execlastid
INSERT INTO uploaded_images (
    users_idusers, path, width, height, file_size, uploaded
)
VALUES (?, ?, ?, ?, ?, NOW())
`

type CreateUploadedImageForUploaderParams struct {
	UploaderID int32
	Path       sql.NullString
	Width      sql.NullInt32
	Height     sql.NullInt32
	FileSize   int32
}

func (q *Queries) CreateUploadedImageForUploader(ctx context.Context, arg CreateUploadedImageForUploaderParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createUploadedImageForUploader,
		arg.UploaderID,
		arg.Path,
		arg.Width,
		arg.Height,
		arg.FileSize,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const listUploadedImagePathsByUser = `-- name: ListUploadedImagePathsByUser :many
SELECT path
FROM uploaded_images
WHERE users_idusers = ?
  AND path IN (/*SLICE:paths*/?)
`

type ListUploadedImagePathsByUserParams struct {
	UserID int32
	Paths  []sql.NullString
}

func (q *Queries) ListUploadedImagePathsByUser(ctx context.Context, arg ListUploadedImagePathsByUserParams) ([]sql.NullString, error) {
	query := listUploadedImagePathsByUser
	var queryParams []interface{}
	queryParams = append(queryParams, arg.UserID)
	if len(arg.Paths) > 0 {
		for _, v := range arg.Paths {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:paths*/?", strings.Repeat(",?", len(arg.Paths))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:paths*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var path sql.NullString
		if err := rows.Scan(&path); err != nil {
			return nil, err
		}
		items = append(items, path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUploadedImagesByUserForLister = `-- name: ListUploadedImagesByUserForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT ui.iduploadedimage, ui.users_idusers, ui.path, ui.width, ui.height, ui.file_size, ui.uploaded
FROM uploaded_images ui
WHERE ui.users_idusers = ?
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='images'
        AND g.item='upload'
        AND g.action='see'
        AND g.active=1
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY uploaded DESC
LIMIT ? OFFSET ?
`

type ListUploadedImagesByUserForListerParams struct {
	ListerID      int32
	UserID        int32
	ListerMatchID sql.NullInt32
	Limit         int32
	Offset        int32
}

func (q *Queries) ListUploadedImagesByUserForLister(ctx context.Context, arg ListUploadedImagesByUserForListerParams) ([]*UploadedImage, error) {
	rows, err := q.db.QueryContext(ctx, listUploadedImagesByUserForLister,
		arg.ListerID,
		arg.UserID,
		arg.ListerMatchID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UploadedImage
	for rows.Next() {
		var i UploadedImage
		if err := rows.Scan(
			&i.Iduploadedimage,
			&i.UsersIdusers,
			&i.Path,
			&i.Width,
			&i.Height,
			&i.FileSize,
			&i.Uploaded,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
