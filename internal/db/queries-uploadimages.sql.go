// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-uploadimages.sql

package db

import (
	"context"
	"database/sql"
)

const adminListUploadedImages = `-- name: AdminListUploadedImages :many
SELECT iduploadedimage, users_idusers, path, width, height, file_size, uploaded
FROM uploaded_images
ORDER BY uploaded DESC
LIMIT ? OFFSET ?
`

type AdminListUploadedImagesParams struct {
	Limit  int32
	Offset int32
}

// Admin
func (q *Queries) AdminListUploadedImages(ctx context.Context, arg AdminListUploadedImagesParams) ([]*UploadedImage, error) {
	rows, err := q.db.QueryContext(ctx, adminListUploadedImages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UploadedImage
	for rows.Next() {
		var i UploadedImage
		if err := rows.Scan(
			&i.Iduploadedimage,
			&i.UsersIdusers,
			&i.Path,
			&i.Width,
			&i.Height,
			&i.FileSize,
			&i.Uploaded,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createUploadedImageForUploader = `-- name: CreateUploadedImageForUploader :execlastid
INSERT INTO uploaded_images (
    users_idusers, path, width, height, file_size, uploaded
)
SELECT ?, ?, ?, ?, ?, NOW()
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='images'
      AND g.item='upload'
      AND g.action='post'
      AND g.active=1
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
)
`

type CreateUploadedImageForUploaderParams struct {
	UploaderID int32
	Path       sql.NullString
	Width      sql.NullInt32
	Height     sql.NullInt32
	FileSize   int32
	GranteeID  sql.NullInt32
}

func (q *Queries) CreateUploadedImageForUploader(ctx context.Context, arg CreateUploadedImageForUploaderParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createUploadedImageForUploader,
		arg.UploaderID,
		arg.Path,
		arg.Width,
		arg.Height,
		arg.FileSize,
		arg.GranteeID,
		arg.UploaderID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const listUploadedImagesByUserForLister = `-- name: ListUploadedImagesByUserForLister :many
WITH RECURSIVE role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT ui.iduploadedimage, ui.users_idusers, ui.path, ui.width, ui.height, ui.file_size, ui.uploaded
FROM uploaded_images ui
WHERE ui.users_idusers = ?
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='images'
        AND g.item='upload'
        AND g.action='see'
        AND g.active=1
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY uploaded DESC
LIMIT ? OFFSET ?
`

type ListUploadedImagesByUserForListerParams struct {
	ListerID      int32
	UserID        int32
	ListerMatchID sql.NullInt32
	Limit         int32
	Offset        int32
}

func (q *Queries) ListUploadedImagesByUserForLister(ctx context.Context, arg ListUploadedImagesByUserForListerParams) ([]*UploadedImage, error) {
	rows, err := q.db.QueryContext(ctx, listUploadedImagesByUserForLister,
		arg.ListerID,
		arg.UserID,
		arg.ListerMatchID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UploadedImage
	for rows.Next() {
		var i UploadedImage
		if err := rows.Scan(
			&i.Iduploadedimage,
			&i.UsersIdusers,
			&i.Path,
			&i.Width,
			&i.Height,
			&i.FileSize,
			&i.Uploaded,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
