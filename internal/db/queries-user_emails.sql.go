// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries-user_emails.sql

package db

import (
	"context"
	"database/sql"
)

const adminAddUserEmail = `-- name: AdminAddUserEmail :exec
INSERT INTO user_emails (user_id, email, verified_at, notification_priority)
VALUES (?, ?, ?, ?)
`

type AdminAddUserEmailParams struct {
	UserID               int32
	Email                string
	VerifiedAt           sql.NullTime
	NotificationPriority int32
}

func (q *Queries) AdminAddUserEmail(ctx context.Context, arg AdminAddUserEmailParams) error {
	_, err := q.db.ExecContext(ctx, adminAddUserEmail,
		arg.UserID,
		arg.Email,
		arg.VerifiedAt,
		arg.NotificationPriority,
	)
	return err
}

const adminDeleteUserEmail = `-- name: AdminDeleteUserEmail :exec
DELETE FROM user_emails WHERE id = ?
`

func (q *Queries) AdminDeleteUserEmail(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteUserEmail, id)
	return err
}

const adminGetUserEmailByID = `-- name: AdminGetUserEmailByID :one
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE id = ?
`

func (q *Queries) AdminGetUserEmailByID(ctx context.Context, id int32) (*UserEmail, error) {
	row := q.db.QueryRowContext(ctx, adminGetUserEmailByID, id)
	var i UserEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.VerifiedAt,
		&i.LastVerificationCode,
		&i.VerificationExpiresAt,
		&i.NotificationPriority,
	)
	return &i, err
}

const adminListUserEmails = `-- name: AdminListUserEmails :many
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE user_id = ?
ORDER BY notification_priority DESC, id
`

func (q *Queries) AdminListUserEmails(ctx context.Context, userID int32) ([]*UserEmail, error) {
	rows, err := q.db.QueryContext(ctx, adminListUserEmails, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserEmail
	for rows.Next() {
		var i UserEmail
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.VerifiedAt,
			&i.LastVerificationCode,
			&i.VerificationExpiresAt,
			&i.NotificationPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUpdateUserEmailDetails = `-- name: AdminUpdateUserEmailDetails :exec
UPDATE user_emails
SET email = ?, verified_at = ?, notification_priority = ?
WHERE id = ?
`

type AdminUpdateUserEmailDetailsParams struct {
	Email                string
	VerifiedAt           sql.NullTime
	NotificationPriority int32
	ID                   int32
}

func (q *Queries) AdminUpdateUserEmailDetails(ctx context.Context, arg AdminUpdateUserEmailDetailsParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateUserEmailDetails,
		arg.Email,
		arg.VerifiedAt,
		arg.NotificationPriority,
		arg.ID,
	)
	return err
}

const deleteUserEmailForOwner = `-- name: DeleteUserEmailForOwner :exec
DELETE FROM user_emails WHERE id = ? AND user_id = ?
`

type DeleteUserEmailForOwnerParams struct {
	ID      int32
	OwnerID int32
}

func (q *Queries) DeleteUserEmailForOwner(ctx context.Context, arg DeleteUserEmailForOwnerParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserEmailForOwner, arg.ID, arg.OwnerID)
	return err
}

const getMaxNotificationPriority = `-- name: GetMaxNotificationPriority :one
SELECT COALESCE(MAX(notification_priority),0) AS maxp FROM user_emails WHERE user_id = ?
`

func (q *Queries) GetMaxNotificationPriority(ctx context.Context, userID int32) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxNotificationPriority, userID)
	var maxp interface{}
	err := row.Scan(&maxp)
	return maxp, err
}

const getNotificationEmailByUserID = `-- name: GetNotificationEmailByUserID :one
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE user_id = ? AND verified_at IS NOT NULL
ORDER BY notification_priority DESC, id
LIMIT 1
`

func (q *Queries) GetNotificationEmailByUserID(ctx context.Context, userID int32) (*UserEmail, error) {
	row := q.db.QueryRowContext(ctx, getNotificationEmailByUserID, userID)
	var i UserEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.VerifiedAt,
		&i.LastVerificationCode,
		&i.VerificationExpiresAt,
		&i.NotificationPriority,
	)
	return &i, err
}

const getUserEmailByCode = `-- name: GetUserEmailByCode :one
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE last_verification_code = ?
`

func (q *Queries) GetUserEmailByCode(ctx context.Context, lastVerificationCode sql.NullString) (*UserEmail, error) {
	row := q.db.QueryRowContext(ctx, getUserEmailByCode, lastVerificationCode)
	var i UserEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.VerifiedAt,
		&i.LastVerificationCode,
		&i.VerificationExpiresAt,
		&i.NotificationPriority,
	)
	return &i, err
}

const getUserEmailByEmail = `-- name: GetUserEmailByEmail :one
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE email = ?
`

func (q *Queries) GetUserEmailByEmail(ctx context.Context, email string) (*UserEmail, error) {
	row := q.db.QueryRowContext(ctx, getUserEmailByEmail, email)
	var i UserEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.VerifiedAt,
		&i.LastVerificationCode,
		&i.VerificationExpiresAt,
		&i.NotificationPriority,
	)
	return &i, err
}

const getUserEmailByID = `-- name: GetUserEmailByID :one
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE id = ?
`

func (q *Queries) GetUserEmailByID(ctx context.Context, id int32) (*UserEmail, error) {
	row := q.db.QueryRowContext(ctx, getUserEmailByID, id)
	var i UserEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.VerifiedAt,
		&i.LastVerificationCode,
		&i.VerificationExpiresAt,
		&i.NotificationPriority,
	)
	return &i, err
}

const insertUserEmail = `-- name: InsertUserEmail :exec
INSERT INTO user_emails (user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority)
VALUES (?, ?, ?, ?, ?, ?)
`

type InsertUserEmailParams struct {
	UserID                int32
	Email                 string
	VerifiedAt            sql.NullTime
	LastVerificationCode  sql.NullString
	VerificationExpiresAt sql.NullTime
	NotificationPriority  int32
}

func (q *Queries) InsertUserEmail(ctx context.Context, arg InsertUserEmailParams) error {
	_, err := q.db.ExecContext(ctx, insertUserEmail,
		arg.UserID,
		arg.Email,
		arg.VerifiedAt,
		arg.LastVerificationCode,
		arg.VerificationExpiresAt,
		arg.NotificationPriority,
	)
	return err
}

const listUserEmailsForLister = `-- name: ListUserEmailsForLister :many
WITH role_ids AS (
    SELECT DISTINCT ur.role_id AS id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT ue.id, ue.user_id, ue.email, ue.verified_at, ue.last_verification_code, ue.verification_expires_at, ue.notification_priority
FROM user_emails ue
WHERE ue.user_id = ?
  AND (
      ? = ue.user_id
      OR EXISTS (
          SELECT 1
          FROM role_ids ri
          JOIN roles r ON r.id = ri.id
          WHERE r.is_admin = 1
      )
  )
`

type ListUserEmailsForListerParams struct {
	ListerID int32
	UserID   int32
}

func (q *Queries) ListUserEmailsForLister(ctx context.Context, arg ListUserEmailsForListerParams) ([]*UserEmail, error) {
	rows, err := q.db.QueryContext(ctx, listUserEmailsForLister, arg.ListerID, arg.UserID, arg.ListerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserEmail
	for rows.Next() {
		var i UserEmail
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.VerifiedAt,
			&i.LastVerificationCode,
			&i.VerificationExpiresAt,
			&i.NotificationPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setNotificationPriorityForLister = `-- name: SetNotificationPriorityForLister :exec
UPDATE user_emails SET notification_priority = ?
WHERE id = ? AND user_id = ?
`

type SetNotificationPriorityForListerParams struct {
	NotificationPriority int32
	ID                   int32
	ListerID             int32
}

func (q *Queries) SetNotificationPriorityForLister(ctx context.Context, arg SetNotificationPriorityForListerParams) error {
	_, err := q.db.ExecContext(ctx, setNotificationPriorityForLister, arg.NotificationPriority, arg.ID, arg.ListerID)
	return err
}

const setVerificationCodeForLister = `-- name: SetVerificationCodeForLister :exec
UPDATE user_emails
SET last_verification_code = ?,
    verification_expires_at = ?
WHERE id = ? AND user_id = ?
`

type SetVerificationCodeForListerParams struct {
	LastVerificationCode  sql.NullString
	VerificationExpiresAt sql.NullTime
	ID                    int32
	ListerID              int32
}

func (q *Queries) SetVerificationCodeForLister(ctx context.Context, arg SetVerificationCodeForListerParams) error {
	_, err := q.db.ExecContext(ctx, setVerificationCodeForLister,
		arg.LastVerificationCode,
		arg.VerificationExpiresAt,
		arg.ID,
		arg.ListerID,
	)
	return err
}

const systemDeleteUnverifiedEmailsExpiresBefore = `-- name: SystemDeleteUnverifiedEmailsExpiresBefore :execresult
DELETE FROM user_emails
WHERE verified_at IS NULL
  AND verification_expires_at < ?
`

func (q *Queries) SystemDeleteUnverifiedEmailsExpiresBefore(ctx context.Context, verificationExpiresAt sql.NullTime) (sql.Result, error) {
	return q.db.ExecContext(ctx, systemDeleteUnverifiedEmailsExpiresBefore, verificationExpiresAt)
}

const systemDeleteUserEmailsByEmailExceptID = `-- name: SystemDeleteUserEmailsByEmailExceptID :exec
DELETE FROM user_emails WHERE email = ? AND id != ?
`

type SystemDeleteUserEmailsByEmailExceptIDParams struct {
	Email string
	ID    int32
}

func (q *Queries) SystemDeleteUserEmailsByEmailExceptID(ctx context.Context, arg SystemDeleteUserEmailsByEmailExceptIDParams) error {
	_, err := q.db.ExecContext(ctx, systemDeleteUserEmailsByEmailExceptID, arg.Email, arg.ID)
	return err
}

const systemListAllUnverifiedEmails = `-- name: SystemListAllUnverifiedEmails :many
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE verified_at IS NULL
ORDER BY id
`

func (q *Queries) SystemListAllUnverifiedEmails(ctx context.Context) ([]*UserEmail, error) {
	rows, err := q.db.QueryContext(ctx, systemListAllUnverifiedEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserEmail
	for rows.Next() {
		var i UserEmail
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.VerifiedAt,
			&i.LastVerificationCode,
			&i.VerificationExpiresAt,
			&i.NotificationPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemListAllUserEmails = `-- name: SystemListAllUserEmails :many
SELECT user_id, email, verified_at
FROM user_emails
ORDER BY user_id, email
`

type SystemListAllUserEmailsRow struct {
	UserID     int32
	Email      string
	VerifiedAt sql.NullTime
}

func (q *Queries) SystemListAllUserEmails(ctx context.Context) ([]*SystemListAllUserEmailsRow, error) {
	rows, err := q.db.QueryContext(ctx, systemListAllUserEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SystemListAllUserEmailsRow
	for rows.Next() {
		var i SystemListAllUserEmailsRow
		if err := rows.Scan(&i.UserID, &i.Email, &i.VerifiedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemListUnverifiedEmailsCreatedAfter = `-- name: SystemListUnverifiedEmailsCreatedAfter :many
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE verified_at IS NULL
  AND verification_expires_at > ?
ORDER BY id
`

func (q *Queries) SystemListUnverifiedEmailsCreatedAfter(ctx context.Context, verificationExpiresAt sql.NullTime) ([]*UserEmail, error) {
	rows, err := q.db.QueryContext(ctx, systemListUnverifiedEmailsCreatedAfter, verificationExpiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserEmail
	for rows.Next() {
		var i UserEmail
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.VerifiedAt,
			&i.LastVerificationCode,
			&i.VerificationExpiresAt,
			&i.NotificationPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemListUnverifiedEmailsExpiresBefore = `-- name: SystemListUnverifiedEmailsExpiresBefore :many
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE verified_at IS NULL
  AND verification_expires_at < ?
ORDER BY id
`

func (q *Queries) SystemListUnverifiedEmailsExpiresBefore(ctx context.Context, verificationExpiresAt sql.NullTime) ([]*UserEmail, error) {
	rows, err := q.db.QueryContext(ctx, systemListUnverifiedEmailsExpiresBefore, verificationExpiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserEmail
	for rows.Next() {
		var i UserEmail
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.VerifiedAt,
			&i.LastVerificationCode,
			&i.VerificationExpiresAt,
			&i.NotificationPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemListVerifiedEmailsByUserID = `-- name: SystemListVerifiedEmailsByUserID :many
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE user_id = ? AND verified_at IS NOT NULL
ORDER BY notification_priority DESC, id
`

func (q *Queries) SystemListVerifiedEmailsByUserID(ctx context.Context, userID int32) ([]*UserEmail, error) {
	rows, err := q.db.QueryContext(ctx, systemListVerifiedEmailsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserEmail
	for rows.Next() {
		var i UserEmail
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.VerifiedAt,
			&i.LastVerificationCode,
			&i.VerificationExpiresAt,
			&i.NotificationPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemMarkUserEmailVerified = `-- name: SystemMarkUserEmailVerified :exec
UPDATE user_emails
SET verified_at = ?, last_verification_code = NULL, verification_expires_at = NULL
WHERE id = ?
`

type SystemMarkUserEmailVerifiedParams struct {
	VerifiedAt sql.NullTime
	ID         int32
}

func (q *Queries) SystemMarkUserEmailVerified(ctx context.Context, arg SystemMarkUserEmailVerifiedParams) error {
	_, err := q.db.ExecContext(ctx, systemMarkUserEmailVerified, arg.VerifiedAt, arg.ID)
	return err
}

const systemUpdateVerificationCode = `-- name: SystemUpdateVerificationCode :exec
UPDATE user_emails
SET last_verification_code = ?, verification_expires_at = ?
WHERE id = ?
`

type SystemUpdateVerificationCodeParams struct {
	LastVerificationCode  sql.NullString
	VerificationExpiresAt sql.NullTime
	ID                    int32
}

func (q *Queries) SystemUpdateVerificationCode(ctx context.Context, arg SystemUpdateVerificationCodeParams) error {
	_, err := q.db.ExecContext(ctx, systemUpdateVerificationCode, arg.LastVerificationCode, arg.VerificationExpiresAt, arg.ID)
	return err
}
