// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-user_emails.sql

package db

import (
	"context"
	"database/sql"
)

const adminListUserEmails = `-- name: AdminListUserEmails :many
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE user_id = ?
ORDER BY notification_priority DESC, id
`

func (q *Queries) AdminListUserEmails(ctx context.Context, userID int32) ([]*UserEmail, error) {
	rows, err := q.db.QueryContext(ctx, adminListUserEmails, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserEmail
	for rows.Next() {
		var i UserEmail
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.VerifiedAt,
			&i.LastVerificationCode,
			&i.VerificationExpiresAt,
			&i.NotificationPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteUserEmailForOwner = `-- name: DeleteUserEmailForOwner :exec
DELETE FROM user_emails WHERE id = ? AND user_id = ?
`

type DeleteUserEmailForOwnerParams struct {
	ID      int32
	OwnerID int32
}

func (q *Queries) DeleteUserEmailForOwner(ctx context.Context, arg DeleteUserEmailForOwnerParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserEmailForOwner, arg.ID, arg.OwnerID)
	return err
}

const getMaxNotificationPriority = `-- name: GetMaxNotificationPriority :one
SELECT COALESCE(MAX(notification_priority),0) AS maxp FROM user_emails WHERE user_id = ?
`

func (q *Queries) GetMaxNotificationPriority(ctx context.Context, userID int32) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxNotificationPriority, userID)
	var maxp interface{}
	err := row.Scan(&maxp)
	return maxp, err
}

const getNotificationEmailByUserID = `-- name: GetNotificationEmailByUserID :one
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE user_id = ? AND verified_at IS NOT NULL
ORDER BY notification_priority DESC, id
LIMIT 1
`

func (q *Queries) GetNotificationEmailByUserID(ctx context.Context, userID int32) (*UserEmail, error) {
	row := q.db.QueryRowContext(ctx, getNotificationEmailByUserID, userID)
	var i UserEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.VerifiedAt,
		&i.LastVerificationCode,
		&i.VerificationExpiresAt,
		&i.NotificationPriority,
	)
	return &i, err
}

const getUserEmailByCode = `-- name: GetUserEmailByCode :one
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE last_verification_code = ?
`

func (q *Queries) GetUserEmailByCode(ctx context.Context, lastVerificationCode sql.NullString) (*UserEmail, error) {
	row := q.db.QueryRowContext(ctx, getUserEmailByCode, lastVerificationCode)
	var i UserEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.VerifiedAt,
		&i.LastVerificationCode,
		&i.VerificationExpiresAt,
		&i.NotificationPriority,
	)
	return &i, err
}

const getUserEmailByEmail = `-- name: GetUserEmailByEmail :one
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE email = ?
`

func (q *Queries) GetUserEmailByEmail(ctx context.Context, email string) (*UserEmail, error) {
	row := q.db.QueryRowContext(ctx, getUserEmailByEmail, email)
	var i UserEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.VerifiedAt,
		&i.LastVerificationCode,
		&i.VerificationExpiresAt,
		&i.NotificationPriority,
	)
	return &i, err
}

const getUserEmailByID = `-- name: GetUserEmailByID :one
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE id = ?
`

func (q *Queries) GetUserEmailByID(ctx context.Context, id int32) (*UserEmail, error) {
	row := q.db.QueryRowContext(ctx, getUserEmailByID, id)
	var i UserEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.VerifiedAt,
		&i.LastVerificationCode,
		&i.VerificationExpiresAt,
		&i.NotificationPriority,
	)
	return &i, err
}

const insertUserEmail = `-- name: InsertUserEmail :exec
INSERT INTO user_emails (user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority)
VALUES (?, ?, ?, ?, ?, ?)
`

type InsertUserEmailParams struct {
	UserID                int32
	Email                 string
	VerifiedAt            sql.NullTime
	LastVerificationCode  sql.NullString
	VerificationExpiresAt sql.NullTime
	NotificationPriority  int32
}

func (q *Queries) InsertUserEmail(ctx context.Context, arg InsertUserEmailParams) error {
	_, err := q.db.ExecContext(ctx, insertUserEmail,
		arg.UserID,
		arg.Email,
		arg.VerifiedAt,
		arg.LastVerificationCode,
		arg.VerificationExpiresAt,
		arg.NotificationPriority,
	)
	return err
}

const listUserEmailsForLister = `-- name: ListUserEmailsForLister :many
WITH role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT ue.id, ue.user_id, ue.email, ue.verified_at, ue.last_verification_code, ue.verification_expires_at, ue.notification_priority
FROM user_emails ue
WHERE ue.user_id = ?
  AND (
      ? = ue.user_id
      OR EXISTS (
          SELECT 1
          FROM role_ids ri
          JOIN roles r ON r.id = ri.id
          WHERE r.is_admin = 1
      )
  )
`

type ListUserEmailsForListerParams struct {
	ListerID int32
	UserID   int32
}

func (q *Queries) ListUserEmailsForLister(ctx context.Context, arg ListUserEmailsForListerParams) ([]*UserEmail, error) {
	rows, err := q.db.QueryContext(ctx, listUserEmailsForLister, arg.ListerID, arg.UserID, arg.ListerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserEmail
	for rows.Next() {
		var i UserEmail
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.VerifiedAt,
			&i.LastVerificationCode,
			&i.VerificationExpiresAt,
			&i.NotificationPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setNotificationPriorityForLister = `-- name: SetNotificationPriorityForLister :exec
UPDATE user_emails SET notification_priority = ?
WHERE id = ? AND user_id = ?
`

type SetNotificationPriorityForListerParams struct {
	NotificationPriority int32
	ID                   int32
	ListerID             int32
}

func (q *Queries) SetNotificationPriorityForLister(ctx context.Context, arg SetNotificationPriorityForListerParams) error {
	_, err := q.db.ExecContext(ctx, setNotificationPriorityForLister, arg.NotificationPriority, arg.ID, arg.ListerID)
	return err
}

const setVerificationCodeForLister = `-- name: SetVerificationCodeForLister :exec
UPDATE user_emails
SET last_verification_code = ?,
    verification_expires_at = ?
WHERE id = ? AND user_id = ?
`

type SetVerificationCodeForListerParams struct {
	LastVerificationCode  sql.NullString
	VerificationExpiresAt sql.NullTime
	ID                    int32
	ListerID              int32
}

func (q *Queries) SetVerificationCodeForLister(ctx context.Context, arg SetVerificationCodeForListerParams) error {
	_, err := q.db.ExecContext(ctx, setVerificationCodeForLister,
		arg.LastVerificationCode,
		arg.VerificationExpiresAt,
		arg.ID,
		arg.ListerID,
	)
	return err
}

const systemDeleteUserEmailsByEmailExceptID = `-- name: SystemDeleteUserEmailsByEmailExceptID :exec
DELETE FROM user_emails WHERE email = ? AND id != ?
`

type SystemDeleteUserEmailsByEmailExceptIDParams struct {
	Email string
	ID    int32
}

func (q *Queries) SystemDeleteUserEmailsByEmailExceptID(ctx context.Context, arg SystemDeleteUserEmailsByEmailExceptIDParams) error {
	_, err := q.db.ExecContext(ctx, systemDeleteUserEmailsByEmailExceptID, arg.Email, arg.ID)
	return err
}

const systemListVerifiedEmailsByUserID = `-- name: SystemListVerifiedEmailsByUserID :many
SELECT id, user_id, email, verified_at, last_verification_code, verification_expires_at, notification_priority
FROM user_emails
WHERE user_id = ? AND verified_at IS NOT NULL
ORDER BY notification_priority DESC, id
`

func (q *Queries) SystemListVerifiedEmailsByUserID(ctx context.Context, userID int32) ([]*UserEmail, error) {
	rows, err := q.db.QueryContext(ctx, systemListVerifiedEmailsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserEmail
	for rows.Next() {
		var i UserEmail
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.VerifiedAt,
			&i.LastVerificationCode,
			&i.VerificationExpiresAt,
			&i.NotificationPriority,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemMarkUserEmailVerified = `-- name: SystemMarkUserEmailVerified :exec
UPDATE user_emails
SET verified_at = ?, last_verification_code = NULL, verification_expires_at = NULL
WHERE id = ?
`

type SystemMarkUserEmailVerifiedParams struct {
	VerifiedAt sql.NullTime
	ID         int32
}

func (q *Queries) SystemMarkUserEmailVerified(ctx context.Context, arg SystemMarkUserEmailVerifiedParams) error {
	_, err := q.db.ExecContext(ctx, systemMarkUserEmailVerified, arg.VerifiedAt, arg.ID)
	return err
}
