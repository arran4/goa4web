// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-users.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const allUsers = `-- name: AllUsers :many
SELECT u.idusers, u.email, u.username, u.deleted_at
FROM users u
`

// This query selects all admin users from the "users" table.
// Result:
//
//	idusers (int)
//	username (string)
//	email (string)
func (q *Queries) AllUsers(ctx context.Context) ([]*User, error) {
	rows, err := q.db.QueryContext(ctx, allUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Idusers,
			&i.Email,
			&i.Username,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT idusers, email, username
FROM users
WHERE idusers = ?
`

type GetUserByIdRow struct {
	Idusers  int32
	Email    sql.NullString
	Username sql.NullString
}

func (q *Queries) GetUserById(ctx context.Context, idusers int32) (*GetUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserById, idusers)
	var i GetUserByIdRow
	err := row.Scan(&i.Idusers, &i.Email, &i.Username)
	return &i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT idusers, email, username
FROM users
WHERE username = ?
`

type GetUserByUsernameRow struct {
	Idusers  int32
	Email    sql.NullString
	Username sql.NullString
}

func (q *Queries) GetUserByUsername(ctx context.Context, username sql.NullString) (*GetUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(&i.Idusers, &i.Email, &i.Username)
	return &i, err
}

const insertUser = `-- name: InsertUser :execresult
INSERT INTO users (username, email)
VALUES (?, ?)
`

type InsertUserParams struct {
	Username sql.NullString
	Email    sql.NullString
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertUser, arg.Username, arg.Email)
}

const listAdministratorEmails = `-- name: ListAdministratorEmails :many
SELECT u.email
FROM users u
JOIN permissions p ON p.users_idusers = u.idusers
WHERE p.section = 'all' and p.level = 'administrator'
`

func (q *Queries) ListAdministratorEmails(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, listAdministratorEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToBlogs = `-- name: ListUsersSubscribedToBlogs :many
SELECT idblogs, forumthread_id, t.users_idusers, t.language_idlanguage, blog, written, t.deleted_at, idusers, email, username, u.deleted_at, idpreferences, p.language_idlanguage, p.users_idusers, emailforumupdates, page_size, auto_subscribe_replies
FROM blogs t, users u, preferences p
WHERE t.idblogs=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToBlogsParams struct {
	Idblogs int32
	Idusers int32
}

type ListUsersSubscribedToBlogsRow struct {
	Idblogs              int32
	ForumthreadID        int32
	UsersIdusers         int32
	LanguageIdlanguage   int32
	Blog                 sql.NullString
	Written              time.Time
	DeletedAt            sql.NullTime
	Idusers              int32
	Email                sql.NullString
	Username             sql.NullString
	DeletedAt_2          sql.NullTime
	Idpreferences        int32
	LanguageIdlanguage_2 int32
	UsersIdusers_2       int32
	Emailforumupdates    sql.NullBool
	PageSize             int32
	AutoSubscribeReplies bool
}

func (q *Queries) ListUsersSubscribedToBlogs(ctx context.Context, arg ListUsersSubscribedToBlogsParams) ([]*ListUsersSubscribedToBlogsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToBlogs, arg.Idblogs, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToBlogsRow
	for rows.Next() {
		var i ListUsersSubscribedToBlogsRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Blog,
			&i.Written,
			&i.DeletedAt,
			&i.Idusers,
			&i.Email,
			&i.Username,
			&i.DeletedAt_2,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
			&i.AutoSubscribeReplies,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToLinker = `-- name: ListUsersSubscribedToLinker :many
SELECT idlinker, t.language_idlanguage, t.users_idusers, linker_category_id, forumthread_id, title, url, description, listed, t.deleted_at, idusers, email, username, u.deleted_at, idpreferences, p.language_idlanguage, p.users_idusers, emailforumupdates, page_size, auto_subscribe_replies
FROM linker t, users u, preferences p
WHERE t.idlinker=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToLinkerParams struct {
	Idlinker int32
	Idusers  int32
}

type ListUsersSubscribedToLinkerRow struct {
	Idlinker             int32
	LanguageIdlanguage   int32
	UsersIdusers         int32
	LinkerCategoryID     int32
	ForumthreadID        int32
	Title                sql.NullString
	Url                  sql.NullString
	Description          sql.NullString
	Listed               sql.NullTime
	DeletedAt            sql.NullTime
	Idusers              int32
	Email                sql.NullString
	Username             sql.NullString
	DeletedAt_2          sql.NullTime
	Idpreferences        int32
	LanguageIdlanguage_2 int32
	UsersIdusers_2       int32
	Emailforumupdates    sql.NullBool
	PageSize             int32
	AutoSubscribeReplies bool
}

func (q *Queries) ListUsersSubscribedToLinker(ctx context.Context, arg ListUsersSubscribedToLinkerParams) ([]*ListUsersSubscribedToLinkerRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToLinker, arg.Idlinker, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToLinkerRow
	for rows.Next() {
		var i ListUsersSubscribedToLinkerRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.ForumthreadID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.DeletedAt,
			&i.Idusers,
			&i.Email,
			&i.Username,
			&i.DeletedAt_2,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
			&i.AutoSubscribeReplies,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToThread = `-- name: ListUsersSubscribedToThread :many
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage,
    c.written, c.text, u.idusers, u.email, u.username,
    p.idpreferences, p.language_idlanguage, p.users_idusers, p.emailforumupdates, p.page_size, p.auto_subscribe_replies
FROM comments c, users u, preferences p
WHERE c.forumthread_id=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=c.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToThreadParams struct {
	ForumthreadID int32
	Idusers       int32
}

type ListUsersSubscribedToThreadRow struct {
	Idcomments           int32
	ForumthreadID        int32
	UsersIdusers         int32
	LanguageIdlanguage   int32
	Written              sql.NullTime
	Text                 sql.NullString
	Idusers              int32
	Email                sql.NullString
	Username             sql.NullString
	Idpreferences        int32
	LanguageIdlanguage_2 int32
	UsersIdusers_2       int32
	Emailforumupdates    sql.NullBool
	PageSize             int32
	AutoSubscribeReplies bool
}

func (q *Queries) ListUsersSubscribedToThread(ctx context.Context, arg ListUsersSubscribedToThreadParams) ([]*ListUsersSubscribedToThreadRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToThread, arg.ForumthreadID, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToThreadRow
	for rows.Next() {
		var i ListUsersSubscribedToThreadRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.Idusers,
			&i.Email,
			&i.Username,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
			&i.AutoSubscribeReplies,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToWriting = `-- name: ListUsersSubscribedToWriting :many
SELECT idwriting, t.users_idusers, forumthread_id, t.language_idlanguage, writing_category_id, title, published, writing, abstract, private, t.deleted_at, idusers, email, username, u.deleted_at, idpreferences, p.language_idlanguage, p.users_idusers, emailforumupdates, page_size, auto_subscribe_replies
FROM writing t, users u, preferences p
WHERE t.idwriting=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToWritingParams struct {
	Idwriting int32
	Idusers   int32
}

type ListUsersSubscribedToWritingRow struct {
	Idwriting            int32
	UsersIdusers         int32
	ForumthreadID        int32
	LanguageIdlanguage   int32
	WritingCategoryID    int32
	Title                sql.NullString
	Published            sql.NullTime
	Writing              sql.NullString
	Abstract             sql.NullString
	Private              sql.NullBool
	DeletedAt            sql.NullTime
	Idusers              int32
	Email                sql.NullString
	Username             sql.NullString
	DeletedAt_2          sql.NullTime
	Idpreferences        int32
	LanguageIdlanguage_2 int32
	UsersIdusers_2       int32
	Emailforumupdates    sql.NullBool
	PageSize             int32
	AutoSubscribeReplies bool
}

func (q *Queries) ListUsersSubscribedToWriting(ctx context.Context, arg ListUsersSubscribedToWritingParams) ([]*ListUsersSubscribedToWritingRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToWriting, arg.Idwriting, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToWritingRow
	for rows.Next() {
		var i ListUsersSubscribedToWritingRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.Idusers,
			&i.Email,
			&i.Username,
			&i.DeletedAt_2,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
			&i.AutoSubscribeReplies,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const login = `-- name: Login :one
SELECT u.idusers, u.email, p.passwd, p.passwd_algorithm, u.username
FROM users u LEFT JOIN passwords p ON p.users_idusers = u.idusers
WHERE u.username = ?
ORDER BY p.created_at DESC
LIMIT 1
`

type LoginRow struct {
	Idusers         int32
	Email           sql.NullString
	Passwd          sql.NullString
	PasswdAlgorithm sql.NullString
	Username        sql.NullString
}

func (q *Queries) Login(ctx context.Context, username sql.NullString) (*LoginRow, error) {
	row := q.db.QueryRowContext(ctx, login, username)
	var i LoginRow
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.PasswdAlgorithm,
		&i.Username,
	)
	return &i, err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE users
SET email = ?
WHERE idusers = ?
`

type UpdateUserEmailParams struct {
	Email   sql.NullString
	Idusers int32
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) error {
	_, err := q.db.ExecContext(ctx, updateUserEmail, arg.Email, arg.Idusers)
	return err
}

const userByEmail = `-- name: UserByEmail :one
SELECT idusers, email, username
FROM users
WHERE email = ?
`

type UserByEmailRow struct {
	Idusers  int32
	Email    sql.NullString
	Username sql.NullString
}

func (q *Queries) UserByEmail(ctx context.Context, email sql.NullString) (*UserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, userByEmail, email)
	var i UserByEmailRow
	err := row.Scan(&i.Idusers, &i.Email, &i.Username)
	return &i, err
}

const userByUsername = `-- name: UserByUsername :one
SELECT idusers, email, username
FROM users
WHERE username = ?
`

type UserByUsernameRow struct {
	Idusers  int32
	Email    sql.NullString
	Username sql.NullString
}

func (q *Queries) UserByUsername(ctx context.Context, username sql.NullString) (*UserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, userByUsername, username)
	var i UserByUsernameRow
	err := row.Scan(&i.Idusers, &i.Email, &i.Username)
	return &i, err
}
