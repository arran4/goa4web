// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-users.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const adminAllUserIDs = `-- name: AdminAllUserIDs :many
SELECT idusers FROM users ORDER BY idusers
`

func (q *Queries) AdminAllUserIDs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, adminAllUserIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var idusers int32
		if err := rows.Scan(&idusers); err != nil {
			return nil, err
		}
		items = append(items, idusers)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminAllUsers = `-- name: AdminAllUsers :many
SELECT u.idusers, u.username,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email
FROM users u
JOIN user_roles ur ON ur.users_idusers = u.idusers
JOIN roles r ON ur.role_id = r.id
WHERE r.is_admin = 1
`

type AdminAllUsersRow struct {
	Idusers  int32
	Username sql.NullString
	Email    string
}

// Result:
//
//	idusers (int)
//	username (string)
//	email (string)
func (q *Queries) AdminAllUsers(ctx context.Context) ([]*AdminAllUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, adminAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminAllUsersRow
	for rows.Next() {
		var i AdminAllUsersRow
		if err := rows.Scan(&i.Idusers, &i.Username, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListAdministratorEmails = `-- name: AdminListAdministratorEmails :many
const getUserById = `-- name: GetUserById :one
SELECT u.idusers, ue.email, u.username, u.public_profile_enabled_at
FROM users u
LEFT JOIN user_emails ue ON ue.id = (
        SELECT id FROM user_emails ue2
        WHERE ue2.user_id = u.idusers AND ue2.verified_at IS NOT NULL
        ORDER BY ue2.notification_priority DESC, ue2.id LIMIT 1
)
WHERE u.idusers = ?
`

type GetUserByIdRow struct {
	Idusers                int32
	Email                  sql.NullString
	Username               sql.NullString
	PublicProfileEnabledAt sql.NullTime
}

func (q *Queries) GetUserById(ctx context.Context, idusers int32) (*GetUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserById, idusers)
	var i GetUserByIdRow
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Username,
		&i.PublicProfileEnabledAt,
	)
	return &i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT idusers,
       (SELECT email FROM user_emails ue WHERE ue.user_id = users.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email,
       username,
       public_profile_enabled_at
FROM users
WHERE username = ?
`

type GetUserByUsernameRow struct {
	Idusers                int32
	Email                  string
	Username               sql.NullString
	PublicProfileEnabledAt sql.NullTime
}

func (q *Queries) GetUserByUsername(ctx context.Context, username sql.NullString) (*GetUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Username,
		&i.PublicProfileEnabledAt,
	)
	return &i, err
}

const listAdministratorEmails = `-- name: ListAdministratorEmails :many
SELECT (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email
FROM users u
JOIN user_roles ur ON ur.users_idusers = u.idusers
JOIN roles r ON ur.role_id = r.id
WHERE r.is_admin = 1
`

func (q *Queries) AdminListAdministratorEmails(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, adminListAdministratorEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var email string
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListPendingUsers = `-- name: AdminListPendingUsers :many
SELECT u.idusers, u.username,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email
FROM users u
WHERE NOT EXISTS (
    SELECT 1 FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.users_idusers = u.idusers AND (r.can_login = 1 OR r.name = 'rejected')
)
ORDER BY u.idusers
`

type AdminListPendingUsersRow struct {
	Idusers  int32
	Username sql.NullString
	Email    string
}

func (q *Queries) AdminListPendingUsers(ctx context.Context) ([]*AdminListPendingUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListPendingUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListPendingUsersRow
	for rows.Next() {
		var i AdminListPendingUsersRow
		if err := rows.Scan(&i.Idusers, &i.Username, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListUserIDsByRole = `-- name: AdminListUserIDsByRole :many
SELECT u.idusers
FROM users u
JOIN user_roles ur ON ur.users_idusers = u.idusers
JOIN roles r ON ur.role_id = r.id
WHERE r.name = ?
ORDER BY u.idusers
`

func (q *Queries) AdminListUserIDsByRole(ctx context.Context, name string) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, adminListUserIDsByRole, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var idusers int32
		if err := rows.Scan(&idusers); err != nil {
			return nil, err
		}
		items = append(items, idusers)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUsersByID = `-- name: AdminUsersByID :many
SELECT idusers, username
FROM users
WHERE idusers IN (/*SLICE:ids*/?)
`

type AdminUsersByIDRow struct {
	Idusers  int32
	Username sql.NullString
}

func (q *Queries) AdminUsersByID(ctx context.Context, ids []int32) ([]*AdminUsersByIDRow, error) {
	query := adminUsersByID
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminUsersByIDRow
	for rows.Next() {
		var i AdminUsersByIDRow
		if err := rows.Scan(&i.Idusers, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT u.idusers, ue.email, u.username, u.public_profile_enabled_at
FROM users u
LEFT JOIN user_emails ue ON ue.id = (
        SELECT id FROM user_emails ue2
        WHERE ue2.user_id = u.idusers AND ue2.verified_at IS NOT NULL
        ORDER BY ue2.notification_priority DESC, ue2.id LIMIT 1
)
WHERE u.idusers = ?
`

type GetUserByIdRow struct {
	Idusers                int32
	Email                  sql.NullString
	Username               sql.NullString
	PublicProfileEnabledAt sql.NullTime
}

func (q *Queries) GetUserById(ctx context.Context, idusers int32) (*GetUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserById, idusers)
	var i GetUserByIdRow
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Username,
		&i.PublicProfileEnabledAt,
	)
	return &i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT idusers,
       (SELECT email FROM user_emails ue WHERE ue.user_id = users.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email,
       username,
       public_profile_enabled_at
FROM users
WHERE username = ?
`

type GetUserByUsernameRow struct {
	Idusers                int32
	Email                  string
	Username               sql.NullString
	PublicProfileEnabledAt sql.NullTime
}

func (q *Queries) GetUserByUsername(ctx context.Context, username sql.NullString) (*GetUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Username,
		&i.PublicProfileEnabledAt,
	)
	return &i, err
}

const insertUser = `-- name: InsertUser :execresult
INSERT INTO users (username)
VALUES (?)
`

func (q *Queries) InsertUser(ctx context.Context, username sql.NullString) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertUser, username)
}

const login = `-- name: Login :one
SELECT u.idusers,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email,
       p.passwd, p.passwd_algorithm, u.username
FROM users u LEFT JOIN passwords p ON p.users_idusers = u.idusers
WHERE u.username = ?
ORDER BY p.created_at DESC
LIMIT 1
`

type LoginRow struct {
	Idusers         int32
	Email           string
	Passwd          sql.NullString
	PasswdAlgorithm sql.NullString
	Username        sql.NullString
}

func (q *Queries) Login(ctx context.Context, username sql.NullString) (*LoginRow, error) {
	row := q.db.QueryRowContext(ctx, login, username)
	var i LoginRow
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.PasswdAlgorithm,
		&i.Username,
	)
	return &i, err
}

const updatePublicProfileEnabledAtByUserID = `-- name: UpdatePublicProfileEnabledAtByUserID :exec
UPDATE users SET public_profile_enabled_at = ? WHERE idusers = ?
`

type UpdatePublicProfileEnabledAtByUserIDParams struct {
	PublicProfileEnabledAt sql.NullTime
	Idusers                int32
}

func (q *Queries) UpdatePublicProfileEnabledAtByUserID(ctx context.Context, arg UpdatePublicProfileEnabledAtByUserIDParams) error {
	_, err := q.db.ExecContext(ctx, updatePublicProfileEnabledAtByUserID, arg.PublicProfileEnabledAt, arg.Idusers)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE user_emails SET email = ? WHERE user_id = ?
`

type UpdateUserEmailParams struct {
	Email  string
	UserID int32
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) error {
	_, err := q.db.ExecContext(ctx, updateUserEmail, arg.Email, arg.UserID)
	return err
}

const userByEmail = `-- name: UserByEmail :one
SELECT u.idusers, ue.email, u.username
FROM users u JOIN user_emails ue ON ue.user_id = u.idusers
WHERE ue.email = ?
LIMIT 1
`

type UserByEmailRow struct {
	Idusers  int32
	Email    string
	Username sql.NullString
}

func (q *Queries) UserByEmail(ctx context.Context, email string) (*UserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, userByEmail, email)
	var i UserByEmailRow
	err := row.Scan(&i.Idusers, &i.Email, &i.Username)
	return &i, err
}
