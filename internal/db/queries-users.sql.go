// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-users.sql

package db

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const allUserIDs = `-- name: AllUserIDs :many
SELECT idusers FROM users ORDER BY idusers
`

func (q *Queries) AllUserIDs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, allUserIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var idusers int32
		if err := rows.Scan(&idusers); err != nil {
			return nil, err
		}
		items = append(items, idusers)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allUsers = `-- name: AllUsers :many
SELECT u.idusers, u.username,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email
FROM users u
`

type AllUsersRow struct {
	Idusers  int32
	Username sql.NullString
	Email    string
}

// This query selects all admin users from the "users" table.
// Result:
//
//	idusers (int)
//	username (string)
//	email (string)
func (q *Queries) AllUsers(ctx context.Context) ([]*AllUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, allUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AllUsersRow
	for rows.Next() {
		var i AllUsersRow
		if err := rows.Scan(&i.Idusers, &i.Username, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT u.idusers, ue.email, u.username
FROM users u
LEFT JOIN user_emails ue ON ue.id = (
        SELECT id FROM user_emails ue2
        WHERE ue2.user_id = u.idusers AND ue2.verified_at IS NOT NULL
        ORDER BY ue2.notification_priority DESC, ue2.id LIMIT 1
)
WHERE u.idusers = ?
`

type GetUserByIdRow struct {
	Idusers  int32
	Email    sql.NullString
	Username sql.NullString
}

func (q *Queries) GetUserById(ctx context.Context, idusers int32) (*GetUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUserById, idusers)
	var i GetUserByIdRow
	err := row.Scan(&i.Idusers, &i.Email, &i.Username)
	return &i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT idusers,
       (SELECT email FROM user_emails ue WHERE ue.user_id = users.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email,
       username
FROM users
WHERE username = ?
`

type GetUserByUsernameRow struct {
	Idusers  int32
	Email    string
	Username sql.NullString
}

func (q *Queries) GetUserByUsername(ctx context.Context, username sql.NullString) (*GetUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(&i.Idusers, &i.Email, &i.Username)
	return &i, err
}

const insertUser = `-- name: InsertUser :execresult
INSERT INTO users (username)
VALUES (?)
`

func (q *Queries) InsertUser(ctx context.Context, username sql.NullString) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertUser, username)
}

const listAdministratorEmails = `-- name: ListAdministratorEmails :many
SELECT (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email
FROM users u
JOIN user_roles ur ON ur.users_idusers = u.idusers
JOIN roles r ON ur.role_id = r.id
WHERE ur.section = 'all' and r.name = 'administrator'
`

func (q *Queries) ListAdministratorEmails(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAdministratorEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var email string
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingUsers = `-- name: ListPendingUsers :many
SELECT u.idusers, u.username,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email
FROM users u
WHERE NOT EXISTS (
    SELECT 1 FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.users_idusers = u.idusers AND r.name IN ('user','rejected')
)
ORDER BY u.idusers
`

type ListPendingUsersRow struct {
	Idusers  int32
	Username sql.NullString
	Email    string
}

func (q *Queries) ListPendingUsers(ctx context.Context) ([]*ListPendingUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listPendingUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListPendingUsersRow
	for rows.Next() {
		var i ListPendingUsersRow
		if err := rows.Scan(&i.Idusers, &i.Username, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserIDsByRole = `-- name: ListUserIDsByRole :many
SELECT u.idusers
FROM users u
JOIN user_roles ur ON ur.users_idusers = u.idusers
JOIN roles r ON ur.role_id = r.id
WHERE r.name = ?
ORDER BY u.idusers
`

func (q *Queries) ListUserIDsByRole(ctx context.Context, name string) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, listUserIDsByRole, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var idusers int32
		if err := rows.Scan(&idusers); err != nil {
			return nil, err
		}
		items = append(items, idusers)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT u.idusers,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email,
       u.username
FROM users u
ORDER BY u.idusers
LIMIT ? OFFSET ?
`

type ListUsersParams struct {
	Limit  int32
	Offset int32
}

type ListUsersRow struct {
	Idusers  int32
	Email    string
	Username sql.NullString
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]*ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(&i.Idusers, &i.Email, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToBlogs = `-- name: ListUsersSubscribedToBlogs :many
SELECT idblogs, forumthread_id, t.users_idusers, t.language_idlanguage, blog, written, t.deleted_at, last_index, idusers, username, u.deleted_at, idpreferences, p.language_idlanguage, p.users_idusers, emailforumupdates, page_size, auto_subscribe_replies, (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers ORDER BY ue.id LIMIT 1) AS email
FROM blogs t, users u, preferences p
WHERE t.idblogs=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToBlogsParams struct {
	Idblogs int32
	Idusers int32
}

type ListUsersSubscribedToBlogsRow struct {
	Idblogs              int32
	ForumthreadID        sql.NullInt32
	UsersIdusers         int32
	LanguageIdlanguage   int32
	Blog                 sql.NullString
	Written              time.Time
	DeletedAt            sql.NullTime
	LastIndex            sql.NullTime
	Idusers              int32
	Username             sql.NullString
	DeletedAt_2          sql.NullTime
	Idpreferences        int32
	LanguageIdlanguage_2 int32
	UsersIdusers_2       int32
	Emailforumupdates    sql.NullBool
	PageSize             int32
	AutoSubscribeReplies bool
	Email                string
}

func (q *Queries) ListUsersSubscribedToBlogs(ctx context.Context, arg ListUsersSubscribedToBlogsParams) ([]*ListUsersSubscribedToBlogsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToBlogs, arg.Idblogs, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToBlogsRow
	for rows.Next() {
		var i ListUsersSubscribedToBlogsRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Blog,
			&i.Written,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Idusers,
			&i.Username,
			&i.DeletedAt_2,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
			&i.AutoSubscribeReplies,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToLinker = `-- name: ListUsersSubscribedToLinker :many
SELECT idlinker, t.language_idlanguage, t.users_idusers, linker_category_id, forumthread_id, title, url, description, listed, t.deleted_at, last_index, idusers, username, u.deleted_at, idpreferences, p.language_idlanguage, p.users_idusers, emailforumupdates, page_size, auto_subscribe_replies, (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers ORDER BY ue.id LIMIT 1) AS email
FROM linker t, users u, preferences p
WHERE t.idlinker=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToLinkerParams struct {
	Idlinker int32
	Idusers  int32
}

type ListUsersSubscribedToLinkerRow struct {
	Idlinker             int32
	LanguageIdlanguage   int32
	UsersIdusers         int32
	LinkerCategoryID     int32
	ForumthreadID        int32
	Title                sql.NullString
	Url                  sql.NullString
	Description          sql.NullString
	Listed               sql.NullTime
	DeletedAt            sql.NullTime
	LastIndex            sql.NullTime
	Idusers              int32
	Username             sql.NullString
	DeletedAt_2          sql.NullTime
	Idpreferences        int32
	LanguageIdlanguage_2 int32
	UsersIdusers_2       int32
	Emailforumupdates    sql.NullBool
	PageSize             int32
	AutoSubscribeReplies bool
	Email                string
}

func (q *Queries) ListUsersSubscribedToLinker(ctx context.Context, arg ListUsersSubscribedToLinkerParams) ([]*ListUsersSubscribedToLinkerRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToLinker, arg.Idlinker, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToLinkerRow
	for rows.Next() {
		var i ListUsersSubscribedToLinkerRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkerCategoryID,
			&i.ForumthreadID,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Idusers,
			&i.Username,
			&i.DeletedAt_2,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
			&i.AutoSubscribeReplies,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToNews = `-- name: ListUsersSubscribedToNews :many
SELECT idsitenews, forumthread_id, t.language_idlanguage, t.users_idusers,
    news, occurred, u.idusers, u.username, u.deleted_at,
    p.idpreferences, p.language_idlanguage, p.users_idusers, p.emailforumupdates,
    p.page_size, p.auto_subscribe_replies,
    (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers ORDER BY ue.id LIMIT 1) AS email
FROM site_news t, users u, preferences p
WHERE t.idsiteNews=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToNewsParams struct {
	Idsitenews int32
	Idusers    int32
}

type ListUsersSubscribedToNewsRow struct {
	Idsitenews           int32
	ForumthreadID        int32
	LanguageIdlanguage   int32
	UsersIdusers         int32
	News                 sql.NullString
	Occurred             sql.NullTime
	Idusers              int32
	Username             sql.NullString
	DeletedAt            sql.NullTime
	Idpreferences        int32
	LanguageIdlanguage_2 int32
	UsersIdusers_2       int32
	Emailforumupdates    sql.NullBool
	PageSize             int32
	AutoSubscribeReplies bool
	Email                string
}

func (q *Queries) ListUsersSubscribedToNews(ctx context.Context, arg ListUsersSubscribedToNewsParams) ([]*ListUsersSubscribedToNewsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToNews, arg.Idsitenews, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToNewsRow
	for rows.Next() {
		var i ListUsersSubscribedToNewsRow
		if err := rows.Scan(
			&i.Idsitenews,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.News,
			&i.Occurred,
			&i.Idusers,
			&i.Username,
			&i.DeletedAt,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
			&i.AutoSubscribeReplies,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToThread = `-- name: ListUsersSubscribedToThread :many
SELECT c.idcomments, c.forumthread_id, c.users_idusers, c.language_idlanguage,
    c.written, c.text, u.idusers,
    (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers ORDER BY ue.id LIMIT 1) AS email,
    u.username,
    p.idpreferences, p.language_idlanguage, p.users_idusers, p.emailforumupdates, p.page_size, p.auto_subscribe_replies
FROM comments c, users u, preferences p
WHERE c.forumthread_id=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=c.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToThreadParams struct {
	ForumthreadID int32
	Idusers       int32
}

type ListUsersSubscribedToThreadRow struct {
	Idcomments           int32
	ForumthreadID        int32
	UsersIdusers         int32
	LanguageIdlanguage   int32
	Written              sql.NullTime
	Text                 sql.NullString
	Idusers              int32
	Email                string
	Username             sql.NullString
	Idpreferences        int32
	LanguageIdlanguage_2 int32
	UsersIdusers_2       int32
	Emailforumupdates    sql.NullBool
	PageSize             int32
	AutoSubscribeReplies bool
}

func (q *Queries) ListUsersSubscribedToThread(ctx context.Context, arg ListUsersSubscribedToThreadParams) ([]*ListUsersSubscribedToThreadRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToThread, arg.ForumthreadID, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToThreadRow
	for rows.Next() {
		var i ListUsersSubscribedToThreadRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadID,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.Idusers,
			&i.Email,
			&i.Username,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
			&i.AutoSubscribeReplies,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToWriting = `-- name: ListUsersSubscribedToWriting :many
SELECT idwriting, t.users_idusers, forumthread_id, t.language_idlanguage, writing_category_id, title, published, writing, abstract, private, t.deleted_at, last_index, idusers, username, u.deleted_at, idpreferences, p.language_idlanguage, p.users_idusers, emailforumupdates, page_size, auto_subscribe_replies, (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers ORDER BY ue.id LIMIT 1) AS email
FROM writing t, users u, preferences p
WHERE t.idwriting=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToWritingParams struct {
	Idwriting int32
	Idusers   int32
}

type ListUsersSubscribedToWritingRow struct {
	Idwriting            int32
	UsersIdusers         int32
	ForumthreadID        int32
	LanguageIdlanguage   int32
	WritingCategoryID    int32
	Title                sql.NullString
	Published            sql.NullTime
	Writing              sql.NullString
	Abstract             sql.NullString
	Private              sql.NullBool
	DeletedAt            sql.NullTime
	LastIndex            sql.NullTime
	Idusers              int32
	Username             sql.NullString
	DeletedAt_2          sql.NullTime
	Idpreferences        int32
	LanguageIdlanguage_2 int32
	UsersIdusers_2       int32
	Emailforumupdates    sql.NullBool
	PageSize             int32
	AutoSubscribeReplies bool
	Email                string
}

func (q *Queries) ListUsersSubscribedToWriting(ctx context.Context, arg ListUsersSubscribedToWritingParams) ([]*ListUsersSubscribedToWritingRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToWriting, arg.Idwriting, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToWritingRow
	for rows.Next() {
		var i ListUsersSubscribedToWritingRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Idusers,
			&i.Username,
			&i.DeletedAt_2,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
			&i.AutoSubscribeReplies,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const login = `-- name: Login :one
SELECT u.idusers,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email,
       p.passwd, p.passwd_algorithm, u.username
FROM users u LEFT JOIN passwords p ON p.users_idusers = u.idusers
WHERE u.username = ?
ORDER BY p.created_at DESC
LIMIT 1
`

type LoginRow struct {
	Idusers         int32
	Email           string
	Passwd          sql.NullString
	PasswdAlgorithm sql.NullString
	Username        sql.NullString
}

func (q *Queries) Login(ctx context.Context, username sql.NullString) (*LoginRow, error) {
	row := q.db.QueryRowContext(ctx, login, username)
	var i LoginRow
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.PasswdAlgorithm,
		&i.Username,
	)
	return &i, err
}

const searchUsers = `-- name: SearchUsers :many
SELECT u.idusers,
       (SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email,
       u.username
FROM users u
WHERE LOWER(u.username) LIKE LOWER(?) OR LOWER((SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1)) LIKE LOWER(?)
ORDER BY u.idusers
LIMIT ? OFFSET ?
`

type SearchUsersParams struct {
	Pattern string
	Limit   int32
	Offset  int32
}

type SearchUsersRow struct {
	Idusers  int32
	Email    string
	Username sql.NullString
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]*SearchUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, searchUsers,
		arg.Pattern,
		arg.Pattern,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchUsersRow
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(&i.Idusers, &i.Email, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE user_emails SET email = ? WHERE user_id = ?
`

type UpdateUserEmailParams struct {
	Email  string
	UserID int32
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) error {
	_, err := q.db.ExecContext(ctx, updateUserEmail, arg.Email, arg.UserID)
	return err
}

const userByEmail = `-- name: UserByEmail :one
SELECT u.idusers, ue.email, u.username
FROM users u JOIN user_emails ue ON ue.user_id = u.idusers
WHERE ue.email = ?
LIMIT 1
`

type UserByEmailRow struct {
	Idusers  int32
	Email    string
	Username sql.NullString
}

func (q *Queries) UserByEmail(ctx context.Context, email string) (*UserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, userByEmail, email)
	var i UserByEmailRow
	err := row.Scan(&i.Idusers, &i.Email, &i.Username)
	return &i, err
}

const userByUsername = `-- name: UserByUsername :one
SELECT idusers,
       (SELECT email FROM user_emails ue WHERE ue.user_id = users.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1) AS email,
       username
FROM users
WHERE username = ?
`

type UserByUsernameRow struct {
	Idusers  int32
	Email    string
	Username sql.NullString
}

func (q *Queries) UserByUsername(ctx context.Context, username sql.NullString) (*UserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, userByUsername, username)
	var i UserByUsernameRow
	err := row.Scan(&i.Idusers, &i.Email, &i.Username)
	return &i, err
}

const usersByID = `-- name: UsersByID :many
SELECT idusers, username
FROM users
WHERE idusers IN (/*SLICE:ids*/?)
`

type UsersByIDRow struct {
	Idusers  int32
	Username sql.NullString
}

func (q *Queries) UsersByID(ctx context.Context, ids []int32) ([]*UsersByIDRow, error) {
	query := usersByID
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UsersByIDRow
	for rows.Next() {
		var i UsersByIDRow
		if err := rows.Scan(&i.Idusers, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
