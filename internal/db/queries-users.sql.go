// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries-users.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const adminDeleteUserByID = `-- name: AdminDeleteUserByID :exec
DELETE FROM users WHERE idusers = ?
`

func (q *Queries) AdminDeleteUserByID(ctx context.Context, idusers int32) error {
	_, err := q.db.ExecContext(ctx, adminDeleteUserByID, idusers)
	return err
}

const adminListAdministratorEmails = `-- name: AdminListAdministratorEmails :many
SELECT ue.email
FROM users u
JOIN user_roles ur ON ur.users_idusers = u.idusers
JOIN roles r ON ur.role_id = r.id
JOIN user_emails ue ON ue.user_id = u.idusers AND ue.verified_at IS NOT NULL
WHERE r.is_admin = 1
ORDER BY u.idusers, ue.notification_priority DESC, ue.id
`

func (q *Queries) AdminListAdministratorEmails(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, adminListAdministratorEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var email string
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListAllUserIDs = `-- name: AdminListAllUserIDs :many
SELECT idusers FROM users ORDER BY idusers
`

func (q *Queries) AdminListAllUserIDs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, adminListAllUserIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var idusers int32
		if err := rows.Scan(&idusers); err != nil {
			return nil, err
		}
		items = append(items, idusers)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListAllUsers = `-- name: AdminListAllUsers :many
SELECT DISTINCT u.idusers, u.username
FROM users u
JOIN user_roles ur ON ur.users_idusers = u.idusers
JOIN roles r ON ur.role_id = r.id
WHERE r.is_admin = 1
ORDER BY u.username
`

type AdminListAllUsersRow struct {
	Idusers  int32
	Username sql.NullString
}

// Result:
//
//	idusers (int)
//	username (string)
func (q *Queries) AdminListAllUsers(ctx context.Context) ([]*AdminListAllUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListAllUsersRow
	for rows.Next() {
		var i AdminListAllUsersRow
		if err := rows.Scan(&i.Idusers, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListPendingUsers = `-- name: AdminListPendingUsers :many
SELECT u.idusers, u.username
FROM users u
WHERE NOT EXISTS (
    SELECT 1 FROM user_roles ur
    JOIN roles r ON ur.role_id = r.id
    WHERE ur.users_idusers = u.idusers AND (r.can_login = 1 OR r.name = 'rejected')
)
ORDER BY u.idusers
`

type AdminListPendingUsersRow struct {
	Idusers  int32
	Username sql.NullString
}

func (q *Queries) AdminListPendingUsers(ctx context.Context) ([]*AdminListPendingUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListPendingUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListPendingUsersRow
	for rows.Next() {
		var i AdminListPendingUsersRow
		if err := rows.Scan(&i.Idusers, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListUserIDsByRole = `-- name: AdminListUserIDsByRole :many
SELECT u.idusers
FROM users u
JOIN user_roles ur ON ur.users_idusers = u.idusers
JOIN roles r ON ur.role_id = r.id
WHERE r.name = ?
ORDER BY u.idusers
`

func (q *Queries) AdminListUserIDsByRole(ctx context.Context, name string) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, adminListUserIDsByRole, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var idusers int32
		if err := rows.Scan(&idusers); err != nil {
			return nil, err
		}
		items = append(items, idusers)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminListUsersByID = `-- name: AdminListUsersByID :many
SELECT idusers, username
FROM users
WHERE idusers IN (/*SLICE:ids*/?)
`

type AdminListUsersByIDRow struct {
	Idusers  int32
	Username sql.NullString
}

func (q *Queries) AdminListUsersByID(ctx context.Context, ids []int32) ([]*AdminListUsersByIDRow, error) {
	query := adminListUsersByID
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminListUsersByIDRow
	for rows.Next() {
		var i AdminListUsersByIDRow
		if err := rows.Scan(&i.Idusers, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUpdateUserEmail = `-- name: AdminUpdateUserEmail :exec
UPDATE user_emails SET email = ? WHERE user_id = ?
`

type AdminUpdateUserEmailParams struct {
	Email  string
	UserID int32
}

func (q *Queries) AdminUpdateUserEmail(ctx context.Context, arg AdminUpdateUserEmailParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateUserEmail, arg.Email, arg.UserID)
	return err
}

const adminUpdateUsernameByID = `-- name: AdminUpdateUsernameByID :exec
UPDATE users SET username = ? WHERE idusers = ?
`

type AdminUpdateUsernameByIDParams struct {
	Username sql.NullString
	Idusers  int32
}

func (q *Queries) AdminUpdateUsernameByID(ctx context.Context, arg AdminUpdateUsernameByIDParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateUsernameByID, arg.Username, arg.Idusers)
	return err
}

const checkUserHasGrant = `-- name: CheckUserHasGrant :one
SELECT EXISTS(
    SELECT 1
    FROM grants g
    WHERE g.user_id = ?
    AND g.section = ?
    AND g.item = ?
    AND g.action = ?
    AND g.active = 1
)
`

type CheckUserHasGrantParams struct {
	UserID  sql.NullInt32
	Section string
	Item    sql.NullString
	Action  string
}

func (q *Queries) CheckUserHasGrant(ctx context.Context, arg CheckUserHasGrantParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserHasGrant,
		arg.UserID,
		arg.Section,
		arg.Item,
		arg.Action,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const systemGetLogin = `-- name: SystemGetLogin :one
SELECT u.idusers,
       p.passwd, p.passwd_algorithm, u.username
FROM users u LEFT JOIN passwords p ON p.users_idusers = u.idusers
WHERE u.username = ?
ORDER BY p.created_at DESC
LIMIT 1
`

type SystemGetLoginRow struct {
	Idusers         int32
	Passwd          sql.NullString
	PasswdAlgorithm sql.NullString
	Username        sql.NullString
}

func (q *Queries) SystemGetLogin(ctx context.Context, username sql.NullString) (*SystemGetLoginRow, error) {
	row := q.db.QueryRowContext(ctx, systemGetLogin, username)
	var i SystemGetLoginRow
	err := row.Scan(
		&i.Idusers,
		&i.Passwd,
		&i.PasswdAlgorithm,
		&i.Username,
	)
	return &i, err
}

const systemGetUserByEmail = `-- name: SystemGetUserByEmail :one
SELECT u.idusers, ue.email, u.username
FROM users u JOIN user_emails ue ON ue.user_id = u.idusers
WHERE ue.email = ?
LIMIT 1
`

type SystemGetUserByEmailRow struct {
	Idusers  int32
	Email    string
	Username sql.NullString
}

func (q *Queries) SystemGetUserByEmail(ctx context.Context, email string) (*SystemGetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, systemGetUserByEmail, email)
	var i SystemGetUserByEmailRow
	err := row.Scan(&i.Idusers, &i.Email, &i.Username)
	return &i, err
}

const systemGetUserByID = `-- name: SystemGetUserByID :one
SELECT u.idusers, ue.email, u.username, u.public_profile_enabled_at
FROM users u
LEFT JOIN user_emails ue ON ue.id = (
        SELECT id FROM user_emails ue2
        WHERE ue2.user_id = u.idusers AND ue2.verified_at IS NOT NULL
        ORDER BY ue2.notification_priority DESC, ue2.id LIMIT 1
)
WHERE u.idusers = ?
`

type SystemGetUserByIDRow struct {
	Idusers                int32
	Email                  sql.NullString
	Username               sql.NullString
	PublicProfileEnabledAt sql.NullTime
}

func (q *Queries) SystemGetUserByID(ctx context.Context, idusers int32) (*SystemGetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, systemGetUserByID, idusers)
	var i SystemGetUserByIDRow
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Username,
		&i.PublicProfileEnabledAt,
	)
	return &i, err
}

const systemGetUserByUsername = `-- name: SystemGetUserByUsername :one
SELECT idusers,
       username,
       public_profile_enabled_at
FROM users
WHERE username = ?
`

type SystemGetUserByUsernameRow struct {
	Idusers                int32
	Username               sql.NullString
	PublicProfileEnabledAt sql.NullTime
}

func (q *Queries) SystemGetUserByUsername(ctx context.Context, username sql.NullString) (*SystemGetUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, systemGetUserByUsername, username)
	var i SystemGetUserByUsernameRow
	err := row.Scan(&i.Idusers, &i.Username, &i.PublicProfileEnabledAt)
	return &i, err
}

const systemGetUsersByIDs = `-- name: SystemGetUsersByIDs :many
SELECT u.idusers, ue.email, u.username, u.public_profile_enabled_at
FROM users u
LEFT JOIN user_emails ue ON ue.id = (
        SELECT id FROM user_emails ue2
        WHERE ue2.user_id = u.idusers AND ue2.verified_at IS NOT NULL
        ORDER BY ue2.notification_priority DESC, ue2.id LIMIT 1
)
WHERE u.idusers IN (/*SLICE:ids*/?)
`

type SystemGetUsersByIDsRow struct {
	Idusers                int32
	Email                  sql.NullString
	Username               sql.NullString
	PublicProfileEnabledAt sql.NullTime
}

func (q *Queries) SystemGetUsersByIDs(ctx context.Context, ids []int32) ([]*SystemGetUsersByIDsRow, error) {
	query := systemGetUsersByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SystemGetUsersByIDsRow
	for rows.Next() {
		var i SystemGetUsersByIDsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Email,
			&i.Username,
			&i.PublicProfileEnabledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemInsertUser = `-- name: SystemInsertUser :execlastid
INSERT INTO users (username)
VALUES (?)
`

func (q *Queries) SystemInsertUser(ctx context.Context, username sql.NullString) (int64, error) {
	result, err := q.db.ExecContext(ctx, systemInsertUser, username)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const systemListAllUsers = `-- name: SystemListAllUsers :many
SELECT u.idusers, u.username,
       IF(r.id IS NULL, 0, 1) AS admin,
       MIN(s.created_at) AS created_at,
       u.deleted_at
FROM users u
LEFT JOIN user_roles ur ON ur.users_idusers = u.idusers
LEFT JOIN roles r ON ur.role_id = r.id AND r.is_admin = 1
LEFT JOIN sessions s ON s.users_idusers = u.idusers
GROUP BY u.idusers
ORDER BY u.idusers
`

type SystemListAllUsersRow struct {
	Idusers   int32
	Username  sql.NullString
	Admin     interface{}
	CreatedAt interface{}
	DeletedAt sql.NullTime
}

func (q *Queries) SystemListAllUsers(ctx context.Context) ([]*SystemListAllUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, systemListAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SystemListAllUsersRow
	for rows.Next() {
		var i SystemListAllUsersRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Username,
			&i.Admin,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePublicProfileEnabledAtForUser = `-- name: UpdatePublicProfileEnabledAtForUser :exec
UPDATE users u
SET public_profile_enabled_at = ?
WHERE u.idusers = ?
  AND EXISTS (
      SELECT 1 FROM grants g
      WHERE g.section='users'
        AND (g.item='public_profile' OR g.item IS NULL)
        AND g.action='post'
        AND g.active=1
        AND (g.item_id = u.idusers OR g.item_id IS NULL)
        AND (g.user_id = ? OR g.user_id IS NULL)
        AND (g.role_id IS NULL OR g.role_id IN (
            SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
        ))
  )
`

type UpdatePublicProfileEnabledAtForUserParams struct {
	EnabledAt sql.NullTime
	UserID    int32
	GranteeID sql.NullInt32
}

func (q *Queries) UpdatePublicProfileEnabledAtForUser(ctx context.Context, arg UpdatePublicProfileEnabledAtForUserParams) error {
	_, err := q.db.ExecContext(ctx, updatePublicProfileEnabledAtForUser,
		arg.EnabledAt,
		arg.UserID,
		arg.GranteeID,
		arg.UserID,
	)
	return err
}
