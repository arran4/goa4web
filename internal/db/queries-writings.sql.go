// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-writings.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const adminGetAllWritingsByAuthor = `-- name: AdminGetAllWritingsByAuthor :many
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, w.last_index, u.username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_id=w.forumthread_id AND w.forumthread_id != 0) AS Comments
FROM writing w
LEFT JOIN users u ON w.users_idusers = u.idusers
WHERE w.users_idusers = ?
ORDER BY w.published DESC
`

type AdminGetAllWritingsByAuthorRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Username           sql.NullString
	Comments           int64
}

func (q *Queries) AdminGetAllWritingsByAuthor(ctx context.Context, authorID int32) ([]*AdminGetAllWritingsByAuthorRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetAllWritingsByAuthor, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminGetAllWritingsByAuthorRow
	for rows.Next() {
		var i AdminGetAllWritingsByAuthorRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminGetWritingsByCategoryId = `-- name: AdminGetWritingsByCategoryId :many
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, w.last_index, u.username
FROM writing w
LEFT JOIN users u ON w.users_idusers = u.idusers
WHERE w.writing_category_id = ?
ORDER BY w.published DESC
`

type AdminGetWritingsByCategoryIdRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Username           sql.NullString
}

func (q *Queries) AdminGetWritingsByCategoryId(ctx context.Context, writingCategoryID int32) ([]*AdminGetWritingsByCategoryIdRow, error) {
	rows, err := q.db.QueryContext(ctx, adminGetWritingsByCategoryId, writingCategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AdminGetWritingsByCategoryIdRow
	for rows.Next() {
		var i AdminGetWritingsByCategoryIdRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminInsertWritingCategory = `-- name: AdminInsertWritingCategory :exec
INSERT INTO writing_category (writing_category_id, title, description)
VALUES (?, ?, ?)
`

type AdminInsertWritingCategoryParams struct {
	WritingCategoryID int32
	Title             sql.NullString
	Description       sql.NullString
}

func (q *Queries) AdminInsertWritingCategory(ctx context.Context, arg AdminInsertWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, adminInsertWritingCategory, arg.WritingCategoryID, arg.Title, arg.Description)
	return err
}

const adminUpdateWritingCategory = `-- name: AdminUpdateWritingCategory :exec
UPDATE writing_category
SET title = ?, description = ?, writing_category_id = ?
WHERE idwritingCategory = ?
`

type AdminUpdateWritingCategoryParams struct {
	Title             sql.NullString
	Description       sql.NullString
	WritingCategoryID int32
	Idwritingcategory int32
}

func (q *Queries) AdminUpdateWritingCategory(ctx context.Context, arg AdminUpdateWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, adminUpdateWritingCategory,
		arg.Title,
		arg.Description,
		arg.WritingCategoryID,
		arg.Idwritingcategory,
	)
	return err
}

const getAllWritingsByAuthorForLister = `-- name: GetAllWritingsByAuthorForLister :many
WITH RECURSIVE role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, w.last_index, u.username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_id=w.forumthread_id AND w.forumthread_id != 0) AS Comments
FROM writing w
LEFT JOIN users u ON w.users_idusers = u.idusers
WHERE w.users_idusers = ?
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='writing'
      AND g.item='article'
      AND g.action='view'
      AND g.active=1
      AND g.item_id = w.idwriting
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY w.published DESC
`

type GetAllWritingsByAuthorForListerParams struct {
	ListerID      int32
	AuthorID      int32
	ListerMatchID sql.NullInt32
}

type GetAllWritingsByAuthorForListerRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Username           sql.NullString
	Comments           int64
}

func (q *Queries) GetAllWritingsByAuthorForLister(ctx context.Context, arg GetAllWritingsByAuthorForListerParams) ([]*GetAllWritingsByAuthorForListerRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllWritingsByAuthorForLister, arg.ListerID, arg.AuthorID, arg.ListerMatchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllWritingsByAuthorForListerRow
	for rows.Next() {
		var i GetAllWritingsByAuthorForListerRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWritingsForIndex = `-- name: GetAllWritingsForIndex :many
SELECT idwriting, title, abstract, writing FROM writing WHERE deleted_at IS NULL
`

type GetAllWritingsForIndexRow struct {
	Idwriting int32
	Title     sql.NullString
	Abstract  sql.NullString
	Writing   sql.NullString
}

func (q *Queries) GetAllWritingsForIndex(ctx context.Context) ([]*GetAllWritingsForIndexRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllWritingsForIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllWritingsForIndexRow
	for rows.Next() {
		var i GetAllWritingsForIndexRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.Title,
			&i.Abstract,
			&i.Writing,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicWritings = `-- name: GetPublicWritings :many
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, w.last_index
FROM writing w
WHERE w.private = 0
ORDER BY w.published DESC
LIMIT ? OFFSET ?
`

type GetPublicWritingsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetPublicWritings(ctx context.Context, arg GetPublicWritingsParams) ([]*Writing, error) {
	rows, err := q.db.QueryContext(ctx, getPublicWritings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Writing
	for rows.Next() {
		var i Writing
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.LastIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWritingCategoryById = `-- name: GetWritingCategoryById :one
SELECT idwritingcategory, writing_category_id, title, description FROM writing_category WHERE idwritingCategory = ?
`

func (q *Queries) GetWritingCategoryById(ctx context.Context, idwritingcategory int32) (*WritingCategory, error) {
	row := q.db.QueryRowContext(ctx, getWritingCategoryById, idwritingcategory)
	var i WritingCategory
	err := row.Scan(
		&i.Idwritingcategory,
		&i.WritingCategoryID,
		&i.Title,
		&i.Description,
	)
	return &i, err
}

const getWritingForListerByID = `-- name: GetWritingForListerByID :one
WITH RECURSIVE role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, w.last_index, u.idusers AS WriterId, u.Username AS WriterUsername
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
WHERE w.idwriting = ?
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='writing'
      AND g.item='article'
      AND g.action='view'
      AND g.active=1
      AND g.item_id = w.idwriting
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY w.published DESC
`

type GetWritingForListerByIDParams struct {
	ListerID      int32
	Idwriting     int32
	ListerMatchID sql.NullInt32
}

type GetWritingForListerByIDRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Writerid           int32
	Writerusername     sql.NullString
}

func (q *Queries) GetWritingForListerByID(ctx context.Context, arg GetWritingForListerByIDParams) (*GetWritingForListerByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getWritingForListerByID, arg.ListerID, arg.Idwriting, arg.ListerMatchID)
	var i GetWritingForListerByIDRow
	err := row.Scan(
		&i.Idwriting,
		&i.UsersIdusers,
		&i.ForumthreadID,
		&i.LanguageIdlanguage,
		&i.WritingCategoryID,
		&i.Title,
		&i.Published,
		&i.Writing,
		&i.Abstract,
		&i.Private,
		&i.DeletedAt,
		&i.LastIndex,
		&i.Writerid,
		&i.Writerusername,
	)
	return &i, err
}

const insertWriting = `-- name: InsertWriting :execlastid
INSERT INTO writing (writing_category_id, title, abstract, writing, private, language_idlanguage, published, users_idusers)
VALUES (?, ?, ?, ?, ?, ?, NOW(), ?)
`

type InsertWritingParams struct {
	WritingCategoryID  int32
	Title              sql.NullString
	Abstract           sql.NullString
	Writing            sql.NullString
	Private            sql.NullBool
	LanguageIdlanguage int32
	UsersIdusers       int32
}

func (q *Queries) InsertWriting(ctx context.Context, arg InsertWritingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertWriting,
		arg.WritingCategoryID,
		arg.Title,
		arg.Abstract,
		arg.Writing,
		arg.Private,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const listPublicWritingsByUserForLister = `-- name: ListPublicWritingsByUserForLister :many
WITH RECURSIVE role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, w.last_index, u.username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_id=w.forumthread_id AND w.forumthread_id != 0) AS Comments
FROM writing w
LEFT JOIN users u ON w.users_idusers = u.idusers
WHERE w.private = 0 AND w.users_idusers = ?
  AND (
    w.language_idlanguage = 0
    OR w.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = w.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='writing'
      AND (g.item='article' OR g.item IS NULL)
      AND g.action='see'
      AND g.active=1
      AND (g.item_id = w.idwriting OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY w.published DESC
LIMIT ? OFFSET ?
`

type ListPublicWritingsByUserForListerParams struct {
	ListerID int32
	AuthorID int32
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type ListPublicWritingsByUserForListerRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Username           sql.NullString
	Comments           int64
}

func (q *Queries) ListPublicWritingsByUserForLister(ctx context.Context, arg ListPublicWritingsByUserForListerParams) ([]*ListPublicWritingsByUserForListerRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublicWritingsByUserForLister,
		arg.ListerID,
		arg.AuthorID,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListPublicWritingsByUserForListerRow
	for rows.Next() {
		var i ListPublicWritingsByUserForListerRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicWritingsInCategoryForLister = `-- name: ListPublicWritingsInCategoryForLister :many
WITH RECURSIVE role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, w.last_index, u.Username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_id=w.forumthread_id AND w.forumthread_id != 0) as Comments
FROM writing w
LEFT JOIN users u ON w.Users_Idusers=u.idusers
WHERE w.private = 0 AND w.writing_category_id = ?
  AND (
    w.language_idlanguage = 0
    OR w.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = w.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='writing'
      AND (g.item='article' OR g.item IS NULL)
      AND g.action='see'
      AND g.active=1
      AND (g.item_id = w.idwriting OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY w.published DESC
LIMIT ? OFFSET ?
`

type ListPublicWritingsInCategoryForListerParams struct {
	ListerID          int32
	WritingCategoryID int32
	UserID            sql.NullInt32
	Limit             int32
	Offset            int32
}

type ListPublicWritingsInCategoryForListerRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Username           sql.NullString
	Comments           int64
}

func (q *Queries) ListPublicWritingsInCategoryForLister(ctx context.Context, arg ListPublicWritingsInCategoryForListerParams) ([]*ListPublicWritingsInCategoryForListerRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublicWritingsInCategoryForLister,
		arg.ListerID,
		arg.WritingCategoryID,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListPublicWritingsInCategoryForListerRow
	for rows.Next() {
		var i ListPublicWritingsInCategoryForListerRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWritersForLister = `-- name: ListWritersForLister :many
WITH RECURSIVE role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT u.username, COUNT(w.idwriting) AS count
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
WHERE (
    w.language_idlanguage = 0
    OR w.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = w.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
)
AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'writing'
      AND (g.item = 'article' OR g.item IS NULL)
      AND g.action = 'see'
      AND g.active = 1
      AND (g.item_id = w.idwriting OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
GROUP BY u.idusers
ORDER BY u.username
LIMIT ? OFFSET ?
`

type ListWritersForListerParams struct {
	ListerID int32
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type ListWritersForListerRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) ListWritersForLister(ctx context.Context, arg ListWritersForListerParams) ([]*ListWritersForListerRow, error) {
	rows, err := q.db.QueryContext(ctx, listWritersForLister,
		arg.ListerID,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListWritersForListerRow
	for rows.Next() {
		var i ListWritersForListerRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWritersSearchForLister = `-- name: ListWritersSearchForLister :many
WITH RECURSIVE role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT u.username, COUNT(w.idwriting) AS count
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
WHERE (LOWER(u.username) LIKE LOWER(?) OR LOWER((SELECT email FROM user_emails ue WHERE ue.user_id = u.idusers AND ue.verified_at IS NOT NULL ORDER BY ue.notification_priority DESC, ue.id LIMIT 1)) LIKE LOWER(?))
  AND (
    w.language_idlanguage = 0
    OR w.language_idlanguage IS NULL
    OR EXISTS (
        SELECT 1 FROM user_language ul
        WHERE ul.users_idusers = ?
          AND ul.language_idlanguage = w.language_idlanguage
    )
    OR NOT EXISTS (
        SELECT 1 FROM user_language ul WHERE ul.users_idusers = ?
    )
  )
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section = 'writing'
      AND (g.item = 'article' OR g.item IS NULL)
      AND g.action = 'see'
      AND g.active = 1
      AND (g.item_id = w.idwriting OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
GROUP BY u.idusers
ORDER BY u.username
LIMIT ? OFFSET ?
`

type ListWritersSearchForListerParams struct {
	ListerID int32
	Query    string
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type ListWritersSearchForListerRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) ListWritersSearchForLister(ctx context.Context, arg ListWritersSearchForListerParams) ([]*ListWritersSearchForListerRow, error) {
	rows, err := q.db.QueryContext(ctx, listWritersSearchForLister,
		arg.ListerID,
		arg.Query,
		arg.Query,
		arg.ListerID,
		arg.ListerID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListWritersSearchForListerRow
	for rows.Next() {
		var i ListWritersSearchForListerRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWritingCategoriesForLister = `-- name: ListWritingCategoriesForLister :many
WITH RECURSIVE role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT wc.idwritingcategory, wc.writing_category_id, wc.title, wc.description
FROM writing_category wc
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='writing'
      AND (g.item='category' OR g.item IS NULL)
      AND g.action='see'
      AND g.active=1
      AND (g.item_id = wc.idwritingcategory OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
`

type ListWritingCategoriesForListerParams struct {
	ListerID int32
	UserID   sql.NullInt32
}

func (q *Queries) ListWritingCategoriesForLister(ctx context.Context, arg ListWritingCategoriesForListerParams) ([]*WritingCategory, error) {
	rows, err := q.db.QueryContext(ctx, listWritingCategoriesForLister, arg.ListerID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WritingCategory
	for rows.Next() {
		var i WritingCategory
		if err := rows.Scan(
			&i.Idwritingcategory,
			&i.WritingCategoryID,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWritingsByIDsForLister = `-- name: ListWritingsByIDsForLister :many
WITH RECURSIVE role_ids(id) AS (
    SELECT DISTINCT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
)
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, w.last_index, u.idusers AS WriterId, u.username AS WriterUsername
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
WHERE w.idwriting IN (/*SLICE:writing_ids*/?)
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='writing'
      AND g.item='article'
      AND g.action='view'
      AND g.active=1
      AND g.item_id = w.idwriting
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY w.published DESC
`

type ListWritingsByIDsForListerParams struct {
	ListerID      int32
	WritingIds    []int32
	ListerMatchID sql.NullInt32
}

type ListWritingsByIDsForListerRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Writerid           int32
	Writerusername     sql.NullString
}

func (q *Queries) ListWritingsByIDsForLister(ctx context.Context, arg ListWritingsByIDsForListerParams) ([]*ListWritingsByIDsForListerRow, error) {
	query := listWritingsByIDsForLister
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ListerID)
	if len(arg.WritingIds) > 0 {
		for _, v := range arg.WritingIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:writing_ids*/?", strings.Repeat(",?", len(arg.WritingIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:writing_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.ListerMatchID)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListWritingsByIDsForListerRow
	for rows.Next() {
		var i ListWritingsByIDsForListerRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Writerid,
			&i.Writerusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemAssignWritingThreadID = `-- name: SystemAssignWritingThreadID :exec
UPDATE writing SET forumthread_id = ? WHERE idwriting = ?
`

type SystemAssignWritingThreadIDParams struct {
	ForumthreadID int32
	Idwriting     int32
}

func (q *Queries) SystemAssignWritingThreadID(ctx context.Context, arg SystemAssignWritingThreadIDParams) error {
	_, err := q.db.ExecContext(ctx, systemAssignWritingThreadID, arg.ForumthreadID, arg.Idwriting)
	return err
}

const systemListPublicWritingsByAuthor = `-- name: SystemListPublicWritingsByAuthor :many
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, w.last_index, u.username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_id=w.forumthread_id AND w.forumthread_id != 0) AS Comments
FROM writing w
LEFT JOIN users u ON w.users_idusers = u.idusers
WHERE w.private = 0 AND w.users_idusers = ?
ORDER BY w.published DESC
LIMIT ? OFFSET ?
`

type SystemListPublicWritingsByAuthorParams struct {
	AuthorID int32
	Limit    int32
	Offset   int32
}

type SystemListPublicWritingsByAuthorRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Username           sql.NullString
	Comments           int64
}

func (q *Queries) SystemListPublicWritingsByAuthor(ctx context.Context, arg SystemListPublicWritingsByAuthorParams) ([]*SystemListPublicWritingsByAuthorRow, error) {
	rows, err := q.db.QueryContext(ctx, systemListPublicWritingsByAuthor, arg.AuthorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SystemListPublicWritingsByAuthorRow
	for rows.Next() {
		var i SystemListPublicWritingsByAuthorRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemListPublicWritingsInCategory = `-- name: SystemListPublicWritingsInCategory :many
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, w.last_index, u.Username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_id=w.forumthread_id AND w.forumthread_id != 0) as Comments
FROM writing w
LEFT JOIN users u ON w.Users_Idusers = u.idusers
WHERE w.private = 0 AND w.writing_category_id = ?
ORDER BY w.published DESC
LIMIT ? OFFSET ?
`

type SystemListPublicWritingsInCategoryParams struct {
	CategoryID int32
	Limit      int32
	Offset     int32
}

type SystemListPublicWritingsInCategoryRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	LastIndex          sql.NullTime
	Username           sql.NullString
	Comments           int64
}

func (q *Queries) SystemListPublicWritingsInCategory(ctx context.Context, arg SystemListPublicWritingsInCategoryParams) ([]*SystemListPublicWritingsInCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, systemListPublicWritingsInCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SystemListPublicWritingsInCategoryRow
	for rows.Next() {
		var i SystemListPublicWritingsInCategoryRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.LastIndex,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemListWritingCategories = `-- name: SystemListWritingCategories :many
SELECT wc.idwritingcategory, wc.writing_category_id, wc.title, wc.description
FROM writing_category wc
ORDER BY wc.idwritingcategory
LIMIT ? OFFSET ?
`

type SystemListWritingCategoriesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) SystemListWritingCategories(ctx context.Context, arg SystemListWritingCategoriesParams) ([]*WritingCategory, error) {
	rows, err := q.db.QueryContext(ctx, systemListWritingCategories, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WritingCategory
	for rows.Next() {
		var i WritingCategory
		if err := rows.Scan(
			&i.Idwritingcategory,
			&i.WritingCategoryID,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const systemSetWritingLastIndex = `-- name: SystemSetWritingLastIndex :exec
UPDATE writing SET last_index = NOW() WHERE idwriting = ?
`

func (q *Queries) SystemSetWritingLastIndex(ctx context.Context, idwriting int32) error {
	_, err := q.db.ExecContext(ctx, systemSetWritingLastIndex, idwriting)
	return err
}

const updateWritingForWriter = `-- name: UpdateWritingForWriter :exec
UPDATE writing w
SET title = ?,
    abstract = ?,
    writing = ?,
    private = ?,
    language_idlanguage = ?
WHERE w.idwriting = ?
  AND w.users_idusers = ?
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='writing'
      AND (g.item='article' OR g.item IS NULL)
      AND g.action='post'
      AND g.active=1
      AND (g.item_id = w.idwriting OR g.item_id IS NULL)
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (
          SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
      ))
  )
`

type UpdateWritingForWriterParams struct {
	Title      sql.NullString
	Abstract   sql.NullString
	Content    sql.NullString
	Private    sql.NullBool
	LanguageID int32
	WritingID  int32
	WriterID   int32
	GranteeID  sql.NullInt32
}

func (q *Queries) UpdateWritingForWriter(ctx context.Context, arg UpdateWritingForWriterParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingForWriter,
		arg.Title,
		arg.Abstract,
		arg.Content,
		arg.Private,
		arg.LanguageID,
		arg.WritingID,
		arg.WriterID,
		arg.GranteeID,
		arg.WriterID,
	)
	return err
}
