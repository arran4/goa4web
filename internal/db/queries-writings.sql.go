// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-writings.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const assignWritingThisThreadId = `-- name: AssignWritingThisThreadId :exec
UPDATE writing SET forumthread_id = ? WHERE idwriting = ?
`

type AssignWritingThisThreadIdParams struct {
	ForumthreadID int32
	Idwriting     int32
}

func (q *Queries) AssignWritingThisThreadId(ctx context.Context, arg AssignWritingThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignWritingThisThreadId, arg.ForumthreadID, arg.Idwriting)
	return err
}

const createWritingApproval = `-- name: CreateWritingApproval :exec
INSERT INTO writing_user_permissions (writing_id, users_idusers, can_read, can_edit)
VALUES (?, ?, ?, ?)
`

type CreateWritingApprovalParams struct {
	WritingID    int32
	UsersIdusers int32
	CanRead      sql.NullBool
	CanEdit      sql.NullBool
}

func (q *Queries) CreateWritingApproval(ctx context.Context, arg CreateWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, createWritingApproval,
		arg.WritingID,
		arg.UsersIdusers,
		arg.CanRead,
		arg.CanEdit,
	)
	return err
}

const deleteWritingApproval = `-- name: DeleteWritingApproval :exec
DELETE FROM writing_user_permissions
WHERE writing_id = ? AND users_idusers = ?
`

type DeleteWritingApprovalParams struct {
	WritingID    int32
	UsersIdusers int32
}

func (q *Queries) DeleteWritingApproval(ctx context.Context, arg DeleteWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, deleteWritingApproval, arg.WritingID, arg.UsersIdusers)
	return err
}

const fetchAllCategories = `-- name: FetchAllCategories :many
SELECT wc.idwritingcategory, wc.writing_category_id, wc.title, wc.description
FROM writing_category wc
`

func (q *Queries) FetchAllCategories(ctx context.Context) ([]*WritingCategory, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WritingCategory
	for rows.Next() {
		var i WritingCategory
		if err := rows.Scan(
			&i.Idwritingcategory,
			&i.WritingCategoryID,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchCategoriesForUser = `-- name: FetchCategoriesForUser :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT wc.idwritingcategory, wc.writing_category_id, wc.title, wc.description
FROM writing_category wc
WHERE EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='writing'
      AND g.item='category'
      AND g.action='see'
      AND g.active=1
      AND g.item_id = wc.idwritingcategory
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
)
`

type FetchCategoriesForUserParams struct {
	ViewerID int32
	UserID   sql.NullInt32
}

func (q *Queries) FetchCategoriesForUser(ctx context.Context, arg FetchCategoriesForUserParams) ([]*WritingCategory, error) {
	rows, err := q.db.QueryContext(ctx, fetchCategoriesForUser, arg.ViewerID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WritingCategory
	for rows.Next() {
		var i WritingCategory
		if err := rows.Scan(
			&i.Idwritingcategory,
			&i.WritingCategoryID,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWritingApprovals = `-- name: GetAllWritingApprovals :many
SELECT idusers, u.username, wau.writing_id, wau.users_idusers, wau.can_read, wau.can_edit
FROM writing_user_permissions wau
LEFT JOIN users u ON idusers = wau.users_idusers
`

type GetAllWritingApprovalsRow struct {
	Idusers      sql.NullInt32
	Username     sql.NullString
	WritingID    int32
	UsersIdusers int32
	CanRead      sql.NullBool
	CanEdit      sql.NullBool
}

func (q *Queries) GetAllWritingApprovals(ctx context.Context) ([]*GetAllWritingApprovalsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllWritingApprovals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllWritingApprovalsRow
	for rows.Next() {
		var i GetAllWritingApprovalsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Username,
			&i.WritingID,
			&i.UsersIdusers,
			&i.CanRead,
			&i.CanEdit,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWritingCategories = `-- name: GetAllWritingCategories :many
SELECT idwritingcategory, writing_category_id, title, description
FROM writing_category
WHERE writing_category_id = ?
`

func (q *Queries) GetAllWritingCategories(ctx context.Context, writingCategoryID int32) ([]*WritingCategory, error) {
	rows, err := q.db.QueryContext(ctx, getAllWritingCategories, writingCategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WritingCategory
	for rows.Next() {
		var i WritingCategory
		if err := rows.Scan(
			&i.Idwritingcategory,
			&i.WritingCategoryID,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWritingsByUser = `-- name: GetAllWritingsByUser :many
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, u.username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_id=w.forumthread_id AND w.forumthread_id != 0) AS Comments
FROM writing w
LEFT JOIN users u ON w.users_idusers = u.idusers
WHERE w.users_idusers = ?
ORDER BY w.published DESC
`

type GetAllWritingsByUserRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	Username           sql.NullString
	Comments           int64
}

func (q *Queries) GetAllWritingsByUser(ctx context.Context, usersIdusers int32) ([]*GetAllWritingsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllWritingsByUser, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllWritingsByUserRow
	for rows.Next() {
		var i GetAllWritingsByUserRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicWritings = `-- name: GetPublicWritings :many
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at
FROM writing w
WHERE w.private = 0
ORDER BY w.published DESC
LIMIT ? OFFSET ?
`

type GetPublicWritingsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetPublicWritings(ctx context.Context, arg GetPublicWritingsParams) ([]*Writing, error) {
	rows, err := q.db.QueryContext(ctx, getPublicWritings, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Writing
	for rows.Next() {
		var i Writing
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicWritingsByUser = `-- name: GetPublicWritingsByUser :many
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, u.username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_id=w.forumthread_id AND w.forumthread_id != 0) AS Comments
FROM writing w
LEFT JOIN users u ON w.users_idusers = u.idusers
WHERE w.private = 0 AND w.users_idusers = ?
ORDER BY w.published DESC
LIMIT ? OFFSET ?
`

type GetPublicWritingsByUserParams struct {
	UsersIdusers int32
	Limit        int32
	Offset       int32
}

type GetPublicWritingsByUserRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	Username           sql.NullString
	Comments           int64
}

func (q *Queries) GetPublicWritingsByUser(ctx context.Context, arg GetPublicWritingsByUserParams) ([]*GetPublicWritingsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getPublicWritingsByUser, arg.UsersIdusers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPublicWritingsByUserRow
	for rows.Next() {
		var i GetPublicWritingsByUserRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicWritingsByUserForViewer = `-- name: GetPublicWritingsByUserForViewer :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, u.username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_id=w.forumthread_id AND w.forumthread_id != 0) AS Comments
FROM writing w
LEFT JOIN users u ON w.users_idusers = u.idusers
WHERE w.private = 0 AND w.users_idusers = ?
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='writing'
      AND g.item='article'
      AND g.action='see'
      AND g.active=1
      AND g.item_id = w.idwriting
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY w.published DESC
LIMIT ? OFFSET ?
`

type GetPublicWritingsByUserForViewerParams struct {
	ViewerID int32
	AuthorID int32
	UserID   sql.NullInt32
	Limit    int32
	Offset   int32
}

type GetPublicWritingsByUserForViewerRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	Username           sql.NullString
	Comments           int64
}

func (q *Queries) GetPublicWritingsByUserForViewer(ctx context.Context, arg GetPublicWritingsByUserForViewerParams) ([]*GetPublicWritingsByUserForViewerRow, error) {
	rows, err := q.db.QueryContext(ctx, getPublicWritingsByUserForViewer,
		arg.ViewerID,
		arg.AuthorID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPublicWritingsByUserForViewerRow
	for rows.Next() {
		var i GetPublicWritingsByUserForViewerRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicWritingsInCategory = `-- name: GetPublicWritingsInCategory :many
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, u.Username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_id=w.forumthread_id AND w.forumthread_id != 0) as Comments
FROM writing w
LEFT JOIN users u ON w.Users_Idusers=u.idusers
WHERE w.private = 0 AND w.writing_category_id=?
ORDER BY w.published DESC
LIMIT ? OFFSET ?
`

type GetPublicWritingsInCategoryParams struct {
	WritingCategoryID int32
	Limit             int32
	Offset            int32
}

type GetPublicWritingsInCategoryRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	Username           sql.NullString
	Comments           int64
}

func (q *Queries) GetPublicWritingsInCategory(ctx context.Context, arg GetPublicWritingsInCategoryParams) ([]*GetPublicWritingsInCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getPublicWritingsInCategory, arg.WritingCategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPublicWritingsInCategoryRow
	for rows.Next() {
		var i GetPublicWritingsInCategoryRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublicWritingsInCategoryForUser = `-- name: GetPublicWritingsInCategoryForUser :many
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, u.Username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_id=w.forumthread_id AND w.forumthread_id != 0) as Comments
FROM writing w
LEFT JOIN users u ON w.Users_Idusers=u.idusers
WHERE w.private = 0 AND w.writing_category_id = ?
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='writing'
      AND g.item='article'
      AND g.action='see'
      AND g.active=1
      AND g.item_id = w.idwriting
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY w.published DESC
LIMIT ? OFFSET ?
`

type GetPublicWritingsInCategoryForUserParams struct {
	ViewerID          int32
	WritingCategoryID int32
	UserID            sql.NullInt32
	Limit             int32
	Offset            int32
}

type GetPublicWritingsInCategoryForUserRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	Username           sql.NullString
	Comments           int64
}

func (q *Queries) GetPublicWritingsInCategoryForUser(ctx context.Context, arg GetPublicWritingsInCategoryForUserParams) ([]*GetPublicWritingsInCategoryForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getPublicWritingsInCategoryForUser,
		arg.ViewerID,
		arg.WritingCategoryID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPublicWritingsInCategoryForUserRow
	for rows.Next() {
		var i GetPublicWritingsInCategoryForUserRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWritingByIdForUserDescendingByPublishedDate = `-- name: GetWritingByIdForUserDescendingByPublishedDate :one
WITH RECURSIVE role_ids(id) AS (
    SELECT ur.role_id FROM user_roles ur WHERE ur.users_idusers = ?
    UNION
    SELECT r2.id
    FROM role_ids ri
    JOIN grants g ON g.role_id = ri.id AND g.section = 'role' AND g.active = 1
    JOIN roles r2 ON r2.name = g.action
)
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, u.idusers AS WriterId, u.Username AS WriterUsername
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN writing_user_permissions wau ON w.idwriting = wau.writing_id AND wau.users_idusers = ?
WHERE w.idwriting = ? AND (w.private = 0 OR wau.can_read = 1 OR w.users_idusers = ?)
  AND EXISTS (
    SELECT 1 FROM grants g
    WHERE g.section='writing'
      AND g.item='article'
      AND g.action='view'
      AND g.active=1
      AND g.item_id = w.idwriting
      AND (g.user_id = ? OR g.user_id IS NULL)
      AND (g.role_id IS NULL OR g.role_id IN (SELECT id FROM role_ids))
  )
ORDER BY w.published DESC
`

type GetWritingByIdForUserDescendingByPublishedDateParams struct {
	Userid    int32
	Idwriting int32
	UserID    sql.NullInt32
}

type GetWritingByIdForUserDescendingByPublishedDateRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	Writerid           int32
	Writerusername     sql.NullString
}

func (q *Queries) GetWritingByIdForUserDescendingByPublishedDate(ctx context.Context, arg GetWritingByIdForUserDescendingByPublishedDateParams) (*GetWritingByIdForUserDescendingByPublishedDateRow, error) {
	row := q.db.QueryRowContext(ctx, getWritingByIdForUserDescendingByPublishedDate,
		arg.Userid,
		arg.Userid,
		arg.Idwriting,
		arg.Userid,
		arg.UserID,
	)
	var i GetWritingByIdForUserDescendingByPublishedDateRow
	err := row.Scan(
		&i.Idwriting,
		&i.UsersIdusers,
		&i.ForumthreadID,
		&i.LanguageIdlanguage,
		&i.WritingCategoryID,
		&i.Title,
		&i.Published,
		&i.Writing,
		&i.Abstract,
		&i.Private,
		&i.DeletedAt,
		&i.Writerid,
		&i.Writerusername,
	)
	return &i, err
}

const getWritingsByIdsForUserDescendingByPublishedDate = `-- name: GetWritingsByIdsForUserDescendingByPublishedDate :many
SELECT w.idwriting, w.users_idusers, w.forumthread_id, w.language_idlanguage, w.writing_category_id, w.title, w.published, w.writing, w.abstract, w.private, w.deleted_at, u.idusers AS WriterId, u.username AS WriterUsername
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN writing_user_permissions wau ON w.idwriting = wau.writing_id AND wau.users_idusers = ?
WHERE w.idwriting IN (/*SLICE:writingids*/?) AND (w.private = 0 OR wau.readdoc = 1 OR w.users_idusers = ?)
ORDER BY w.published DESC
`

type GetWritingsByIdsForUserDescendingByPublishedDateParams struct {
	Userid     int32
	Writingids []int32
}

type GetWritingsByIdsForUserDescendingByPublishedDateRow struct {
	Idwriting          int32
	UsersIdusers       int32
	ForumthreadID      int32
	LanguageIdlanguage int32
	WritingCategoryID  int32
	Title              sql.NullString
	Published          sql.NullTime
	Writing            sql.NullString
	Abstract           sql.NullString
	Private            sql.NullBool
	DeletedAt          sql.NullTime
	Writerid           int32
	Writerusername     sql.NullString
}

func (q *Queries) GetWritingsByIdsForUserDescendingByPublishedDate(ctx context.Context, arg GetWritingsByIdsForUserDescendingByPublishedDateParams) ([]*GetWritingsByIdsForUserDescendingByPublishedDateRow, error) {
	query := getWritingsByIdsForUserDescendingByPublishedDate
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Userid)
	if len(arg.Writingids) > 0 {
		for _, v := range arg.Writingids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:writingids*/?", strings.Repeat(",?", len(arg.Writingids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:writingids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Userid)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetWritingsByIdsForUserDescendingByPublishedDateRow
	for rows.Next() {
		var i GetWritingsByIdsForUserDescendingByPublishedDateRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadID,
			&i.LanguageIdlanguage,
			&i.WritingCategoryID,
			&i.Title,
			&i.Published,
			&i.Writing,
			&i.Abstract,
			&i.Private,
			&i.DeletedAt,
			&i.Writerid,
			&i.Writerusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertWriting = `-- name: InsertWriting :execlastid
INSERT INTO writing (writing_category_id, title, abstract, writing, private, language_idlanguage, published, users_idusers)
VALUES (?, ?, ?, ?, ?, ?, NOW(), ?)
`

type InsertWritingParams struct {
	WritingCategoryID  int32
	Title              sql.NullString
	Abstract           sql.NullString
	Writing            sql.NullString
	Private            sql.NullBool
	LanguageIdlanguage int32
	UsersIdusers       int32
}

func (q *Queries) InsertWriting(ctx context.Context, arg InsertWritingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertWriting,
		arg.WritingCategoryID,
		arg.Title,
		arg.Abstract,
		arg.Writing,
		arg.Private,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertWritingCategory = `-- name: InsertWritingCategory :exec
INSERT INTO writing_category (writing_category_id, title, description)
VALUES (?, ?, ?)
`

type InsertWritingCategoryParams struct {
	WritingCategoryID int32
	Title             sql.NullString
	Description       sql.NullString
}

func (q *Queries) InsertWritingCategory(ctx context.Context, arg InsertWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, insertWritingCategory, arg.WritingCategoryID, arg.Title, arg.Description)
	return err
}

const updateWriting = `-- name: UpdateWriting :exec
UPDATE writing
SET title = ?, abstract = ?, writing = ?, private = ?, language_idlanguage = ?
WHERE idwriting = ?
`

type UpdateWritingParams struct {
	Title              sql.NullString
	Abstract           sql.NullString
	Writing            sql.NullString
	Private            sql.NullBool
	LanguageIdlanguage int32
	Idwriting          int32
}

func (q *Queries) UpdateWriting(ctx context.Context, arg UpdateWritingParams) error {
	_, err := q.db.ExecContext(ctx, updateWriting,
		arg.Title,
		arg.Abstract,
		arg.Writing,
		arg.Private,
		arg.LanguageIdlanguage,
		arg.Idwriting,
	)
	return err
}

const updateWritingApproval = `-- name: UpdateWritingApproval :exec
UPDATE writing_user_permissions
SET can_read = ?, can_edit = ?
WHERE writing_id = ? AND users_idusers = ?
`

type UpdateWritingApprovalParams struct {
	CanRead      sql.NullBool
	CanEdit      sql.NullBool
	WritingID    int32
	UsersIdusers int32
}

func (q *Queries) UpdateWritingApproval(ctx context.Context, arg UpdateWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingApproval,
		arg.CanRead,
		arg.CanEdit,
		arg.WritingID,
		arg.UsersIdusers,
	)
	return err
}

const updateWritingCategory = `-- name: UpdateWritingCategory :exec
UPDATE writing_category
SET title = ?, description = ?, writing_category_id = ?
WHERE idwritingCategory = ?
`

type UpdateWritingCategoryParams struct {
	Title             sql.NullString
	Description       sql.NullString
	WritingCategoryID int32
	Idwritingcategory int32
}

func (q *Queries) UpdateWritingCategory(ctx context.Context, arg UpdateWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingCategory,
		arg.Title,
		arg.Description,
		arg.WritingCategoryID,
		arg.Idwritingcategory,
	)
	return err
}
