From dafdc93be5e56ed9568bb1e17fd78976c245d73f Mon Sep 17 00:00:00 2001
From: "google-labs-jules[bot]"
 <161369871+google-labs-jules[bot]@users.noreply.github.com>
Date: Wed, 28 Jan 2026 09:37:35 +0000
Subject: [PATCH] Refactor image signing verification and generation

- Updated `verifyMiddleware` in `handlers/images/routes.go` to support path-based signatures with timestamps/nonces, falling back to legacy prefix-based signatures.
- Updated `CoreData.SignImageURL` and `SignCacheURL` in `core/common/signing.go` to sign the URL path instead of custom string, ensuring compatibility with the new verification logic.
- Added `TestSignImageURL_EndToEnd` to verify the new signing and verification flow.
- Removed unused imports.

Co-authored-by: arran4 <111667+arran4@users.noreply.github.com>
---
 core/common/signing.go         | 19 ++++--------
 handlers/images/routes.go      | 48 ++++++++++++++++++-----------
 handlers/images/routes_test.go | 56 ++++++++++++++++++++++++++++++++++
 3 files changed, 92 insertions(+), 31 deletions(-)

diff --git a/core/common/signing.go b/core/common/signing.go
index c2d022ad5..5769eb817 100644
--- a/core/common/signing.go
+++ b/core/common/signing.go
@@ -41,28 +41,21 @@ func (cd *CoreData) SignImageURL(imageRef string, ttl time.Duration) string {
	// Strip image: or img: prefix if present
	imageRef = strings.TrimPrefix(strings.TrimPrefix(imageRef, "image:"), "img:")

-	data := "image:" + imageRef
+	path := "/images/image/" + imageRef
	expiry := time.Now().Add(ttl)

-	sig := sign.Sign(data, cd.ImageSignKey, sign.WithExpiry(expiry))
-
-	// Add signature as query param
-	path := "/images/image/" + imageRef
-	fullURL := strings.TrimSuffix(cd.Config.HTTPHostname, "/") + "/" + strings.TrimPrefix(path, "/")
-	signedURL, _ := sign.AddQuerySig(fullURL, sig, sign.WithExpiry(expiry))
+	fullURL := strings.TrimSuffix(cd.Config.HTTPHostname, "/") + path
+	signedURL, _ := signutil.SignAndAddQuery(fullURL, path, cd.ImageSignKey, sign.WithExpiry(expiry))
	return signedURL
 }

 // SignCacheURL signs a cache URL with the given TTL.
 func (cd *CoreData) SignCacheURL(cacheRef string, ttl time.Duration) string {
-	data := "cache:" + cacheRef
+	path := "/images/cache/" + cacheRef
	expiry := time.Now().Add(ttl)

-	sig := sign.Sign(data, cd.ImageSignKey, sign.WithExpiry(expiry))
-
-	path := "/images/cache/" + cacheRef
-	fullURL := strings.TrimSuffix(cd.Config.HTTPHostname, "/") + "/" + strings.TrimPrefix(path, "/")
-	signedURL, _ := sign.AddQuerySig(fullURL, sig, sign.WithExpiry(expiry))
+	fullURL := strings.TrimSuffix(cd.Config.HTTPHostname, "/") + path
+	signedURL, _ := signutil.SignAndAddQuery(fullURL, path, cd.ImageSignKey, sign.WithExpiry(expiry))
	return signedURL
 }

diff --git a/handlers/images/routes.go b/handlers/images/routes.go
index 84d56e238..20b5299fc 100644
--- a/handlers/images/routes.go
+++ b/handlers/images/routes.go
@@ -4,9 +4,9 @@ import (
	"bytes"
	"fmt"
	"net/http"
-	"net/url"
	"path"
	"path/filepath"
+	"strconv"
	"time"

	"github.com/gorilla/mux"
@@ -32,26 +32,38 @@ func verifyMiddleware(prefix string) mux.MiddlewareFunc {
				return
			}

-			cleanURL, sig, opts, err := sign.ExtractQuerySig(r.URL.String())
-			if err != nil || sig == "" {
-				w.WriteHeader(http.StatusForbidden)
-				handlers.RenderErrorPage(w, r, fmt.Errorf("missing or invalid signature"))
-				return
-			}
+			query := r.URL.Query()
+			sig := query.Get("sig")
+			tsStr := query.Get("ts")
+			nonce := query.Get("nonce")

-			u, err := url.Parse(cleanURL)
-			if err != nil {
-				w.WriteHeader(http.StatusForbidden)
-				handlers.RenderErrorPage(w, r, fmt.Errorf("invalid url"))
-				return
-			}
+			cd := r.Context().Value(consts.KeyCoreData).(*common.CoreData)

-			data := prefix + id
-			if q := u.Query().Encode(); q != "" {
-				data += "?" + q
+			var err error
+			if tsStr != "" || nonce != "" {
+				var opts []sign.SignOption
+				if tsStr != "" {
+					ts, _ := strconv.ParseInt(tsStr, 10, 64)
+					opts = append(opts, sign.WithExpiry(time.Unix(ts, 0)))
+				}
+				if nonce != "" {
+					opts = append(opts, sign.WithNonce(nonce))
+				}
+				err = sign.Verify(r.URL.Path, sig, cd.ImageSignKey, opts...)
+			} else {
+				query.Del("ts")
+				query.Del("sig")
+				data := id
+				if encoded := query.Encode(); encoded != "" {
+					data = data + "?" + encoded
+				}
+				if prefix != "" {
+					data = prefix + data
+				}
+				err = sign.Verify(data, sig, cd.ImageSignKey, sign.WithOutNonce())
			}
-			cd := r.Context().Value(consts.KeyCoreData).(*common.CoreData)
-			if cd.ImageSignKey == "" || sign.Verify(data, sig, cd.ImageSignKey, opts...) != nil {
+
+			if cd.ImageSignKey == "" || err != nil {
				w.WriteHeader(http.StatusForbidden)
				handlers.RenderErrorPage(w, r, fmt.Errorf("forbidden"))
				return
diff --git a/handlers/images/routes_test.go b/handlers/images/routes_test.go
index 4273997f7..867021525 100644
--- a/handlers/images/routes_test.go
+++ b/handlers/images/routes_test.go
@@ -6,6 +6,7 @@ import (
	"net/http/httptest"
	"net/url"
	"testing"
+	"time"

	"github.com/gorilla/mux"

@@ -122,3 +123,58 @@ func TestVerifyMiddlewareAllowsQuerySignedImage(t *testing.T) {
		t.Fatalf("want %d got %d", http.StatusOK, rr.Code)
	}
 }
+
+func TestSignImageURL_EndToEnd(t *testing.T) {
+	// Setup Router
+	r := mux.NewRouter()
+	cfg := config.NewRuntimeConfig()
+	cfg.HTTPHostname = "http://localhost"
+	// Create a dummy image directory or mock the serving part?
+	// For this test, we only care about middleware passing (200 OK or 404 NotFound if file missing, but not 403 Forbidden).
+	// But serveImage will try to serve file.
+	// We can't easily mock serveImage without changing code, but if middleware passes, serveImage runs.
+	// serveImage checks ValidID which we will use a valid ID.
+	// It then tries to serve file. If file missing -> 404.
+	// If middleware fails -> 403.
+	// So we expect !403.
+
+	navReg := navigation.NewRegistry()
+	RegisterRoutes(r, cfg, navReg)
+
+	// Setup CoreData with key
+	req := httptest.NewRequest("GET", "/", nil)
+	key := "test-image-key"
+	cd := common.NewCoreData(req.Context(), nil, cfg, common.WithImageSignKey(key))
+
+	// Generate Signed URL
+	// We use a valid ID format
+	imageID := "ccf0e454-e774-4d6f-9ac3-2d6c15baad6d.png" // Valid format from user report
+	signedURLStr := cd.SignImageURL("image:"+imageID, 1*time.Hour)
+
+	t.Logf("Signed URL: %s", signedURLStr)
+
+	u, err := url.Parse(signedURLStr)
+	if err != nil {
+		t.Fatalf("Failed to parse generated URL: %v", err)
+	}
+
+	// Create Request
+	req = httptest.NewRequest("GET", u.Path+"?"+u.RawQuery, nil)
+	// Must inject CoreData into context as middleware expects it
+	ctx := context.WithValue(req.Context(), consts.KeyCoreData, cd)
+	req = req.WithContext(ctx)
+
+	rr := httptest.NewRecorder()
+	r.ServeHTTP(rr, req)
+
+	// We expect 404 (because file doesn't exist) but NOT 403 (Forbidden).
+	// If the middleware works, it should reach serveImage, which likely returns 404 for missing file.
+	// If middleware fails, it returns 403.
+	if rr.Code == http.StatusForbidden {
+		t.Errorf("Request was forbidden (403). Middleware failed verification. URL: %s", signedURLStr)
+	} else if rr.Code != http.StatusNotFound && rr.Code != http.StatusOK {
+		t.Errorf("Unexpected status code: %d. Expected 404 (file missing) or 200 (if we mocked file).", rr.Code)
+	} else {
+		t.Logf("Success: Got status %d (likely passed middleware)", rr.Code)
+	}
+}
