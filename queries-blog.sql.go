// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-blog.sql

package main

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const assignThreadIdToBlogEntry = `-- name: AssignThreadIdToBlogEntry :exec
UPDATE blogs
SET forumthread_idforumthread = ?
WHERE idblogs = ?
`

type AssignThreadIdToBlogEntryParams struct {
	ForumthreadIdforumthread int32
	Idblogs                  int32
}

func (q *Queries) AssignThreadIdToBlogEntry(ctx context.Context, arg AssignThreadIdToBlogEntryParams) error {
	_, err := q.db.ExecContext(ctx, assignThreadIdToBlogEntry, arg.ForumthreadIdforumthread, arg.Idblogs)
	return err
}

const blogsSearchFirst = `-- name: BlogsSearchFirst :many
SELECT DISTINCT cs.blogs_idblogs
FROM blogsSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
`

func (q *Queries) BlogsSearchFirst(ctx context.Context, word sql.NullString) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, blogsSearchFirst, word)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var blogs_idblogs int32
		if err := rows.Scan(&blogs_idblogs); err != nil {
			return nil, err
		}
		items = append(items, blogs_idblogs)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const blogsSearchNext = `-- name: BlogsSearchNext :many
SELECT DISTINCT cs.blogs_idblogs
FROM blogsSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
AND cs.blogs_idblogs IN (/*SLICE:ids*/?)
`

type BlogsSearchNextParams struct {
	Word sql.NullString
	Ids  []int32
}

func (q *Queries) BlogsSearchNext(ctx context.Context, arg BlogsSearchNextParams) ([]int32, error) {
	query := blogsSearchNext
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var blogs_idblogs int32
		if err := rows.Scan(&blogs_idblogs); err != nil {
			return nil, err
		}
		items = append(items, blogs_idblogs)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createBlogEntry = `-- name: CreateBlogEntry :execlastid
INSERT INTO blogs (users_idusers, language_idlanguage, blog, written)
VALUES (?, ?, ?, NOW())
`

type CreateBlogEntryParams struct {
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
}

func (q *Queries) CreateBlogEntry(ctx context.Context, arg CreateBlogEntryParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createBlogEntry, arg.UsersIdusers, arg.LanguageIdlanguage, arg.Blog)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const getAllBlogEntriesByUser = `-- name: GetAllBlogEntriesByUser :many
SELECT b.idblogs, b.forumthread_idforumthread, b.users_idusers, b.language_idlanguage, b.blog, b.written, u.username, coalesce(th.comments, 0)
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE b.users_idusers = ?
ORDER BY b.written DESC
`

type GetAllBlogEntriesByUserRow struct {
	Idblogs                  int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Blog                     sql.NullString
	Written                  time.Time
	Username                 sql.NullString
	Comments                 int32
}

func (q *Queries) GetAllBlogEntriesByUser(ctx context.Context, usersIdusers int32) ([]*GetAllBlogEntriesByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllBlogEntriesByUser, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllBlogEntriesByUserRow
	for rows.Next() {
		var i GetAllBlogEntriesByUserRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlogEntriesByIdsDescending = `-- name: GetBlogEntriesByIdsDescending :many
SELECT b.idblogs, b.forumthread_idforumthread, b.users_idusers, b.language_idlanguage, b.blog, b.written
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE b.idblogs IN (/*SLICE:blogids*/?)
ORDER BY b.written DESC
`

func (q *Queries) GetBlogEntriesByIdsDescending(ctx context.Context, blogids []int32) ([]*Blog, error) {
	query := getBlogEntriesByIdsDescending
	var queryParams []interface{}
	if len(blogids) > 0 {
		for _, v := range blogids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:blogids*/?", strings.Repeat(",?", len(blogids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:blogids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Blog
	for rows.Next() {
		var i Blog
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Blog,
			&i.Written,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlogEntriesForUserDescending = `-- name: GetBlogEntriesForUserDescending :many
SELECT b.idblogs, b.forumthread_idforumthread, b.users_idusers, b.language_idlanguage, b.blog, b.written, u.username, coalesce(th.comments, 0)
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE (b.language_idlanguage = ? OR ? = 0)
AND (b.users_idusers = ? OR ? = 0)
ORDER BY b.written DESC
LIMIT ? OFFSET ?
`

type GetBlogEntriesForUserDescendingParams struct {
	LanguageIdlanguage int32
	UsersIdusers       int32
	Limit              int32
	Offset             int32
}

type GetBlogEntriesForUserDescendingRow struct {
	Idblogs                  int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Blog                     sql.NullString
	Written                  time.Time
	Username                 sql.NullString
	Comments                 int32
}

func (q *Queries) GetBlogEntriesForUserDescending(ctx context.Context, arg GetBlogEntriesForUserDescendingParams) ([]*GetBlogEntriesForUserDescendingRow, error) {
	rows, err := q.db.QueryContext(ctx, getBlogEntriesForUserDescending,
		arg.LanguageIdlanguage,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
		arg.UsersIdusers,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetBlogEntriesForUserDescendingRow
	for rows.Next() {
		var i GetBlogEntriesForUserDescendingRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlogEntryForUserById = `-- name: GetBlogEntryForUserById :one
SELECT b.idblogs, b.forumthread_idforumthread, b.users_idusers, b.language_idlanguage, b.blog, b.written, u.username, coalesce(th.comments, 0)
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE b.idblogs = ?
LIMIT 1
`

type GetBlogEntryForUserByIdRow struct {
	Idblogs                  int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Blog                     sql.NullString
	Written                  time.Time
	Username                 sql.NullString
	Comments                 int32
}

func (q *Queries) GetBlogEntryForUserById(ctx context.Context, idblogs int32) (*GetBlogEntryForUserByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getBlogEntryForUserById, idblogs)
	var i GetBlogEntryForUserByIdRow
	err := row.Scan(
		&i.Idblogs,
		&i.ForumthreadIdforumthread,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Blog,
		&i.Written,
		&i.Username,
		&i.Comments,
	)
	return &i, err
}

const getCountOfBlogPostsByUser = `-- name: GetCountOfBlogPostsByUser :many
SELECT u.username, COUNT(b.idblogs)
FROM blogs b, users u
WHERE b.users_idusers = u.idusers
GROUP BY u.idusers
`

type GetCountOfBlogPostsByUserRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) GetCountOfBlogPostsByUser(ctx context.Context) ([]*GetCountOfBlogPostsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getCountOfBlogPostsByUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCountOfBlogPostsByUserRow
	for rows.Next() {
		var i GetCountOfBlogPostsByUserRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBlogEntry = `-- name: UpdateBlogEntry :exec
UPDATE blogs
SET language_idlanguage = ?, blog = ?
WHERE idblogs = ?
`

type UpdateBlogEntryParams struct {
	LanguageIdlanguage int32
	Blog               sql.NullString
	Idblogs            int32
}

func (q *Queries) UpdateBlogEntry(ctx context.Context, arg UpdateBlogEntryParams) error {
	_, err := q.db.ExecContext(ctx, updateBlogEntry, arg.LanguageIdlanguage, arg.Blog, arg.Idblogs)
	return err
}
