// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: queries-comments.sql

package main

import (
	"context"
	"database/sql"
	"strings"
)

const getComment = `-- name: GetComment :one
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text
FROM comments c
WHERE c.Idcomments=?
`

func (q *Queries) GetComment(ctx context.Context, idcomments int32) (*Comment, error) {
	row := q.db.QueryRowContext(ctx, getComment, idcomments)
	var i Comment
	err := row.Scan(
		&i.Idcomments,
		&i.ForumthreadIdforumthread,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Written,
		&i.Text,
	)
	return &i, err
}

const getComments = `-- name: GetComments :many
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text
FROM comments c
WHERE c.Idcomments IN (/*SLICE:ids*/?)
`

func (q *Queries) GetComments(ctx context.Context, ids []int32) ([]*Comment, error) {
	query := getComments
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsWithThreadInfo = `-- name: GetCommentsWithThreadInfo :many
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text, pu.username AS posterusername, th.idforumthread, t.idforumtopic, t.title AS forumtopic_title, fc.idforumcategory, fc.title AS forumcategory_title
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_idforumthread=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users pu ON pu.idusers = c.users_idusers
LEFT JOIN forumcategory fc ON t.forumcategory_idforumcategory = fc.idforumcategory
WHERE c.Idcomments IN (/*SLICE:ids*/?)
ORDER BY c.written DESC
`

type GetCommentsWithThreadInfoParams struct {
	UsersIdusers int32
	Ids          []int32
}

type GetCommentsWithThreadInfoRow struct {
	Idcomments               int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Written                  sql.NullTime
	Text                     sql.NullString
	Posterusername           sql.NullString
	Idforumthread            sql.NullInt32
	Idforumtopic             sql.NullInt32
	ForumtopicTitle          sql.NullString
	Idforumcategory          sql.NullInt32
	ForumcategoryTitle       sql.NullString
}

func (q *Queries) GetCommentsWithThreadInfo(ctx context.Context, arg GetCommentsWithThreadInfoParams) ([]*GetCommentsWithThreadInfoRow, error) {
	query := getCommentsWithThreadInfo
	var queryParams []interface{}
	queryParams = append(queryParams, arg.UsersIdusers)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCommentsWithThreadInfoRow
	for rows.Next() {
		var i GetCommentsWithThreadInfoRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.Posterusername,
			&i.Idforumthread,
			&i.Idforumtopic,
			&i.ForumtopicTitle,
			&i.Idforumcategory,
			&i.ForumcategoryTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makePost = `-- name: MakePost :execlastid
;

INSERT INTO comments (language_idlanguage, users_idusers, forumthread_idforumthread, text, written)
VALUES (?, ?, ?, ?, NOW())
`

type MakePostParams struct {
	LanguageIdlanguage       int32
	UsersIdusers             int32
	ForumthreadIdforumthread int32
	Text                     sql.NullString
}

func (q *Queries) MakePost(ctx context.Context, arg MakePostParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, makePost,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
		arg.ForumthreadIdforumthread,
		arg.Text,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const update_comment = `-- name: Update_comment :exec
UPDATE comments
SET language_idlanguage = ?, text = ?
WHERE idcomments = ?
`

type Update_commentParams struct {
	LanguageIdlanguage int32
	Text               sql.NullString
	Idcomments         int32
}

func (q *Queries) Update_comment(ctx context.Context, arg Update_commentParams) error {
	_, err := q.db.ExecContext(ctx, update_comment, arg.LanguageIdlanguage, arg.Text, arg.Idcomments)
	return err
}

const user_get_all_comments_for_thread = `-- name: User_get_all_comments_for_thread :many
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text, pu.username AS posterusername
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_idforumthread=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users pu ON pu.idusers = c.users_idusers
WHERE c.forumthread_idforumthread=? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY c.written
`

type User_get_all_comments_for_threadParams struct {
	UsersIdusers             int32
	ForumthreadIdforumthread int32
}

type User_get_all_comments_for_threadRow struct {
	Idcomments               int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Written                  sql.NullTime
	Text                     sql.NullString
	Posterusername           sql.NullString
}

func (q *Queries) User_get_all_comments_for_thread(ctx context.Context, arg User_get_all_comments_for_threadParams) ([]*User_get_all_comments_for_threadRow, error) {
	rows, err := q.db.QueryContext(ctx, user_get_all_comments_for_thread, arg.UsersIdusers, arg.ForumthreadIdforumthread)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User_get_all_comments_for_threadRow
	for rows.Next() {
		var i User_get_all_comments_for_threadRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const user_get_comment = `-- name: User_get_comment :one
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text, pu.Username
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_idforumthread=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users pu ON pu.idusers = c.users_idusers
WHERE c.idcomments = ? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
LIMIT 1
`

type User_get_commentParams struct {
	UsersIdusers int32
	Idcomments   int32
}

type User_get_commentRow struct {
	Idcomments               int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Written                  sql.NullTime
	Text                     sql.NullString
	Username                 sql.NullString
}

func (q *Queries) User_get_comment(ctx context.Context, arg User_get_commentParams) (*User_get_commentRow, error) {
	row := q.db.QueryRowContext(ctx, user_get_comment, arg.UsersIdusers, arg.Idcomments)
	var i User_get_commentRow
	err := row.Scan(
		&i.Idcomments,
		&i.ForumthreadIdforumthread,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Written,
		&i.Text,
		&i.Username,
	)
	return &i, err
}
