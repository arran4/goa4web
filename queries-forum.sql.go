// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: queries-forum.sql

package main

import (
	"context"
	"database/sql"
)

const changeCategory = `-- name: ChangeCategory :exec
UPDATE forumcategory SET title = ?, description = ?, forumcategory_idforumcategory = ? WHERE idforumcategory = ?
`

type ChangeCategoryParams struct {
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	Idforumcategory              int32
}

func (q *Queries) ChangeCategory(ctx context.Context, arg ChangeCategoryParams) error {
	_, err := q.db.ExecContext(ctx, changeCategory,
		arg.Title,
		arg.Description,
		arg.ForumcategoryIdforumcategory,
		arg.Idforumcategory,
	)
	return err
}

const changeTopic = `-- name: ChangeTopic :exec
UPDATE forumtopic SET title = ?, description = ?, forumcategory_idforumcategory = ? WHERE idforumtopic = ?
`

type ChangeTopicParams struct {
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	Idforumtopic                 int32
}

func (q *Queries) ChangeTopic(ctx context.Context, arg ChangeTopicParams) error {
	_, err := q.db.ExecContext(ctx, changeTopic,
		arg.Title,
		arg.Description,
		arg.ForumcategoryIdforumcategory,
		arg.Idforumtopic,
	)
	return err
}

const deleteUsersTopicLevel = `-- name: DeleteUsersTopicLevel :exec
DELETE FROM userstopiclevel WHERE forumtopic_idforumtopic = ? AND users_idusers = ?
`

type DeleteUsersTopicLevelParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
}

func (q *Queries) DeleteUsersTopicLevel(ctx context.Context, arg DeleteUsersTopicLevelParams) error {
	_, err := q.db.ExecContext(ctx, deleteUsersTopicLevel, arg.ForumtopicIdforumtopic, arg.UsersIdusers)
	return err
}

const findForumTopicByName = `-- name: FindForumTopicByName :one
SELECT idforumtopic FROM forumtopic WHERE title=?
`

func (q *Queries) FindForumTopicByName(ctx context.Context, title sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, findForumTopicByName, title)
	var idforumtopic int32
	err := row.Scan(&idforumtopic)
	return idforumtopic, err
}

const forumCategories = `-- name: ForumCategories :many
SELECT f.idforumcategory, f.forumcategory_idforumcategory, f.title, f.description
FROM forumcategory f
`

func (q *Queries) ForumCategories(ctx context.Context) ([]*Forumcategory, error) {
	rows, err := q.db.QueryContext(ctx, forumCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumcategory
	for rows.Next() {
		var i Forumcategory
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTopics = `-- name: GetAllTopics :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition
FROM forumtopic t
LEFT JOIN forumcategory c ON t.forumcategory_idforumcategory = c.idforumcategory
GROUP BY t.idforumtopic
`

func (q *Queries) GetAllTopics(ctx context.Context) ([]*Forumtopic, error) {
	rows, err := q.db.QueryContext(ctx, getAllTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumtopic
	for rows.Next() {
		var i Forumtopic
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersAllTopicLevels = `-- name: GetAllUsersAllTopicLevels :many
SELECT u.idusers, u.email, u.passwd, u.username, t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, utl.users_idusers, utl.forumtopic_idforumtopic, utl.level, utl.invitemax, tr.forumtopic_idforumtopic, tr.viewlevel, tr.replylevel, tr.newthreadlevel, tr.seelevel, tr.invitelevel, tr.readlevel, tr.modlevel, tr.adminlevel
FROM users u
JOIN userstopiclevel utl ON utl.users_idusers=u.idusers
JOIN forumtopic t ON utl.forumtopic_idforumtopic = t.idforumtopic
LEFT JOIN topicrestrictions tr ON t.idforumtopic = tr.forumtopic_idforumtopic
`

type GetAllUsersAllTopicLevelsRow struct {
	Idusers                      int32
	Email                        sql.NullString
	Passwd                       sql.NullString
	Username                     sql.NullString
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	UsersIdusers                 int32
	ForumtopicIdforumtopic       int32
	Level                        sql.NullInt32
	Invitemax                    sql.NullInt32
	ForumtopicIdforumtopic_2     sql.NullInt32
	Viewlevel                    sql.NullInt32
	Replylevel                   sql.NullInt32
	Newthreadlevel               sql.NullInt32
	Seelevel                     sql.NullInt32
	Invitelevel                  sql.NullInt32
	Readlevel                    sql.NullInt32
	Modlevel                     sql.NullInt32
	Adminlevel                   sql.NullInt32
}

func (q *Queries) GetAllUsersAllTopicLevels(ctx context.Context) ([]*GetAllUsersAllTopicLevelsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersAllTopicLevels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllUsersAllTopicLevelsRow
	for rows.Next() {
		var i GetAllUsersAllTopicLevelsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.UsersIdusers,
			&i.ForumtopicIdforumtopic,
			&i.Level,
			&i.Invitemax,
			&i.ForumtopicIdforumtopic_2,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersAllTopicLevels = `-- name: GetUsersAllTopicLevels :many
SELECT u.idusers, u.email, u.passwd, u.username, t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, utl.users_idusers, utl.forumtopic_idforumtopic, utl.level, utl.invitemax, tr.forumtopic_idforumtopic, tr.viewlevel, tr.replylevel, tr.newthreadlevel, tr.seelevel, tr.invitelevel, tr.readlevel, tr.modlevel, tr.adminlevel
FROM users u
JOIN userstopiclevel utl ON utl.users_idusers=u.idusers
JOIN forumtopic t ON utl.forumtopic_idforumtopic = t.idforumtopic
JOIN topicrestrictions tr ON t.idforumtopic = tr.forumtopic_idforumtopic
WHERE u.idusers = ?
`

type GetUsersAllTopicLevelsRow struct {
	Idusers                      int32
	Email                        sql.NullString
	Passwd                       sql.NullString
	Username                     sql.NullString
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	UsersIdusers                 int32
	ForumtopicIdforumtopic       int32
	Level                        sql.NullInt32
	Invitemax                    sql.NullInt32
	ForumtopicIdforumtopic_2     int32
	Viewlevel                    sql.NullInt32
	Replylevel                   sql.NullInt32
	Newthreadlevel               sql.NullInt32
	Seelevel                     sql.NullInt32
	Invitelevel                  sql.NullInt32
	Readlevel                    sql.NullInt32
	Modlevel                     sql.NullInt32
	Adminlevel                   sql.NullInt32
}

func (q *Queries) GetUsersAllTopicLevels(ctx context.Context, idusers int32) ([]*GetUsersAllTopicLevelsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersAllTopicLevels, idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUsersAllTopicLevelsRow
	for rows.Next() {
		var i GetUsersAllTopicLevelsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.UsersIdusers,
			&i.ForumtopicIdforumtopic,
			&i.Level,
			&i.Invitemax,
			&i.ForumtopicIdforumtopic_2,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get_all_user_topics = `-- name: Get_all_user_topics :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY t.lastaddition DESC
`

type Get_all_user_topicsRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
	Seelevel                     sql.NullInt32
	Level                        sql.NullInt32
}

func (q *Queries) Get_all_user_topics(ctx context.Context, usersIdusers int32) ([]*Get_all_user_topicsRow, error) {
	rows, err := q.db.QueryContext(ctx, get_all_user_topics, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Get_all_user_topicsRow
	for rows.Next() {
		var i Get_all_user_topicsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Lastposterusername,
			&i.Seelevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get_all_user_topics_for_category = `-- name: Get_all_user_topics_for_category :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE t.forumcategory_idforumcategory = ? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY t.lastaddition DESC
`

type Get_all_user_topics_for_categoryParams struct {
	UsersIdusers                 int32
	ForumcategoryIdforumcategory int32
}

type Get_all_user_topics_for_categoryRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
	Seelevel                     sql.NullInt32
	Level                        sql.NullInt32
}

func (q *Queries) Get_all_user_topics_for_category(ctx context.Context, arg Get_all_user_topics_for_categoryParams) ([]*Get_all_user_topics_for_categoryRow, error) {
	rows, err := q.db.QueryContext(ctx, get_all_user_topics_for_category, arg.UsersIdusers, arg.ForumcategoryIdforumcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Get_all_user_topics_for_categoryRow
	for rows.Next() {
		var i Get_all_user_topics_for_categoryRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Lastposterusername,
			&i.Seelevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeCategory = `-- name: MakeCategory :exec
INSERT INTO forumcategory (forumcategory_idforumcategory, title, description) VALUES (?, ?, ?)
`

type MakeCategoryParams struct {
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) MakeCategory(ctx context.Context, arg MakeCategoryParams) error {
	_, err := q.db.ExecContext(ctx, makeCategory, arg.ForumcategoryIdforumcategory, arg.Title, arg.Description)
	return err
}

const makeTopic = `-- name: MakeTopic :execlastid
INSERT INTO forumtopic (forumcategory_idforumcategory, title, description) VALUES (?, ?, ?)
`

type MakeTopicParams struct {
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) MakeTopic(ctx context.Context, arg MakeTopicParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, makeTopic, arg.ForumcategoryIdforumcategory, arg.Title, arg.Description)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const setUsersTopicLevel = `-- name: SetUsersTopicLevel :exec
INSERT INTO userstopiclevel (forumtopic_idforumtopic, users_idusers, level, invitemax)
VALUES (?, ?, ?, ?)
ON DUPLICATE KEY UPDATE level = VALUES(level), invitemax = VALUES(invitemax)
`

type SetUsersTopicLevelParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
	Level                  sql.NullInt32
	Invitemax              sql.NullInt32
}

func (q *Queries) SetUsersTopicLevel(ctx context.Context, arg SetUsersTopicLevelParams) error {
	_, err := q.db.ExecContext(ctx, setUsersTopicLevel,
		arg.ForumtopicIdforumtopic,
		arg.UsersIdusers,
		arg.Level,
		arg.Invitemax,
	)
	return err
}

const showAllCategories = `-- name: ShowAllCategories :many
SELECT c.idforumcategory, c.forumcategory_idforumcategory, c.title, c.description, COUNT(c2.idforumcategory) as SubcategoryCount
FROM forumcategory c
LEFT JOIN forumcategory c2 ON c.forumcategory_idforumcategory = c2.idforumcategory
GROUP BY c.idforumcategory
`

type ShowAllCategoriesRow struct {
	Idforumcategory              int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Subcategorycount             int64
}

func (q *Queries) ShowAllCategories(ctx context.Context) ([]*ShowAllCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, showAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ShowAllCategoriesRow
	for rows.Next() {
		var i ShowAllCategoriesRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Subcategorycount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const update_forumtopic = `-- name: Update_forumtopic :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
), lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
WHERE idforumtopic = ?
`

func (q *Queries) Update_forumtopic(ctx context.Context, idforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic, idforumtopic)
	return err
}

const update_forumtopics = `-- name: Update_forumtopics :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
), lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
`

func (q *Queries) Update_forumtopics(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopics)
	return err
}

const user_get_threads_for_topic = `-- name: User_get_threads_for_topic :many
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked, lu.username AS lastposterusername, lu.idusers AS lastposterid, fcu.username as firstpostusername, fc.written as firstpostwritten, fc.text as firstposttext
FROM forumthread th
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
LEFT JOIN comments fc ON th.firstpost=fc.idcomments
LEFT JOIN users fcu ON fcu.idusers = fc.users_idusers
WHERE th.forumtopic_idforumtopic=? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY th.lastaddition DESC
`

type User_get_threads_for_topicParams struct {
	UsersIdusers           int32
	ForumtopicIdforumtopic int32
}

type User_get_threads_for_topicRow struct {
	Idforumthread          int32
	Firstpost              int32
	Lastposter             int32
	ForumtopicIdforumtopic int32
	Comments               sql.NullInt32
	Lastaddition           sql.NullTime
	Locked                 sql.NullBool
	Lastposterusername     sql.NullString
	Lastposterid           sql.NullInt32
	Firstpostusername      sql.NullString
	Firstpostwritten       sql.NullTime
	Firstposttext          sql.NullString
}

func (q *Queries) User_get_threads_for_topic(ctx context.Context, arg User_get_threads_for_topicParams) ([]*User_get_threads_for_topicRow, error) {
	rows, err := q.db.QueryContext(ctx, user_get_threads_for_topic, arg.UsersIdusers, arg.ForumtopicIdforumtopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User_get_threads_for_topicRow
	for rows.Next() {
		var i User_get_threads_for_topicRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Firstpost,
			&i.Lastposter,
			&i.ForumtopicIdforumtopic,
			&i.Comments,
			&i.Lastaddition,
			&i.Locked,
			&i.Lastposterusername,
			&i.Lastposterid,
			&i.Firstpostusername,
			&i.Firstpostwritten,
			&i.Firstposttext,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const user_get_topic = `-- name: User_get_topic :one
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0) AND t.idforumtopic=?
ORDER BY t.lastaddition DESC
`

type User_get_topicParams struct {
	UsersIdusers int32
	Idforumtopic int32
}

type User_get_topicRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
	Seelevel                     sql.NullInt32
	Level                        sql.NullInt32
}

func (q *Queries) User_get_topic(ctx context.Context, arg User_get_topicParams) (*User_get_topicRow, error) {
	row := q.db.QueryRowContext(ctx, user_get_topic, arg.UsersIdusers, arg.Idforumtopic)
	var i User_get_topicRow
	err := row.Scan(
		&i.Idforumtopic,
		&i.Lastposter,
		&i.ForumcategoryIdforumcategory,
		&i.Title,
		&i.Description,
		&i.Threads,
		&i.Comments,
		&i.Lastaddition,
		&i.Lastposterusername,
		&i.Seelevel,
		&i.Level,
	)
	return &i, err
}
