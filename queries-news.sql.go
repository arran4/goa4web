// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: queries-news.sql

package main

import (
	"context"
	"database/sql"
	"strings"
)

const assignNewsThisThreadId = `-- name: AssignNewsThisThreadId :exec
UPDATE siteNews SET forumthread_idforumthread = ? WHERE idsiteNews = ?
`

type AssignNewsThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idsitenews               int32
}

func (q *Queries) AssignNewsThisThreadId(ctx context.Context, arg AssignNewsThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignNewsThisThreadId, arg.ForumthreadIdforumthread, arg.Idsitenews)
	return err
}

const editNewsPost = `-- name: EditNewsPost :exec
UPDATE siteNews SET news = ?, language_idlanguage = ? WHERE idsiteNews = ?
`

type EditNewsPostParams struct {
	News               sql.NullString
	LanguageIdlanguage int32
	Idsitenews         int32
}

func (q *Queries) EditNewsPost(ctx context.Context, arg EditNewsPostParams) error {
	_, err := q.db.ExecContext(ctx, editNewsPost, arg.News, arg.LanguageIdlanguage, arg.Idsitenews)
	return err
}

const getLatestNewsPosts = `-- name: GetLatestNewsPosts :many
SELECT u.username AS writerName, u.idusers as writerId, s.idsitenews, s.forumthread_idforumthread, s.language_idlanguage, s.users_idusers, s.news, s.occured, th.comments as Comments
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_idforumthread = th.idforumthread
ORDER BY s.occured DESC
LIMIT 15
`

type GetLatestNewsPostsRow struct {
	Writername               sql.NullString
	Writerid                 sql.NullInt32
	Idsitenews               int32
	ForumthreadIdforumthread int32
	LanguageIdlanguage       int32
	UsersIdusers             int32
	News                     sql.NullString
	Occured                  sql.NullTime
	Comments                 sql.NullInt32
}

func (q *Queries) GetLatestNewsPosts(ctx context.Context) ([]*GetLatestNewsPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestNewsPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetLatestNewsPostsRow
	for rows.Next() {
		var i GetLatestNewsPostsRow
		if err := rows.Scan(
			&i.Writername,
			&i.Writerid,
			&i.Idsitenews,
			&i.ForumthreadIdforumthread,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.News,
			&i.Occured,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsPost = `-- name: GetNewsPost :one
SELECT u.username AS writerName, u.idusers as writerId, s.idsitenews, s.forumthread_idforumthread, s.language_idlanguage, s.users_idusers, s.news, s.occured, th.comments as Comments
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_idforumthread = th.idforumthread
WHERE s.idsiteNews = ?
`

type GetNewsPostRow struct {
	Writername               sql.NullString
	Writerid                 sql.NullInt32
	Idsitenews               int32
	ForumthreadIdforumthread int32
	LanguageIdlanguage       int32
	UsersIdusers             int32
	News                     sql.NullString
	Occured                  sql.NullTime
	Comments                 sql.NullInt32
}

func (q *Queries) GetNewsPost(ctx context.Context, idsitenews int32) (*GetNewsPostRow, error) {
	row := q.db.QueryRowContext(ctx, getNewsPost, idsitenews)
	var i GetNewsPostRow
	err := row.Scan(
		&i.Writername,
		&i.Writerid,
		&i.Idsitenews,
		&i.ForumthreadIdforumthread,
		&i.LanguageIdlanguage,
		&i.UsersIdusers,
		&i.News,
		&i.Occured,
		&i.Comments,
	)
	return &i, err
}

const getNewsPosts = `-- name: GetNewsPosts :many
SELECT u.username AS writerName, u.idusers as writerId, s.idsitenews, s.forumthread_idforumthread, s.language_idlanguage, s.users_idusers, s.news, s.occured, th.comments as Comments
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_idforumthread = th.idforumthread
WHERE s.Idsitenews IN (/*SLICE:newsids*/?)
`

type GetNewsPostsRow struct {
	Writername               sql.NullString
	Writerid                 sql.NullInt32
	Idsitenews               int32
	ForumthreadIdforumthread int32
	LanguageIdlanguage       int32
	UsersIdusers             int32
	News                     sql.NullString
	Occured                  sql.NullTime
	Comments                 sql.NullInt32
}

func (q *Queries) GetNewsPosts(ctx context.Context, newsids []int32) ([]*GetNewsPostsRow, error) {
	query := getNewsPosts
	var queryParams []interface{}
	if len(newsids) > 0 {
		for _, v := range newsids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:newsids*/?", strings.Repeat(",?", len(newsids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:newsids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNewsPostsRow
	for rows.Next() {
		var i GetNewsPostsRow
		if err := rows.Scan(
			&i.Writername,
			&i.Writerid,
			&i.Idsitenews,
			&i.ForumthreadIdforumthread,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.News,
			&i.Occured,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsThreadId = `-- name: GetNewsThreadId :one
SELECT s.forumthread_idforumthread, u.idusers
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
WHERE s.idsiteNews = ?
`

type GetNewsThreadIdRow struct {
	ForumthreadIdforumthread int32
	Idusers                  sql.NullInt32
}

func (q *Queries) GetNewsThreadId(ctx context.Context, idsitenews int32) (*GetNewsThreadIdRow, error) {
	row := q.db.QueryRowContext(ctx, getNewsThreadId, idsitenews)
	var i GetNewsThreadIdRow
	err := row.Scan(&i.ForumthreadIdforumthread, &i.Idusers)
	return &i, err
}

const writeNewsPost = `-- name: WriteNewsPost :exec
INSERT INTO siteNews (news, users_idusers, occured, language_idlanguage)
VALUES (?, ?, NOW(), ?)
`

type WriteNewsPostParams struct {
	News               sql.NullString
	UsersIdusers       int32
	LanguageIdlanguage int32
}

func (q *Queries) WriteNewsPost(ctx context.Context, arg WriteNewsPostParams) error {
	_, err := q.db.ExecContext(ctx, writeNewsPost, arg.News, arg.UsersIdusers, arg.LanguageIdlanguage)
	return err
}

const writeSiteNewsRSS = `-- name: WriteSiteNewsRSS :many
SELECT s.idsiteNews, s.occured, s.news
FROM siteNews s
ORDER BY s.occured DESC LIMIT 15
`

type WriteSiteNewsRSSRow struct {
	Idsitenews int32
	Occured    sql.NullTime
	News       sql.NullString
}

func (q *Queries) WriteSiteNewsRSS(ctx context.Context) ([]*WriteSiteNewsRSSRow, error) {
	rows, err := q.db.QueryContext(ctx, writeSiteNewsRSS)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WriteSiteNewsRSSRow
	for rows.Next() {
		var i WriteSiteNewsRSSRow
		if err := rows.Scan(&i.Idsitenews, &i.Occured, &i.News); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
