// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries-users.sql

package main

import (
	"context"
	"database/sql"
	"time"
)

const allUsers = `-- name: AllUsers :many
SELECT u.idusers, u.email, u.passwd, u.username
FROM users u
`

// This query selects all admin users from the "users" table.
// Result:
//
//	idusers (int)
//	username (string)
//	email (string)
func (q *Queries) AllUsers(ctx context.Context) ([]*User, error) {
	rows, err := q.db.QueryContext(ctx, allUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT idusers, email, passwd, username
FROM users
WHERE idusers = ?
`

func (q *Queries) GetUserById(ctx context.Context, idusers int32) (*User, error) {
	row := q.db.QueryRowContext(ctx, getUserById, idusers)
	var i User
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.Username,
	)
	return &i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT idusers, email, passwd, username
FROM users
WHERE username = ?
`

func (q *Queries) GetUserByUsername(ctx context.Context, username sql.NullString) (*User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.Username,
	)
	return &i, err
}

const insertUser = `-- name: InsertUser :execresult
INSERT INTO users (username, passwd, email)
VALUES (?, MD5(?), ?)
`

type InsertUserParams struct {
	Username sql.NullString
	MD5      string
	Email    sql.NullString
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertUser, arg.Username, arg.MD5, arg.Email)
}

const listAdministratorEmails = `-- name: ListAdministratorEmails :many
SELECT u.email
FROM users u
JOIN permissions p ON p.users_idusers = u.idusers
WHERE p.section = 'administrator'
`

func (q *Queries) ListAdministratorEmails(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, listAdministratorEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToBlogs = `-- name: ListUsersSubscribedToBlogs :many
SELECT idblogs, forumthread_idforumthread, t.users_idusers, t.language_idlanguage, blog, written, idusers, email, passwd, username, idpreferences, p.language_idlanguage, p.users_idusers, emailforumupdates, page_size
FROM blogs t, users u, preferences p
WHERE t.idblogs=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToBlogsParams struct {
	Idblogs int32
	Idusers int32
}

type ListUsersSubscribedToBlogsRow struct {
	Idblogs                  int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Blog                     sql.NullString
	Written                  time.Time
	Idusers                  int32
	Email                    sql.NullString
	Passwd                   sql.NullString
	Username                 sql.NullString
	Idpreferences            int32
	LanguageIdlanguage_2     int32
	UsersIdusers_2           int32
	Emailforumupdates        sql.NullBool
	PageSize                 int32
}

func (q *Queries) ListUsersSubscribedToBlogs(ctx context.Context, arg ListUsersSubscribedToBlogsParams) ([]*ListUsersSubscribedToBlogsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToBlogs, arg.Idblogs, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToBlogsRow
	for rows.Next() {
		var i ListUsersSubscribedToBlogsRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Blog,
			&i.Written,
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToLinker = `-- name: ListUsersSubscribedToLinker :many
SELECT idlinker, t.language_idlanguage, t.users_idusers, linkercategory_idlinkercategory, forumthread_idforumthread, title, url, description, listed, idusers, email, passwd, username, idpreferences, p.language_idlanguage, p.users_idusers, emailforumupdates, page_size
FROM linker t, users u, preferences p
WHERE t.idlinker=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToLinkerParams struct {
	Idlinker int32
	Idusers  int32
}

type ListUsersSubscribedToLinkerRow struct {
	Idlinker                       int32
	LanguageIdlanguage             int32
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	ForumthreadIdforumthread       int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
	Listed                         sql.NullTime
	Idusers                        int32
	Email                          sql.NullString
	Passwd                         sql.NullString
	Username                       sql.NullString
	Idpreferences                  int32
	LanguageIdlanguage_2           int32
	UsersIdusers_2                 int32
	Emailforumupdates              sql.NullBool
	PageSize                       int32
}

func (q *Queries) ListUsersSubscribedToLinker(ctx context.Context, arg ListUsersSubscribedToLinkerParams) ([]*ListUsersSubscribedToLinkerRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToLinker, arg.Idlinker, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToLinkerRow
	for rows.Next() {
		var i ListUsersSubscribedToLinkerRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkercategoryIdlinkercategory,
			&i.ForumthreadIdforumthread,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToThread = `-- name: ListUsersSubscribedToThread :many
SELECT idcomments, forumthread_idforumthread, c.users_idusers, c.language_idlanguage, written, text, idusers, email, passwd, username, idpreferences, p.language_idlanguage, p.users_idusers, emailforumupdates, page_size
FROM comments c, users u, preferences p
WHERE c.forumthread_idforumthread=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=c.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToThreadParams struct {
	ForumthreadIdforumthread int32
	Idusers                  int32
}

type ListUsersSubscribedToThreadRow struct {
	Idcomments               int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Written                  sql.NullTime
	Text                     sql.NullString
	Idusers                  int32
	Email                    sql.NullString
	Passwd                   sql.NullString
	Username                 sql.NullString
	Idpreferences            int32
	LanguageIdlanguage_2     int32
	UsersIdusers_2           int32
	Emailforumupdates        sql.NullBool
	PageSize                 int32
}

func (q *Queries) ListUsersSubscribedToThread(ctx context.Context, arg ListUsersSubscribedToThreadParams) ([]*ListUsersSubscribedToThreadRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToThread, arg.ForumthreadIdforumthread, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToThreadRow
	for rows.Next() {
		var i ListUsersSubscribedToThreadRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersSubscribedToWriting = `-- name: ListUsersSubscribedToWriting :many
SELECT idwriting, t.users_idusers, forumthread_idforumthread, t.language_idlanguage, writingcategory_idwritingcategory, title, published, writting, abstract, private, idusers, email, passwd, username, idpreferences, p.language_idlanguage, p.users_idusers, emailforumupdates, page_size
FROM writing t, users u, preferences p
WHERE t.idwriting=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ListUsersSubscribedToWritingParams struct {
	Idwriting int32
	Idusers   int32
}

type ListUsersSubscribedToWritingRow struct {
	Idwriting                        int32
	UsersIdusers                     int32
	ForumthreadIdforumthread         int32
	LanguageIdlanguage               int32
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Published                        sql.NullTime
	Writting                         sql.NullString
	Abstract                         sql.NullString
	Private                          sql.NullBool
	Idusers                          int32
	Email                            sql.NullString
	Passwd                           sql.NullString
	Username                         sql.NullString
	Idpreferences                    int32
	LanguageIdlanguage_2             int32
	UsersIdusers_2                   int32
	Emailforumupdates                sql.NullBool
	PageSize                         int32
}

func (q *Queries) ListUsersSubscribedToWriting(ctx context.Context, arg ListUsersSubscribedToWritingParams) ([]*ListUsersSubscribedToWritingRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersSubscribedToWriting, arg.Idwriting, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListUsersSubscribedToWritingRow
	for rows.Next() {
		var i ListUsersSubscribedToWritingRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadIdforumthread,
			&i.LanguageIdlanguage,
			&i.WritingcategoryIdwritingcategory,
			&i.Title,
			&i.Published,
			&i.Writting,
			&i.Abstract,
			&i.Private,
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
			&i.Idpreferences,
			&i.LanguageIdlanguage_2,
			&i.UsersIdusers_2,
			&i.Emailforumupdates,
			&i.PageSize,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const login = `-- name: Login :one
SELECT idusers, email, passwd, username
FROM users
WHERE username = ? AND passwd = md5(?)
`

type LoginParams struct {
	Username sql.NullString
	MD5      string
}

func (q *Queries) Login(ctx context.Context, arg LoginParams) (*User, error) {
	row := q.db.QueryRowContext(ctx, login, arg.Username, arg.MD5)
	var i User
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.Username,
	)
	return &i, err
}

const userByEmail = `-- name: UserByEmail :one
SELECT idusers, email, passwd, username
FROM users
WHERE email = ?
`

func (q *Queries) UserByEmail(ctx context.Context, email sql.NullString) (*User, error) {
	row := q.db.QueryRowContext(ctx, userByEmail, email)
	var i User
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.Username,
	)
	return &i, err
}

const userByUsername = `-- name: UserByUsername :one
SELECT idusers, email, passwd, username
FROM users
WHERE username = ?
`

func (q *Queries) UserByUsername(ctx context.Context, username sql.NullString) (*User, error) {
	row := q.db.QueryRowContext(ctx, userByUsername, username)
	var i User
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.Username,
	)
	return &i, err
}
