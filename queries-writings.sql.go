// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: queries-writings.sql

package main

import (
	"context"
	"database/sql"
	"strings"
)

const assignWritingThisThreadId = `-- name: AssignWritingThisThreadId :exec
UPDATE writing SET forumthread_idforumthread = ? WHERE idwriting = ?
`

type AssignWritingThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idwriting                int32
}

func (q *Queries) AssignWritingThisThreadId(ctx context.Context, arg AssignWritingThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignWritingThisThreadId, arg.ForumthreadIdforumthread, arg.Idwriting)
	return err
}

const deleteWritingApproval = `-- name: DeleteWritingApproval :exec
DELETE FROM writtingApprovedUsers
WHERE writing_idwriting = ? AND users_idusers = ?
`

type DeleteWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) DeleteWritingApproval(ctx context.Context, arg DeleteWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, deleteWritingApproval, arg.WritingIdwriting, arg.UsersIdusers)
	return err
}

const fetchAllCategories = `-- name: FetchAllCategories :many
SELECT wc.idwritingcategory, wc.writingcategory_idwritingcategory, wc.title, wc.description
FROM writingCategory wc
`

func (q *Queries) FetchAllCategories(ctx context.Context) ([]*Writingcategory, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Writingcategory
	for rows.Next() {
		var i Writingcategory
		if err := rows.Scan(
			&i.Idwritingcategory,
			&i.WritingcategoryIdwritingcategory,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAllWritingApprovals = `-- name: FetchAllWritingApprovals :many
SELECT idusers, u.username, wau.writing_idwriting, wau.readdoc, wau.editdoc
FROM writtingApprovedUsers wau
LEFT JOIN users u ON idusers = wau.users_idusers
`

type FetchAllWritingApprovalsRow struct {
	Idusers          int32
	Username         sql.NullString
	WritingIdwriting int32
	Readdoc          sql.NullBool
	Editdoc          sql.NullBool
}

func (q *Queries) FetchAllWritingApprovals(ctx context.Context) ([]*FetchAllWritingApprovalsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllWritingApprovals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchAllWritingApprovalsRow
	for rows.Next() {
		var i FetchAllWritingApprovalsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Username,
			&i.WritingIdwriting,
			&i.Readdoc,
			&i.Editdoc,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchCategories = `-- name: FetchCategories :many
SELECT idwritingCategory, title, description
FROM writingCategory
WHERE writingCategory_idwritingCategory = ?
`

type FetchCategoriesRow struct {
	Idwritingcategory int32
	Title             sql.NullString
	Description       sql.NullString
}

func (q *Queries) FetchCategories(ctx context.Context, writingcategoryIdwritingcategory int32) ([]*FetchCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchCategories, writingcategoryIdwritingcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchCategoriesRow
	for rows.Next() {
		var i FetchCategoriesRow
		if err := rows.Scan(&i.Idwritingcategory, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPublicWritings = `-- name: FetchPublicWritings :many
SELECT w.title, w.abstract, w.idwriting, w.private, w.writingCategory_idwritingCategory
FROM writing w
WHERE w.private = 0
ORDER BY w.published DESC LIMIT 15
`

type FetchPublicWritingsRow struct {
	Title                            sql.NullString
	Abstract                         sql.NullString
	Idwriting                        int32
	Private                          sql.NullBool
	WritingcategoryIdwritingcategory int32
}

func (q *Queries) FetchPublicWritings(ctx context.Context) ([]*FetchPublicWritingsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPublicWritings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchPublicWritingsRow
	for rows.Next() {
		var i FetchPublicWritingsRow
		if err := rows.Scan(
			&i.Title,
			&i.Abstract,
			&i.Idwriting,
			&i.Private,
			&i.WritingcategoryIdwritingcategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPublicWritingsInCategory = `-- name: FetchPublicWritingsInCategory :many
SELECT w.idwriting, w.users_idusers, w.forumthread_idforumthread, w.language_idlanguage, w.writingcategory_idwritingcategory, w.title, w.published, w.writting, w.abstract, w.private, u.Username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_idforumthread=w.forumthread_idforumthread AND w.forumthread_idforumthread != 0) as Comments
FROM writing w
LEFT JOIN users u ON w.Users_Idusers=u.idusers
WHERE w.private = 0 AND w.writingCategory_idwritingCategory=?
ORDER BY w.published DESC LIMIT 15
`

type FetchPublicWritingsInCategoryRow struct {
	Idwriting                        int32
	UsersIdusers                     int32
	ForumthreadIdforumthread         int32
	LanguageIdlanguage               int32
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Published                        sql.NullTime
	Writting                         sql.NullString
	Abstract                         sql.NullString
	Private                          sql.NullBool
	Username                         sql.NullString
	Comments                         int64
}

func (q *Queries) FetchPublicWritingsInCategory(ctx context.Context, writingcategoryIdwritingcategory int32) ([]*FetchPublicWritingsInCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPublicWritingsInCategory, writingcategoryIdwritingcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchPublicWritingsInCategoryRow
	for rows.Next() {
		var i FetchPublicWritingsInCategoryRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadIdforumthread,
			&i.LanguageIdlanguage,
			&i.WritingcategoryIdwritingcategory,
			&i.Title,
			&i.Published,
			&i.Writting,
			&i.Abstract,
			&i.Private,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingApproval = `-- name: FetchWritingApproval :many
SELECT editdoc
FROM writtingApprovedUsers
WHERE writing_idwriting = ? AND users_idusers = ?
`

type FetchWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) FetchWritingApproval(ctx context.Context, arg FetchWritingApprovalParams) ([]sql.NullBool, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingApproval, arg.WritingIdwriting, arg.UsersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullBool
	for rows.Next() {
		var editdoc sql.NullBool
		if err := rows.Scan(&editdoc); err != nil {
			return nil, err
		}
		items = append(items, editdoc)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingById = `-- name: FetchWritingById :one
SELECT w.idwriting, w.users_idusers, w.forumthread_idforumthread, w.language_idlanguage, w.writingcategory_idwritingcategory, w.title, w.published, w.writting, w.abstract, w.private, u.idusers AS WriterId, u.Username AS WriterUsername
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN writtingApprovedUsers wau ON w.idwriting = wau.writing_idwriting AND wau.users_idusers = ?
WHERE w.idwriting = ? AND (w.private = 0 OR wau.readdoc = 1 OR w.users_idusers = ?)
ORDER BY w.published DESC
`

type FetchWritingByIdParams struct {
	Userid    int32
	Idwriting int32
}

type FetchWritingByIdRow struct {
	Idwriting                        int32
	UsersIdusers                     int32
	ForumthreadIdforumthread         int32
	LanguageIdlanguage               int32
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Published                        sql.NullTime
	Writting                         sql.NullString
	Abstract                         sql.NullString
	Private                          sql.NullBool
	Writerid                         int32
	Writerusername                   sql.NullString
}

func (q *Queries) FetchWritingById(ctx context.Context, arg FetchWritingByIdParams) (*FetchWritingByIdRow, error) {
	row := q.db.QueryRowContext(ctx, fetchWritingById, arg.Userid, arg.Idwriting, arg.Userid)
	var i FetchWritingByIdRow
	err := row.Scan(
		&i.Idwriting,
		&i.UsersIdusers,
		&i.ForumthreadIdforumthread,
		&i.LanguageIdlanguage,
		&i.WritingcategoryIdwritingcategory,
		&i.Title,
		&i.Published,
		&i.Writting,
		&i.Abstract,
		&i.Private,
		&i.Writerid,
		&i.Writerusername,
	)
	return &i, err
}

const fetchWritingByIds = `-- name: FetchWritingByIds :many
SELECT w.idwriting, w.users_idusers, w.forumthread_idforumthread, w.language_idlanguage, w.writingcategory_idwritingcategory, w.title, w.published, w.writting, w.abstract, w.private, u.idusers AS WriterId, u.username AS WriterUsername
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN writtingApprovedUsers wau ON w.idwriting = wau.writing_idwriting AND wau.users_idusers = ?
WHERE w.idwriting IN (/*SLICE:writingids*/?) AND (w.private = 0 OR wau.readdoc = 1 OR w.users_idusers = ?)
ORDER BY w.published DESC
`

type FetchWritingByIdsParams struct {
	Userid     int32
	Writingids []int32
}

type FetchWritingByIdsRow struct {
	Idwriting                        int32
	UsersIdusers                     int32
	ForumthreadIdforumthread         int32
	LanguageIdlanguage               int32
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Published                        sql.NullTime
	Writting                         sql.NullString
	Abstract                         sql.NullString
	Private                          sql.NullBool
	Writerid                         int32
	Writerusername                   sql.NullString
}

func (q *Queries) FetchWritingByIds(ctx context.Context, arg FetchWritingByIdsParams) ([]*FetchWritingByIdsRow, error) {
	query := fetchWritingByIds
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Userid)
	if len(arg.Writingids) > 0 {
		for _, v := range arg.Writingids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:writingids*/?", strings.Repeat(",?", len(arg.Writingids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:writingids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Userid)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchWritingByIdsRow
	for rows.Next() {
		var i FetchWritingByIdsRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadIdforumthread,
			&i.LanguageIdlanguage,
			&i.WritingcategoryIdwritingcategory,
			&i.Title,
			&i.Published,
			&i.Writting,
			&i.Abstract,
			&i.Private,
			&i.Writerid,
			&i.Writerusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertWriting = `-- name: InsertWriting :execlastid
INSERT INTO writing (writingCategory_idwritingCategory, title, abstract, writting, private, language_idlanguage, published, users_idusers)
VALUES (?, ?, ?, ?, ?, ?, NOW(), ?)
`

type InsertWritingParams struct {
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Abstract                         sql.NullString
	Writting                         sql.NullString
	Private                          sql.NullBool
	LanguageIdlanguage               int32
	UsersIdusers                     int32
}

func (q *Queries) InsertWriting(ctx context.Context, arg InsertWritingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertWriting,
		arg.WritingcategoryIdwritingcategory,
		arg.Title,
		arg.Abstract,
		arg.Writting,
		arg.Private,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertWritingApproval = `-- name: InsertWritingApproval :exec
INSERT INTO writtingApprovedUsers (writing_idwriting, users_idusers, readdoc, editdoc)
VALUES (?, ?, ?, ?)
`

type InsertWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
	Readdoc          sql.NullBool
	Editdoc          sql.NullBool
}

func (q *Queries) InsertWritingApproval(ctx context.Context, arg InsertWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, insertWritingApproval,
		arg.WritingIdwriting,
		arg.UsersIdusers,
		arg.Readdoc,
		arg.Editdoc,
	)
	return err
}

const insertWritingCategory = `-- name: InsertWritingCategory :exec
INSERT INTO writingCategory (writingCategory_idwritingCategory, title, description)
VALUES (?, ?, ?)
`

type InsertWritingCategoryParams struct {
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Description                      sql.NullString
}

func (q *Queries) InsertWritingCategory(ctx context.Context, arg InsertWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, insertWritingCategory, arg.WritingcategoryIdwritingcategory, arg.Title, arg.Description)
	return err
}

const updateWriting = `-- name: UpdateWriting :exec
UPDATE writing
SET title = ?, abstract = ?, writting = ?, private = ?, language_idlanguage = ?
WHERE idwriting = ?
`

type UpdateWritingParams struct {
	Title              sql.NullString
	Abstract           sql.NullString
	Writting           sql.NullString
	Private            sql.NullBool
	LanguageIdlanguage int32
	Idwriting          int32
}

func (q *Queries) UpdateWriting(ctx context.Context, arg UpdateWritingParams) error {
	_, err := q.db.ExecContext(ctx, updateWriting,
		arg.Title,
		arg.Abstract,
		arg.Writting,
		arg.Private,
		arg.LanguageIdlanguage,
		arg.Idwriting,
	)
	return err
}

const updateWritingApproval = `-- name: UpdateWritingApproval :exec
UPDATE writtingApprovedUsers
SET readdoc = ?, editdoc = ?
WHERE writing_idwriting = ? AND users_idusers = ?
`

type UpdateWritingApprovalParams struct {
	Readdoc          sql.NullBool
	Editdoc          sql.NullBool
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) UpdateWritingApproval(ctx context.Context, arg UpdateWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingApproval,
		arg.Readdoc,
		arg.Editdoc,
		arg.WritingIdwriting,
		arg.UsersIdusers,
	)
	return err
}

const updateWritingCategory = `-- name: UpdateWritingCategory :exec
UPDATE writingCategory
SET title = ?, description = ?, writingCategory_idwritingCategory = ?
WHERE idwritingCategory = ?
`

type UpdateWritingCategoryParams struct {
	Title                            sql.NullString
	Description                      sql.NullString
	WritingcategoryIdwritingcategory int32
	Idwritingcategory                int32
}

func (q *Queries) UpdateWritingCategory(ctx context.Context, arg UpdateWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingCategory,
		arg.Title,
		arg.Description,
		arg.WritingcategoryIdwritingcategory,
		arg.Idwritingcategory,
	)
	return err
}
