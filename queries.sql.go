// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: queries.sql

package main

import (
	"context"
	"database/sql"
)

const selectLanguages = `-- name: SelectLanguages :many
SELECT idlanguage, nameof
FROM language
`

// This query selects all languages from the "language" table.
// Result:
//
//	idlanguage (int)
//	nameof (string)
func (q *Queries) SelectLanguages(ctx context.Context) ([]*Language, error) {
	rows, err := q.db.QueryContext(ctx, selectLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(&i.Idlanguage, &i.Nameof); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const add_blog = `-- name: add_blog :exec
INSERT INTO blogs (users_idusers, language_idlanguage, blog, written)
VALUES (?, ?, ?, NOW())
`

type add_blogParams struct {
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
}

func (q *Queries) add_blog(ctx context.Context, arg add_blogParams) error {
	_, err := q.db.ExecContext(ctx, add_blog, arg.UsersIdusers, arg.LanguageIdlanguage, arg.Blog)
	return err
}

const add_bookmarks = `-- name: add_bookmarks :exec
INSERT INTO bookmarks (users_idusers, list)
VALUES (?, ?)
`

type add_bookmarksParams struct {
	UsersIdusers int32
	List         sql.NullString
}

// This query adds a new entry to the "bookmarks" table and returns the last inserted ID as "returnthis".
func (q *Queries) add_bookmarks(ctx context.Context, arg add_bookmarksParams) error {
	_, err := q.db.ExecContext(ctx, add_bookmarks, arg.UsersIdusers, arg.List)
	return err
}

const adminUserPermissions = `-- name: adminUserPermissions :many
SELECT p.idpermissions, p.level, u.username, u.email, p.section
FROM permissions p, users u
WHERE u.idusers = p.users_idusers
ORDER BY p.level
`

type adminUserPermissionsRow struct {
	Idpermissions int32
	Level         sql.NullString
	Username      sql.NullString
	Email         sql.NullString
	Section       sql.NullString
}

// This query selects permissions information for admin users.
// Result:
//
//	idpermissions (int)
//	level (int)
//	username (string)
//	email (string)
//	section (string)
func (q *Queries) adminUserPermissions(ctx context.Context) ([]*adminUserPermissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminUserPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*adminUserPermissionsRow
	for rows.Next() {
		var i adminUserPermissionsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.Level,
			&i.Username,
			&i.Email,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUsers = `-- name: adminUsers :many
SELECT u.idusers, u.username, u.email
FROM users u
`

type adminUsersRow struct {
	Idusers  int32
	Username sql.NullString
	Email    sql.NullString
}

// This query selects all admin users from the "users" table.
// Result:
//
//	idusers (int)
//	username (string)
//	email (string)
func (q *Queries) adminUsers(ctx context.Context) ([]*adminUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, adminUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*adminUsersRow
	for rows.Next() {
		var i adminUsersRow
		if err := rows.Scan(&i.Idusers, &i.Username, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const admin_user_permissions = `-- name: admin_user_permissions :many
SELECT p.idpermissions, p.level, u.username, u.email, p.section
FROM permissions p, users u
WHERE u.idusers = p.users_idusers AND p.section = ?
ORDER BY p.level
`

type admin_user_permissionsRow struct {
	Idpermissions int32
	Level         sql.NullString
	Username      sql.NullString
	Email         sql.NullString
	Section       sql.NullString
}

func (q *Queries) admin_user_permissions(ctx context.Context, section sql.NullString) ([]*admin_user_permissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, admin_user_permissions, section)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*admin_user_permissionsRow
	for rows.Next() {
		var i admin_user_permissionsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.Level,
			&i.Username,
			&i.Email,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const assign_blog_to_thread = `-- name: assign_blog_to_thread :exec
UPDATE blogs
SET forumthread_idforumthread = ?
WHERE idblogs = ?
`

type assign_blog_to_threadParams struct {
	ForumthreadIdforumthread int32
	Idblogs                  int32
}

func (q *Queries) assign_blog_to_thread(ctx context.Context, arg assign_blog_to_threadParams) error {
	_, err := q.db.ExecContext(ctx, assign_blog_to_thread, arg.ForumthreadIdforumthread, arg.Idblogs)
	return err
}

const blogid_to_userid = `-- name: blogid_to_userid :one
SELECT idusers
FROM users u, blogs b
WHERE u.idusers = b.users_idusers AND b.idblogs = ?
`

func (q *Queries) blogid_to_userid(ctx context.Context, idblogs int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, blogid_to_userid, idblogs)
	var idusers int32
	err := row.Scan(&idusers)
	return idusers, err
}

const completeWordList = `-- name: completeWordList :exec
SELECT word
FROM searchwordlist
`

// This query selects all words from the "searchwordlist" table and prints them.
func (q *Queries) completeWordList(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, completeWordList)
	return err
}

const countCategories = `-- name: countCategories :one
SELECT COUNT(*) AS count
FROM language
`

// This query returns the count of all records in the "language" table.
// Result:
//
//	count(*) - The count of rows in the "language" table (int)
func (q *Queries) countCategories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCategories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLanguage = `-- name: createLanguage :exec
INSERT INTO language (nameof)
VALUES ($1)
`

// This query inserts a new record into the "language" table.
// Parameters:
//
//	$1 - Name of the new language (string)
func (q *Queries) createLanguage(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createLanguage)
	return err
}

const deleteBlogsSearch = `-- name: deleteBlogsSearch :exec
DELETE FROM blogsSearch
`

// This query deletes all data from the "blogsSearch" table.
func (q *Queries) deleteBlogsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteBlogsSearch)
	return err
}

const deleteCommentsSearch = `-- name: deleteCommentsSearch :exec
DELETE FROM commentsSearch
`

// This query deletes all data from the "commentsSearch" table.
func (q *Queries) deleteCommentsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteCommentsSearch)
	return err
}

const deleteLanguage = `-- name: deleteLanguage :exec
DELETE FROM language
WHERE idlanguage = $1
`

// This query deletes a record from the "language" table based on the provided "cid".
// Parameters:
//
//	$1 - Language ID to be deleted (int)
func (q *Queries) deleteLanguage(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteLanguage)
	return err
}

const deleteLinkerSearch = `-- name: deleteLinkerSearch :exec
DELETE FROM linkerSearch
`

// This query deletes all data from the "linkerSearch" table.
func (q *Queries) deleteLinkerSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteLinkerSearch)
	return err
}

const deleteSiteNewsSearch = `-- name: deleteSiteNewsSearch :exec
DELETE FROM siteNewsSearch
`

// This query deletes all data from the "siteNewsSearch" table.
func (q *Queries) deleteSiteNewsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteSiteNewsSearch)
	return err
}

const deleteWritingSearch = `-- name: deleteWritingSearch :exec
DELETE FROM writingSearch
`

// This query deletes all data from the "writingSearch" table.
func (q *Queries) deleteWritingSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteWritingSearch)
	return err
}

const delete_blog = `-- name: delete_blog :exec
DELETE FROM blogs
WHERE idblogs = ?
`

func (q *Queries) delete_blog(ctx context.Context, idblogs int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog, idblogs)
	return err
}

const delete_blog_comments = `-- name: delete_blog_comments :exec
DELETE FROM comments
WHERE forumthread_idforumthread = ?
`

func (q *Queries) delete_blog_comments(ctx context.Context, forumthreadIdforumthread int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog_comments, forumthreadIdforumthread)
	return err
}

const delete_blog_search = `-- name: delete_blog_search :exec
DELETE FROM blogsSearch
WHERE blogs_idblogs = ?
`

func (q *Queries) delete_blog_search(ctx context.Context, blogsIdblogs int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog_search, blogsIdblogs)
	return err
}

const delete_bookmarks = `-- name: delete_bookmarks :exec
DELETE FROM bookmarks
WHERE users_idusers = ?
`

// This query deletes all entries from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) delete_bookmarks(ctx context.Context, usersIdusers int32) error {
	_, err := q.db.ExecContext(ctx, delete_bookmarks, usersIdusers)
	return err
}

const remakeBlogSearch = `-- name: remakeBlogSearch :exec
INSERT INTO blogsSearch (text, blogs_idblogs)
SELECT blog, idblogs
FROM blogs
`

// This query selects data from the "blogs" table and populates the "blogsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "blogsSearch" using the "blogs_idblogs".
func (q *Queries) remakeBlogSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeBlogSearch)
	return err
}

const remakeBlogsSearchInsert = `-- name: remakeBlogsSearchInsert :exec
INSERT INTO blogsSearch (text, blogs_idblogs)
SELECT blog, idblogs
FROM blogs
`

// This query selects data from the "blogs" table and populates the "blogsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "blogsSearch" using the "blogs_idblogs".
func (q *Queries) remakeBlogsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeBlogsSearchInsert)
	return err
}

const remakeCommentsSearch = `-- name: remakeCommentsSearch :exec
INSERT INTO commentsSearch (text, comments_idcomments)
SELECT text, idcomments
FROM comments
`

// This query selects data from the "comments" table and populates the "commentsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "commentsSearch" using the "comments_idcomments".
func (q *Queries) remakeCommentsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeCommentsSearch)
	return err
}

const remakeCommentsSearchInsert = `-- name: remakeCommentsSearchInsert :exec
INSERT INTO commentsSearch (text, comments_idcomments)
SELECT text, idcomments
FROM comments
`

// This query selects data from the "comments" table and populates the "commentsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "commentsSearch" using the "comments_idcomments".
func (q *Queries) remakeCommentsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeCommentsSearchInsert)
	return err
}

const remakeLinkerSearch = `-- name: remakeLinkerSearch :exec
INSERT INTO linkerSearch (text, linker_idlinker)
SELECT CONCAT(title, ' ', description), idlinker
FROM linker
`

// This query selects data from the "linker" table and populates the "linkerSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "linkerSearch" using the "linker_idlinker".
func (q *Queries) remakeLinkerSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeLinkerSearch)
	return err
}

const remakeLinkerSearchInsert = `-- name: remakeLinkerSearchInsert :exec
INSERT INTO linkerSearch (text, linker_idlinker)
SELECT CONCAT(title, ' ', description), idlinker
FROM linker
`

// This query selects data from the "linker" table and populates the "linkerSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "linkerSearch" using the "linker_idlinker".
func (q *Queries) remakeLinkerSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeLinkerSearchInsert)
	return err
}

const remakeNewsSearch = `-- name: remakeNewsSearch :exec
INSERT INTO siteNewsSearch (text, siteNews_idsiteNews)
SELECT news, idsiteNews
FROM siteNews
`

// This query selects data from the "siteNews" table and populates the "siteNewsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "siteNewsSearch" using the "siteNews_idsiteNews".
func (q *Queries) remakeNewsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeNewsSearch)
	return err
}

const remakeNewsSearchInsert = `-- name: remakeNewsSearchInsert :exec
INSERT INTO siteNewsSearch (text, siteNews_idsiteNews)
SELECT news, idsiteNews
FROM siteNews
`

// This query selects data from the "siteNews" table and populates the "siteNewsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "siteNewsSearch" using the "siteNews_idsiteNews".
func (q *Queries) remakeNewsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeNewsSearchInsert)
	return err
}

const remakeWritingSearch = `-- name: remakeWritingSearch :exec
INSERT INTO writingSearch (text, writing_idwriting)
SELECT CONCAT(title, ' ', abstract, ' ', writting), idwriting
FROM writing
`

// This query selects data from the "writing" table and populates the "writingSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "writingSearch" using the "writing_idwriting".
func (q *Queries) remakeWritingSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeWritingSearch)
	return err
}

const remakeWritingSearchInsert = `-- name: remakeWritingSearchInsert :exec
INSERT INTO writingSearch (text, writing_idwriting)
SELECT CONCAT(title, ' ', abstract, ' ', writting), idwriting
FROM writing
`

// This query selects data from the "writing" table and populates the "writingSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "writingSearch" using the "writing_idwriting".
func (q *Queries) remakeWritingSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeWritingSearchInsert)
	return err
}

const renameLanguage = `-- name: renameLanguage :exec
UPDATE language
SET nameof = $1
WHERE idlanguage = $2
`

// This query updates the "nameof" field in the "language" table based on the provided "cid".
// Parameters:
//
//	$1 - New name for the language (string)
//	$2 - Language ID to be updated (int)
func (q *Queries) renameLanguage(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, renameLanguage)
	return err
}

const show_blog_comments = `-- name: show_blog_comments :many
SELECT b.blog, b.written, u.username, b.idblogs, b.forumthread_idforumthread
FROM blogs b, users u
WHERE b.users_idusers = u.idusers AND b.idblogs = ?
`

type show_blog_commentsRow struct {
	Blog                     sql.NullString
	Written                  sql.NullTime
	Username                 sql.NullString
	Idblogs                  int32
	ForumthreadIdforumthread int32
}

func (q *Queries) show_blog_comments(ctx context.Context, idblogs int32) ([]*show_blog_commentsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_blog_comments, idblogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_blog_commentsRow
	for rows.Next() {
		var i show_blog_commentsRow
		if err := rows.Scan(
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Idblogs,
			&i.ForumthreadIdforumthread,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_blog_edit = `-- name: show_blog_edit :many
SELECT b.blog, b.language_idlanguage
FROM blogs b, users u
WHERE b.users_idusers = u.idusers AND b.idblogs = ?
`

type show_blog_editRow struct {
	Blog               sql.NullString
	LanguageIdlanguage int32
}

func (q *Queries) show_blog_edit(ctx context.Context, idblogs int32) ([]*show_blog_editRow, error) {
	rows, err := q.db.QueryContext(ctx, show_blog_edit, idblogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_blog_editRow
	for rows.Next() {
		var i show_blog_editRow
		if err := rows.Scan(&i.Blog, &i.LanguageIdlanguage); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_blogger_list = `-- name: show_blogger_list :many
SELECT u.username, COUNT(b.idblogs)
FROM blogs b, users u
WHERE b.users_idusers = u.idusers
GROUP BY u.idusers
`

type show_blogger_listRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) show_blogger_list(ctx context.Context) ([]*show_blogger_listRow, error) {
	rows, err := q.db.QueryContext(ctx, show_blogger_list)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_blogger_listRow
	for rows.Next() {
		var i show_blogger_listRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_bookmarks = `-- name: show_bookmarks :one
SELECT list
FROM bookmarks
WHERE users_idusers = ?
`

// This query retrieves the "list" from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) show_bookmarks(ctx context.Context, usersIdusers int32) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, show_bookmarks, usersIdusers)
	var list sql.NullString
	err := row.Scan(&list)
	return list, err
}

const show_latest_blogs = `-- name: show_latest_blogs :many
SELECT b.blog, b.written, u.username, b.idblogs, IF(th.comments IS NULL, 0, th.comments + 1), b.users_idusers
FROM blogs b, users u
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE b.users_idusers = ? AND (b.language_idlanguage = ?)
ORDER BY b.written DESC
LIMIT ? OFFSET ?
`

type show_latest_blogsParams struct {
	UsersIdusers       int32
	LanguageIdlanguage int32
	Limit              int32
	Offset             int32
}

type show_latest_blogsRow struct {
	Blog         sql.NullString
	Written      sql.NullTime
	Username     sql.NullString
	Idblogs      int32
	If           interface{}
	UsersIdusers int32
}

func (q *Queries) show_latest_blogs(ctx context.Context, arg show_latest_blogsParams) ([]*show_latest_blogsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_latest_blogs,
		arg.UsersIdusers,
		arg.LanguageIdlanguage,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_latest_blogsRow
	for rows.Next() {
		var i show_latest_blogsRow
		if err := rows.Scan(
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Idblogs,
			&i.If,
			&i.UsersIdusers,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const update_blog = `-- name: update_blog :exec
UPDATE blogs
SET language_idlanguage = ?, blog = ?
WHERE idblogs = ?
`

type update_blogParams struct {
	LanguageIdlanguage int32
	Blog               sql.NullString
	Idblogs            int32
}

func (q *Queries) update_blog(ctx context.Context, arg update_blogParams) error {
	_, err := q.db.ExecContext(ctx, update_blog, arg.LanguageIdlanguage, arg.Blog, arg.Idblogs)
	return err
}

const update_bookmarks = `-- name: update_bookmarks :exec
UPDATE bookmarks
SET list = ?
WHERE users_idusers = ?
`

type update_bookmarksParams struct {
	List         sql.NullString
	UsersIdusers int32
}

// This query updates the "list" column in the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) update_bookmarks(ctx context.Context, arg update_bookmarksParams) error {
	_, err := q.db.ExecContext(ctx, update_bookmarks, arg.List, arg.UsersIdusers)
	return err
}

const update_forumthread_comments = `-- name: update_forumthread_comments :exec
UPDATE forumthread
SET comments = (
    SELECT COUNT(users_idusers) - 1
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
)
`

// This query updates the "comments" column in the "forumthread" table.
// It sets the "comments" column to the count of users (excluding the thread creator) from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_comments(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_comments)
	return err
}

const update_forumthread_firstpost = `-- name: update_forumthread_firstpost :exec
UPDATE forumthread
SET firstpost = (
    SELECT idcomments
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    LIMIT 1
)
`

// This query updates the "firstpost" column in the "forumthread" table.
// It sets the "firstpost" column to the ID of the first comment from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_firstpost(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_firstpost)
	return err
}

const update_forumthread_lastaddition = `-- name: update_forumthread_lastaddition :exec
UPDATE forumthread
SET lastaddition = (
    SELECT written
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
)
`

// This query updates the "lastaddition" column in the "forumthread" table.
// It sets the "lastaddition" column to the latest "written" value from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_lastaddition(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_lastaddition)
	return err
}

const update_forumthread_lastposter = `-- name: update_forumthread_lastposter :exec
UPDATE forumthread
SET lastposter = (
    SELECT users_idusers
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
)
`

// This query updates the "lastposter" column in the "forumthread" table.
// It sets the "lastposter" column to the latest "users_idusers" value from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_lastposter(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_lastposter)
	return err
}

const update_forumtopic_comments = `-- name: update_forumtopic_comments :exec
UPDATE forumtopic
SET comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
)
`

// This query updates the "comments" column in the "forumtopic" table.
// It sets the "comments" column to the sum of comments from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
func (q *Queries) update_forumtopic_comments(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic_comments)
	return err
}

const update_forumtopic_lastaddition_lastposter = `-- name: update_forumtopic_lastaddition_lastposter :exec
UPDATE forumtopic
SET lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
),
lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
`

// This query updates the "lastaddition" and "lastposter" columns in the "forumtopic" table.
// It sets the "lastaddition" column to the latest "lastaddition" value from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
// It sets the "lastposter" column to the latest "lastposter" value from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
func (q *Queries) update_forumtopic_lastaddition_lastposter(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic_lastaddition_lastposter)
	return err
}

const update_forumtopic_threads = `-- name: update_forumtopic_threads :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
)
`

// This query updates the "threads" column in the "forumtopic" table.
// It sets the "threads" column to the count of forum threads from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
func (q *Queries) update_forumtopic_threads(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic_threads)
	return err
}

const userAllow = `-- name: userAllow :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES ($1, $2, $3)
`

// This query inserts a new permission into the "permissions" table.
// Parameters:
//
//	$1 - User ID to be associated with the permission (int)
//	$2 - Section for which the permission is granted (string)
//	$3 - Level of the permission (string)
func (q *Queries) userAllow(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, userAllow)
	return err
}

const userDisallow = `-- name: userDisallow :exec
DELETE FROM permissions
WHERE idpermissions = $1
`

// This query deletes a permission from the "permissions" table based on the provided "permid".
// Parameters:
//
//	$1 - Permission ID to be deleted (int)
func (q *Queries) userDisallow(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, userDisallow)
	return err
}

const user_allow = `-- name: user_allow :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES (?, ?, ?)
`

type user_allowParams struct {
	UsersIdusers int32
	Section      sql.NullString
	Level        sql.NullString
}

func (q *Queries) user_allow(ctx context.Context, arg user_allowParams) error {
	_, err := q.db.ExecContext(ctx, user_allow, arg.UsersIdusers, arg.Section, arg.Level)
	return err
}

const user_disallow = `-- name: user_disallow :exec
DELETE FROM permissions
WHERE idpermissions = ? AND section = ?
`

type user_disallowParams struct {
	Idpermissions int32
	Section       sql.NullString
}

func (q *Queries) user_disallow(ctx context.Context, arg user_disallowParams) error {
	_, err := q.db.ExecContext(ctx, user_disallow, arg.Idpermissions, arg.Section)
	return err
}

const users_bookmarks = `-- name: users_bookmarks :one
SELECT list
FROM bookmarks
WHERE users_idusers = ?
`

// This query retrieves the "list" from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) users_bookmarks(ctx context.Context, usersIdusers int32) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, users_bookmarks, usersIdusers)
	var list sql.NullString
	err := row.Scan(&list)
	return list, err
}

const write_blog_atom = `-- name: write_blog_atom :many
SELECT b.idblogs, LEFT(b.written, 255), b.blog, u.username
FROM blogs b, users u
WHERE u.idusers = b.users_idusers AND b.users_idusers = ?
ORDER BY b.written DESC
LIMIT ?
`

type write_blog_atomParams struct {
	UsersIdusers int32
	Limit        int32
}

type write_blog_atomRow struct {
	Idblogs  int32
	Left     string
	Blog     sql.NullString
	Username sql.NullString
}

func (q *Queries) write_blog_atom(ctx context.Context, arg write_blog_atomParams) ([]*write_blog_atomRow, error) {
	rows, err := q.db.QueryContext(ctx, write_blog_atom, arg.UsersIdusers, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*write_blog_atomRow
	for rows.Next() {
		var i write_blog_atomRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.Left,
			&i.Blog,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const write_blog_rss = `-- name: write_blog_rss :many
SELECT b.idblogs, LEFT(b.written, 255), b.blog, u.username
FROM blogs b, users u
WHERE u.idusers = b.users_idusers AND b.users_idusers= ?
ORDER BY b.written DESC
LIMIT ?
`

type write_blog_rssParams struct {
	UsersIdusers int32
	Limit        int32
}

type write_blog_rssRow struct {
	Idblogs  int32
	Left     string
	Blog     sql.NullString
	Username sql.NullString
}

func (q *Queries) write_blog_rss(ctx context.Context, arg write_blog_rssParams) ([]*write_blog_rssRow, error) {
	rows, err := q.db.QueryContext(ctx, write_blog_rss, arg.UsersIdusers, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*write_blog_rssRow
	for rows.Next() {
		var i write_blog_rssRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.Left,
			&i.Blog,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
