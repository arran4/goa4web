// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: queries.sql

package main

import (
	"context"
	"database/sql"
	"time"
)

const allQuestions = `-- name: AllQuestions :many
SELECT idfaq, faqcategories_idfaqcategories, language_idlanguage, users_idusers, answer, question
FROM faq
`

func (q *Queries) AllQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, allQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkExistingUser = `-- name: CheckExistingUser :one
SELECT username FROM users WHERE username = ?
`

func (q *Queries) CheckExistingUser(ctx context.Context, username sql.NullString) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, checkExistingUser, username)
	err := row.Scan(&username)
	return username, err
}

const insertUser = `-- name: InsertUser :execresult
INSERT INTO users (username, passwd, email)
VALUES (?, MD5(?), ?)
`

type InsertUserParams struct {
	Username sql.NullString
	MD5      string
	Email    sql.NullString
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertUser, arg.Username, arg.MD5, arg.Email)
}

const login = `-- name: Login :one
SELECT idusers FROM users
WHERE username = ? AND passwd = md5(?)
`

type LoginParams struct {
	Username sql.NullString
	MD5      string
}

func (q *Queries) Login(ctx context.Context, arg LoginParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, login, arg.Username, arg.MD5)
	var idusers int32
	err := row.Scan(&idusers)
	return idusers, err
}

const selectLanguages = `-- name: SelectLanguages :many
SELECT idlanguage, nameof
FROM language
`

// This query selects all languages from the "language" table.
// Result:
//
//	idlanguage (int)
//	nameof (string)
func (q *Queries) SelectLanguages(ctx context.Context) ([]*Language, error) {
	rows, err := q.db.QueryContext(ctx, selectLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(&i.Idlanguage, &i.Nameof); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUnansweredQuestions = `-- name: SelectUnansweredQuestions :many
SELECT idfaq, faqcategories_idfaqcategories, language_idlanguage, users_idusers, answer, question
FROM faq
WHERE faqCategories_idfaqCategories = '0' OR answer IS NULL
`

func (q *Queries) SelectUnansweredQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, selectUnansweredQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addImage = `-- name: addImage :exec
INSERT INTO imagepost (imageboard_idimageboard, thumbnail, fullimage, users_idusers, description, posted)
VALUES (?, ?, ?, ?, ?, NOW())
`

type addImageParams struct {
	ImageboardIdimageboard int32
	Thumbnail              sql.NullString
	Fullimage              sql.NullString
	UsersIdusers           int32
	Description            sql.NullString
}

func (q *Queries) addImage(ctx context.Context, arg addImageParams) error {
	_, err := q.db.ExecContext(ctx, addImage,
		arg.ImageboardIdimageboard,
		arg.Thumbnail,
		arg.Fullimage,
		arg.UsersIdusers,
		arg.Description,
	)
	return err
}

const addToForumCommentSearch = `-- name: addToForumCommentSearch :exec

INSERT IGNORE INTO commentsSearch
(comments_idcomments, searchwordlist_idsearchwordlist)
VALUES (?, ?)
`

type addToForumCommentSearchParams struct {
	CommentsIdcomments             int32
	SearchwordlistIdsearchwordlist int32
}

// -- name: addToGeneralSearch :exec
// INSERT INTO ? (?, searchwordlist_idsearchwordlist) VALUES (?, ?)
func (q *Queries) addToForumCommentSearch(ctx context.Context, arg addToForumCommentSearchParams) error {
	_, err := q.db.ExecContext(ctx, addToForumCommentSearch, arg.CommentsIdcomments, arg.SearchwordlistIdsearchwordlist)
	return err
}

const addToLinker = `-- name: addToLinker :exec
INSERT INTO linker (users_idusers, linkerCategory_idlinkerCategory, title, url, description, listed)
VALUES (?, ?, ?, ?, ?, NOW())
`

type addToLinkerParams struct {
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
}

func (q *Queries) addToLinker(ctx context.Context, arg addToLinkerParams) error {
	_, err := q.db.ExecContext(ctx, addToLinker,
		arg.UsersIdusers,
		arg.LinkercategoryIdlinkercategory,
		arg.Title,
		arg.Url,
		arg.Description,
	)
	return err
}

const addToQueue = `-- name: addToQueue :exec
INSERT INTO linkerQueue (users_idusers, linkerCategory_idlinkerCategory, title, url, description) VALUES (?, ?, ?, ?, ?)
`

type addToQueueParams struct {
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
}

func (q *Queries) addToQueue(ctx context.Context, arg addToQueueParams) error {
	_, err := q.db.ExecContext(ctx, addToQueue,
		arg.UsersIdusers,
		arg.LinkercategoryIdlinkercategory,
		arg.Title,
		arg.Url,
		arg.Description,
	)
	return err
}

const addTopicRestrictions = `-- name: addTopicRestrictions :exec
INSERT INTO topicrestrictions (forumtopic_idforumtopic, viewlevel, replylevel, newthreadlevel, seelevel, invitelevel, readlevel, modlevel, adminlevel)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type addTopicRestrictionsParams struct {
	ForumtopicIdforumtopic int32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) addTopicRestrictions(ctx context.Context, arg addTopicRestrictionsParams) error {
	_, err := q.db.ExecContext(ctx, addTopicRestrictions,
		arg.ForumtopicIdforumtopic,
		arg.Viewlevel,
		arg.Replylevel,
		arg.Newthreadlevel,
		arg.Seelevel,
		arg.Invitelevel,
		arg.Readlevel,
		arg.Modlevel,
		arg.Adminlevel,
	)
	return err
}

const addUsersTopicLevel = `-- name: addUsersTopicLevel :exec
INSERT INTO userstopiclevel (forumtopic_idforumtopic, users_idusers, level, invitemax)
VALUES (?, ?, ?, ?)
`

type addUsersTopicLevelParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
	Level                  sql.NullInt32
	Invitemax              sql.NullInt32
}

func (q *Queries) addUsersTopicLevel(ctx context.Context, arg addUsersTopicLevelParams) error {
	_, err := q.db.ExecContext(ctx, addUsersTopicLevel,
		arg.ForumtopicIdforumtopic,
		arg.UsersIdusers,
		arg.Level,
		arg.Invitemax,
	)
	return err
}

const addWord = `-- name: addWord :execlastid
INSERT IGNORE INTO searchwordlist (word)
VALUES (lcase(?))
`

func (q *Queries) addWord(ctx context.Context, word string) (int64, error) {
	result, err := q.db.ExecContext(ctx, addWord, word)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const add_blog = `-- name: add_blog :execlastid
INSERT INTO blogs (users_idusers, language_idlanguage, blog, written)
VALUES (?, ?, ?, NOW())
`

type add_blogParams struct {
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
}

func (q *Queries) add_blog(ctx context.Context, arg add_blogParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, add_blog, arg.UsersIdusers, arg.LanguageIdlanguage, arg.Blog)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const add_bookmarks = `-- name: add_bookmarks :exec
INSERT INTO bookmarks (users_idusers, list)
VALUES (?, ?)
`

type add_bookmarksParams struct {
	UsersIdusers int32
	List         sql.NullString
}

// This query adds a new entry to the "bookmarks" table and returns the last inserted ID as "returnthis".
func (q *Queries) add_bookmarks(ctx context.Context, arg add_bookmarksParams) error {
	_, err := q.db.ExecContext(ctx, add_bookmarks, arg.UsersIdusers, arg.List)
	return err
}

const add_question = `-- name: add_question :exec
INSERT INTO faq (question, users_idusers, language_idlanguage)
VALUES (?, ?, ?)
`

type add_questionParams struct {
	Question           sql.NullString
	UsersIdusers       int32
	LanguageIdlanguage int32
}

func (q *Queries) add_question(ctx context.Context, arg add_questionParams) error {
	_, err := q.db.ExecContext(ctx, add_question, arg.Question, arg.UsersIdusers, arg.LanguageIdlanguage)
	return err
}

const adminCategories = `-- name: adminCategories :many
SELECT idlinkerCategory, title FROM linkerCategory
`

func (q *Queries) adminCategories(ctx context.Context) ([]*Linkercategory, error) {
	rows, err := q.db.QueryContext(ctx, adminCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Linkercategory
	for rows.Next() {
		var i Linkercategory
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const admin_categories = `-- name: admin_categories :many
SELECT idfaqCategories, name
FROM faqCategories
`

func (q *Queries) admin_categories(ctx context.Context) ([]*Faqcategory, error) {
	rows, err := q.db.QueryContext(ctx, admin_categories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faqcategory
	for rows.Next() {
		var i Faqcategory
		if err := rows.Scan(&i.Idfaqcategories, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const admin_user_permissions = `-- name: admin_user_permissions :many
SELECT p.idpermissions, p.level, u.username, u.email, p.section
FROM permissions p, users u
WHERE u.idusers = p.users_idusers AND p.section = ?
ORDER BY p.level
`

type admin_user_permissionsRow struct {
	Idpermissions int32
	Level         sql.NullString
	Username      sql.NullString
	Email         sql.NullString
	Section       sql.NullString
}

func (q *Queries) admin_user_permissions(ctx context.Context, section sql.NullString) ([]*admin_user_permissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, admin_user_permissions, section)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*admin_user_permissionsRow
	for rows.Next() {
		var i admin_user_permissionsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.Level,
			&i.Username,
			&i.Email,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allUsers = `-- name: allUsers :many
SELECT u.idusers, u.email, u.passwd, u.username
FROM users u
`

// This query selects all admin users from the "users" table.
// Result:
//
//	idusers (int)
//	username (string)
//	email (string)
func (q *Queries) allUsers(ctx context.Context) ([]*User, error) {
	rows, err := q.db.QueryContext(ctx, allUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const assignImagePostThisThreadId = `-- name: assignImagePostThisThreadId :exec
UPDATE imagepost SET forumthread_idforumthread = ? WHERE idimagepost = ?
`

type assignImagePostThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idimagepost              int32
}

func (q *Queries) assignImagePostThisThreadId(ctx context.Context, arg assignImagePostThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignImagePostThisThreadId, arg.ForumthreadIdforumthread, arg.Idimagepost)
	return err
}

const assignLinkerThisThreadId = `-- name: assignLinkerThisThreadId :exec
UPDATE linker SET forumthread_idforumthread = ? WHERE idlinker = ?
`

type assignLinkerThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idlinker                 int32
}

func (q *Queries) assignLinkerThisThreadId(ctx context.Context, arg assignLinkerThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignLinkerThisThreadId, arg.ForumthreadIdforumthread, arg.Idlinker)
	return err
}

const assignNewsThisThreadId = `-- name: assignNewsThisThreadId :exec
UPDATE siteNews SET forumthread_idforumthread = ? WHERE idsiteNews = ?
`

type assignNewsThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idsitenews               int32
}

func (q *Queries) assignNewsThisThreadId(ctx context.Context, arg assignNewsThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignNewsThisThreadId, arg.ForumthreadIdforumthread, arg.Idsitenews)
	return err
}

const assign_blog_to_thread = `-- name: assign_blog_to_thread :exec
UPDATE blogs
SET forumthread_idforumthread = ?
WHERE idblogs = ?
`

type assign_blog_to_threadParams struct {
	ForumthreadIdforumthread int32
	Idblogs                  int32
}

func (q *Queries) assign_blog_to_thread(ctx context.Context, arg assign_blog_to_threadParams) error {
	_, err := q.db.ExecContext(ctx, assign_blog_to_thread, arg.ForumthreadIdforumthread, arg.Idblogs)
	return err
}

const blogid_to_userid = `-- name: blogid_to_userid :one
SELECT idusers
FROM users u, blogs b
WHERE u.idusers = b.users_idusers AND b.idblogs = ?
`

func (q *Queries) blogid_to_userid(ctx context.Context, idblogs int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, blogid_to_userid, idblogs)
	var idusers int32
	err := row.Scan(&idusers)
	return idusers, err
}

const blogsUserPermissions = `-- name: blogsUserPermissions :many
SELECT p.idpermissions, p.level, u.username, u.email, p.section
FROM permissions p, users u
WHERE u.idusers = p.users_idusers AND p.section = "blogs"
ORDER BY p.level
`

type blogsUserPermissionsRow struct {
	Idpermissions int32
	Level         sql.NullString
	Username      sql.NullString
	Email         sql.NullString
	Section       sql.NullString
}

func (q *Queries) blogsUserPermissions(ctx context.Context) ([]*blogsUserPermissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, blogsUserPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*blogsUserPermissionsRow
	for rows.Next() {
		var i blogsUserPermissionsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.Level,
			&i.Username,
			&i.Email,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const category_combobox = `-- name: category_combobox :many
SELECT idlinkerCategory, title FROM linkerCategory
`

func (q *Queries) category_combobox(ctx context.Context) ([]*Linkercategory, error) {
	rows, err := q.db.QueryContext(ctx, category_combobox)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Linkercategory
	for rows.Next() {
		var i Linkercategory
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const category_faqs = `-- name: category_faqs :many
SELECT question, idfaq, answer, faqCategories_idfaqCategories
FROM faq
WHERE faqCategories_idfaqCategories = ? OR answer IS NULL
`

type category_faqsRow struct {
	Question                     sql.NullString
	Idfaq                        int32
	Answer                       sql.NullString
	FaqcategoriesIdfaqcategories int32
}

func (q *Queries) category_faqs(ctx context.Context, faqcategoriesIdfaqcategories int32) ([]*category_faqsRow, error) {
	rows, err := q.db.QueryContext(ctx, category_faqs, faqcategoriesIdfaqcategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*category_faqsRow
	for rows.Next() {
		var i category_faqsRow
		if err := rows.Scan(
			&i.Question,
			&i.Idfaq,
			&i.Answer,
			&i.FaqcategoriesIdfaqcategories,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const changeCategory = `-- name: changeCategory :exec
UPDATE forumcategory SET title = ?, description = ?, forumcategory_idforumcategory = ? WHERE idforumcategory = ?
`

type changeCategoryParams struct {
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	Idforumcategory              int32
}

func (q *Queries) changeCategory(ctx context.Context, arg changeCategoryParams) error {
	_, err := q.db.ExecContext(ctx, changeCategory,
		arg.Title,
		arg.Description,
		arg.ForumcategoryIdforumcategory,
		arg.Idforumcategory,
	)
	return err
}

const changeImageBoard = `-- name: changeImageBoard :exec
UPDATE imageboard SET title = ?, description = ?, imageboard_idimageboard = ? WHERE idimageboard = ?
`

type changeImageBoardParams struct {
	Title                  sql.NullString
	Description            sql.NullString
	ImageboardIdimageboard int32
	Idimageboard           int32
}

func (q *Queries) changeImageBoard(ctx context.Context, arg changeImageBoardParams) error {
	_, err := q.db.ExecContext(ctx, changeImageBoard,
		arg.Title,
		arg.Description,
		arg.ImageboardIdimageboard,
		arg.Idimageboard,
	)
	return err
}

const changeTopic = `-- name: changeTopic :exec
UPDATE forumtopic SET title = ?, description = ?, forumcategory_idforumcategory = ? WHERE idforumtopic = ?
`

type changeTopicParams struct {
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	Idforumtopic                 int32
}

func (q *Queries) changeTopic(ctx context.Context, arg changeTopicParams) error {
	_, err := q.db.ExecContext(ctx, changeTopic,
		arg.Title,
		arg.Description,
		arg.ForumcategoryIdforumcategory,
		arg.Idforumtopic,
	)
	return err
}

const completeWordList = `-- name: completeWordList :many
SELECT word
FROM searchwordlist
`

// This query selects all words from the "searchwordlist" table and prints them.
func (q *Queries) completeWordList(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, completeWordList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var word sql.NullString
		if err := rows.Scan(&word); err != nil {
			return nil, err
		}
		items = append(items, word)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countCategories = `-- name: countCategories :one
SELECT COUNT(*) AS count
FROM language
`

// This query returns the count of all records in the "language" table.
// Result:
//
//	count(*) - The count of rows in the "language" table (int)
func (q *Queries) countCategories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCategories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLinkerCategories = `-- name: countLinkerCategories :one


SELECT COUNT(*) FROM linkerCategory
`

// -- name: showNews :one
// SELECT count(idsiteNews) FROM siteNews
// WHERE ? AND ?;
// -- name: showNewsPosts :many
// SELECT u.username, s.news, s.occured, s.idsiteNews, u.idusers, IF(th.comments IS NULL, 0, th.comments + 1)
// FROM siteNews s
// LEFT JOIN users u ON s.users_idusers = u.idusers
// LEFT JOIN forumthread th ON s.forumthread_idforumthread = th.idforumthread
// WHERE ? AND ?
// ORDER BY s.occured DESC
// LIMIT 10;
func (q *Queries) countLinkerCategories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLinkerCategories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const count_categories = `-- name: count_categories :one
SELECT COUNT(*) FROM faqCategories
`

func (q *Queries) count_categories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, count_categories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCategory = `-- name: createCategory :exec
INSERT INTO linkerCategory (title) VALUES (?)
`

func (q *Queries) createCategory(ctx context.Context, title sql.NullString) error {
	_, err := q.db.ExecContext(ctx, createCategory, title)
	return err
}

const createLanguage = `-- name: createLanguage :exec
INSERT INTO language (nameof)
VALUES (?)
`

// This query inserts a new record into the "language" table.
// Parameters:
//
//	? - Name of the new language (string)
func (q *Queries) createLanguage(ctx context.Context, nameof sql.NullString) error {
	_, err := q.db.ExecContext(ctx, createLanguage, nameof)
	return err
}

const create_category = `-- name: create_category :exec
INSERT INTO faqCategories (name)
VALUES (?)
`

func (q *Queries) create_category(ctx context.Context, name sql.NullString) error {
	_, err := q.db.ExecContext(ctx, create_category, name)
	return err
}

const deleteBlogsSearch = `-- name: deleteBlogsSearch :exec
DELETE FROM blogsSearch
`

// This query deletes all data from the "blogsSearch" table.
func (q *Queries) deleteBlogsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteBlogsSearch)
	return err
}

const deleteCategory = `-- name: deleteCategory :exec
DELETE FROM linkerCategory WHERE idlinkerCategory = ?
`

func (q *Queries) deleteCategory(ctx context.Context, idlinkercategory int32) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, idlinkercategory)
	return err
}

const deleteCommentsSearch = `-- name: deleteCommentsSearch :exec
DELETE FROM commentsSearch
`

// This query deletes all data from the "commentsSearch" table.
func (q *Queries) deleteCommentsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteCommentsSearch)
	return err
}

const deleteLanguage = `-- name: deleteLanguage :exec
DELETE FROM language
WHERE idlanguage = ?
`

// This query deletes a record from the "language" table based on the provided "cid".
// Parameters:
//
//	? - Language ID to be deleted (int)
func (q *Queries) deleteLanguage(ctx context.Context, idlanguage int32) error {
	_, err := q.db.ExecContext(ctx, deleteLanguage, idlanguage)
	return err
}

const deleteLinkerSearch = `-- name: deleteLinkerSearch :exec
DELETE FROM linkerSearch
`

// This query deletes all data from the "linkerSearch" table.
func (q *Queries) deleteLinkerSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteLinkerSearch)
	return err
}

const deletePagePermission = `-- name: deletePagePermission :exec
DELETE FROM permissions WHERE idpermissions = ? AND section = ?
`

type deletePagePermissionParams struct {
	Idpermissions int32
	Section       sql.NullString
}

func (q *Queries) deletePagePermission(ctx context.Context, arg deletePagePermissionParams) error {
	_, err := q.db.ExecContext(ctx, deletePagePermission, arg.Idpermissions, arg.Section)
	return err
}

const deleteQueueItem = `-- name: deleteQueueItem :exec
DELETE FROM linkerQueue WHERE idlinkerQueue = ?
`

func (q *Queries) deleteQueueItem(ctx context.Context, idlinkerqueue int32) error {
	_, err := q.db.ExecContext(ctx, deleteQueueItem, idlinkerqueue)
	return err
}

const deleteSiteNewsSearch = `-- name: deleteSiteNewsSearch :exec
DELETE FROM siteNewsSearch
`

// This query deletes all data from the "siteNewsSearch" table.
func (q *Queries) deleteSiteNewsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteSiteNewsSearch)
	return err
}

const deleteTopicRestrictions = `-- name: deleteTopicRestrictions :exec
DELETE FROM topicrestrictions WHERE forumtopic_idforumtopic = ?
`

func (q *Queries) deleteTopicRestrictions(ctx context.Context, forumtopicIdforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, deleteTopicRestrictions, forumtopicIdforumtopic)
	return err
}

const deleteUserLanguage = `-- name: deleteUserLanguage :exec
DELETE FROM userlang WHERE users_idusers = ?
`

func (q *Queries) deleteUserLanguage(ctx context.Context, usersIdusers int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserLanguage, usersIdusers)
	return err
}

const deleteUsersTopicLevel = `-- name: deleteUsersTopicLevel :exec
DELETE FROM userstopiclevel WHERE forumtopic_idforumtopic = ? AND users_idusers = ?
`

type deleteUsersTopicLevelParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
}

func (q *Queries) deleteUsersTopicLevel(ctx context.Context, arg deleteUsersTopicLevelParams) error {
	_, err := q.db.ExecContext(ctx, deleteUsersTopicLevel, arg.ForumtopicIdforumtopic, arg.UsersIdusers)
	return err
}

const deleteWritingApproval = `-- name: deleteWritingApproval :exec
DELETE FROM writtingApprovedUsers
WHERE writing_idwriting = ? AND users_idusers = ?
`

type deleteWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) deleteWritingApproval(ctx context.Context, arg deleteWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, deleteWritingApproval, arg.WritingIdwriting, arg.UsersIdusers)
	return err
}

const deleteWritingSearch = `-- name: deleteWritingSearch :exec
DELETE FROM writingSearch
`

// This query deletes all data from the "writingSearch" table.
func (q *Queries) deleteWritingSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteWritingSearch)
	return err
}

const delete_blog = `-- name: delete_blog :exec
DELETE FROM blogs
WHERE idblogs = ?
`

func (q *Queries) delete_blog(ctx context.Context, idblogs int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog, idblogs)
	return err
}

const delete_blog_comments = `-- name: delete_blog_comments :exec
DELETE FROM comments
WHERE forumthread_idforumthread = ?
`

func (q *Queries) delete_blog_comments(ctx context.Context, forumthreadIdforumthread int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog_comments, forumthreadIdforumthread)
	return err
}

const delete_blog_search = `-- name: delete_blog_search :exec
DELETE FROM blogsSearch
WHERE blogs_idblogs = ?
`

func (q *Queries) delete_blog_search(ctx context.Context, blogsIdblogs int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog_search, blogsIdblogs)
	return err
}

const delete_bookmarks = `-- name: delete_bookmarks :exec
DELETE FROM bookmarks
WHERE users_idusers = ?
`

// This query deletes all entries from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) delete_bookmarks(ctx context.Context, usersIdusers int32) error {
	_, err := q.db.ExecContext(ctx, delete_bookmarks, usersIdusers)
	return err
}

const delete_category = `-- name: delete_category :exec
DELETE FROM faqCategories
WHERE idfaqCategories = ?
`

func (q *Queries) delete_category(ctx context.Context, idfaqcategories int32) error {
	_, err := q.db.ExecContext(ctx, delete_category, idfaqcategories)
	return err
}

const delete_faq = `-- name: delete_faq :exec
DELETE FROM faq
WHERE idfaq = ?
`

func (q *Queries) delete_faq(ctx context.Context, idfaq int32) error {
	_, err := q.db.ExecContext(ctx, delete_faq, idfaq)
	return err
}

const doCalled = `-- name: doCalled :many
SELECT s.news, s.idsiteNews, u.idusers, s.language_idlanguage
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
WHERE s.idsiteNews = ?
`

type doCalledRow struct {
	News               sql.NullString
	Idsitenews         int32
	Idusers            sql.NullInt32
	LanguageIdlanguage int32
}

func (q *Queries) doCalled(ctx context.Context, idsitenews int32) ([]*doCalledRow, error) {
	rows, err := q.db.QueryContext(ctx, doCalled, idsitenews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*doCalledRow
	for rows.Next() {
		var i doCalledRow
		if err := rows.Scan(
			&i.News,
			&i.Idsitenews,
			&i.Idusers,
			&i.LanguageIdlanguage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const editNewsPost = `-- name: editNewsPost :exec
UPDATE siteNews SET news = ?, language_idlanguage = ? WHERE idsiteNews = ?
`

type editNewsPostParams struct {
	News               sql.NullString
	LanguageIdlanguage int32
	Idsitenews         int32
}

func (q *Queries) editNewsPost(ctx context.Context, arg editNewsPostParams) error {
	_, err := q.db.ExecContext(ctx, editNewsPost, arg.News, arg.LanguageIdlanguage, arg.Idsitenews)
	return err
}

const existsTopicRestrictions = `-- name: existsTopicRestrictions :one
SELECT (forumtopic_idforumtopic) FROM topicrestrictions WHERE forumtopic_idforumtopic = ?
`

func (q *Queries) existsTopicRestrictions(ctx context.Context, forumtopicIdforumtopic int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, existsTopicRestrictions, forumtopicIdforumtopic)
	var forumtopic_idforumtopic int32
	err := row.Scan(&forumtopic_idforumtopic)
	return forumtopic_idforumtopic, err
}

const faq_categories = `-- name: faq_categories :many
SELECT idfaqCategories, name
FROM faqCategories
`

func (q *Queries) faq_categories(ctx context.Context) ([]*Faqcategory, error) {
	rows, err := q.db.QueryContext(ctx, faq_categories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faqcategory
	for rows.Next() {
		var i Faqcategory
		if err := rows.Scan(&i.Idfaqcategories, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchCategories = `-- name: fetchCategories :many
SELECT idwritingCategory, title, description
FROM writingCategory
WHERE writingCategory_idwritingCategory = ?
`

type fetchCategoriesRow struct {
	Idwritingcategory int32
	Title             sql.NullString
	Description       sql.NullString
}

func (q *Queries) fetchCategories(ctx context.Context, writingcategoryIdwritingcategory int32) ([]*fetchCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchCategories, writingcategoryIdwritingcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchCategoriesRow
	for rows.Next() {
		var i fetchCategoriesRow
		if err := rows.Scan(&i.Idwritingcategory, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChildCategories = `-- name: fetchChildCategories :many
SELECT c3.idwritingCategory, c3.title, c2.idwritingCategory, c2.title
FROM writingCategory c1
LEFT JOIN writingCategory c2 ON c2.idwritingCategory = c1.writingCategory_idwritingCategory
LEFT JOIN writingCategory c3 ON c3.idwritingCategory = c2.writingCategory_idwritingCategory
WHERE c1.idwritingCategory = ?
`

type fetchChildCategoriesRow struct {
	Idwritingcategory   sql.NullInt32
	Title               sql.NullString
	Idwritingcategory_2 sql.NullInt32
	Title_2             sql.NullString
}

func (q *Queries) fetchChildCategories(ctx context.Context, idwritingcategory int32) ([]*fetchChildCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchChildCategories, idwritingcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchChildCategoriesRow
	for rows.Next() {
		var i fetchChildCategoriesRow
		if err := rows.Scan(
			&i.Idwritingcategory,
			&i.Title,
			&i.Idwritingcategory_2,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLanguages = `-- name: fetchLanguages :many
SELECT idlanguage, nameof FROM language
`

func (q *Queries) fetchLanguages(ctx context.Context) ([]*Language, error) {
	rows, err := q.db.QueryContext(ctx, fetchLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(&i.Idlanguage, &i.Nameof); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPagePermissions = `-- name: fetchPagePermissions :many
SELECT p.idpermissions, p.level, u.username, u.email, p.section
FROM permissions p
JOIN users u ON u.idusers = p.users_idusers
WHERE p.section = ?
ORDER BY p.level
`

type fetchPagePermissionsRow struct {
	Idpermissions int32
	Level         sql.NullString
	Username      sql.NullString
	Email         sql.NullString
	Section       sql.NullString
}

func (q *Queries) fetchPagePermissions(ctx context.Context, section sql.NullString) ([]*fetchPagePermissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPagePermissions, section)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchPagePermissionsRow
	for rows.Next() {
		var i fetchPagePermissionsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.Level,
			&i.Username,
			&i.Email,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPublicWritings = `-- name: fetchPublicWritings :many
SELECT w.title, w.abstract, w.idwriting, w.private, w.writingCategory_idwritingCategory
FROM writing w
WHERE w.private = 0
ORDER BY w.published DESC LIMIT 15
`

type fetchPublicWritingsRow struct {
	Title                            sql.NullString
	Abstract                         sql.NullString
	Idwriting                        int32
	Private                          sql.NullBool
	WritingcategoryIdwritingcategory int32
}

func (q *Queries) fetchPublicWritings(ctx context.Context) ([]*fetchPublicWritingsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPublicWritings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchPublicWritingsRow
	for rows.Next() {
		var i fetchPublicWritingsRow
		if err := rows.Scan(
			&i.Title,
			&i.Abstract,
			&i.Idwriting,
			&i.Private,
			&i.WritingcategoryIdwritingcategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPublicWritingsByCategory = `-- name: fetchPublicWritingsByCategory :many
SELECT w.title, w.abstract, u.username, w.published, w.idwriting, w.private, IF(th.comments IS NULL, 0, th.comments + 1)
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN forumthread th ON w.forumthread_idforumthread = th.idforumthread
LEFT JOIN writtingApprovedUsers wau ON w.idwriting = wau.writing_idwriting AND wau.users_idusers = ?
WHERE w.writingCategory_idwritingCategory = ? AND (w.private = 0 OR wau.readdoc = 1 OR w.users_idusers = ?)
ORDER BY w.published DESC
`

type fetchPublicWritingsByCategoryParams struct {
	UsersIdusers                     int32
	WritingcategoryIdwritingcategory int32
	UsersIdusers_2                   int32
}

type fetchPublicWritingsByCategoryRow struct {
	Title     sql.NullString
	Abstract  sql.NullString
	Username  sql.NullString
	Published sql.NullTime
	Idwriting int32
	Private   sql.NullBool
	If        interface{}
}

func (q *Queries) fetchPublicWritingsByCategory(ctx context.Context, arg fetchPublicWritingsByCategoryParams) ([]*fetchPublicWritingsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPublicWritingsByCategory, arg.UsersIdusers, arg.WritingcategoryIdwritingcategory, arg.UsersIdusers_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchPublicWritingsByCategoryRow
	for rows.Next() {
		var i fetchPublicWritingsByCategoryRow
		if err := rows.Scan(
			&i.Title,
			&i.Abstract,
			&i.Username,
			&i.Published,
			&i.Idwriting,
			&i.Private,
			&i.If,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserEmailForumUpdates = `-- name: fetchUserEmailForumUpdates :many

SELECT emailforumupdates FROM preferences WHERE users_idusers = ?
`

// -- name: updateOrInsertEmailForumUpdates :exec
// WITH email_updates AS (
//
//	SELECT emailforumupdates FROM preferences WHERE users_idusers = ?
//
// )
// INSERT INTO preferences (emailforumupdates, users_idusers)
// VALUES (?, ?)
// ON DUPLICATE KEY UPDATE
//
//	emailforumupdates = VALUES(emailforumupdates);
func (q *Queries) fetchUserEmailForumUpdates(ctx context.Context, usersIdusers int32) ([]sql.NullBool, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserEmailForumUpdates, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullBool
	for rows.Next() {
		var emailforumupdates sql.NullBool
		if err := rows.Scan(&emailforumupdates); err != nil {
			return nil, err
		}
		items = append(items, emailforumupdates)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserLanguagePreferences = `-- name: fetchUserLanguagePreferences :many

SELECT idlanguage, nameof, (
  SELECT COUNT(sul.iduserlang) FROM userlang sul
  WHERE sul.language_idlanguage = l.idlanguage AND sul.users_idusers = ?
) AS user_lang_pref
FROM language l
`

type fetchUserLanguagePreferencesRow struct {
	Idlanguage   int32
	Nameof       sql.NullString
	UserLangPref int64
}

// -- name: updateOrInsertUserLanguage :exec
// WITH pref_count AS (
//
//	SELECT COUNT(users_idusers) AS prefcount FROM preferences WHERE users_idusers = ?
//
// )
// INSERT INTO preferences (language_idlanguage, users_idusers)
// VALUES (?, ?)
// ON DUPLICATE KEY UPDATE
//
//	language_idlanguage = VALUES(language_idlanguage);
func (q *Queries) fetchUserLanguagePreferences(ctx context.Context, usersIdusers int32) ([]*fetchUserLanguagePreferencesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserLanguagePreferences, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchUserLanguagePreferencesRow
	for rows.Next() {
		var i fetchUserLanguagePreferencesRow
		if err := rows.Scan(&i.Idlanguage, &i.Nameof, &i.UserLangPref); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingApproval = `-- name: fetchWritingApproval :many
SELECT editdoc
FROM writtingApprovedUsers
WHERE writing_idwriting = ? AND users_idusers = ?
`

type fetchWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) fetchWritingApproval(ctx context.Context, arg fetchWritingApprovalParams) ([]sql.NullBool, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingApproval, arg.WritingIdwriting, arg.UsersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullBool
	for rows.Next() {
		var editdoc sql.NullBool
		if err := rows.Scan(&editdoc); err != nil {
			return nil, err
		}
		items = append(items, editdoc)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingApprovals = `-- name: fetchWritingApprovals :many
SELECT idusers, u.username, wau.readdoc, wau.editdoc
FROM writtingApprovedUsers wau
LEFT JOIN users u ON idusers = wau.users_idusers
WHERE writing_idwriting = ?
`

type fetchWritingApprovalsRow struct {
	Idusers  int32
	Username sql.NullString
	Readdoc  sql.NullBool
	Editdoc  sql.NullBool
}

func (q *Queries) fetchWritingApprovals(ctx context.Context, writingIdwriting int32) ([]*fetchWritingApprovalsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingApprovals, writingIdwriting)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchWritingApprovalsRow
	for rows.Next() {
		var i fetchWritingApprovalsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Username,
			&i.Readdoc,
			&i.Editdoc,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingById = `-- name: fetchWritingById :many
SELECT w.title, w.abstract, w.writting, u.username, w.published, w.idwriting, w.private, wau.editdoc, w.forumthread_idforumthread,
u.idusers, w.writingCategory_idwritingCategory
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN writtingApprovedUsers wau ON w.idwriting = wau.writing_idwriting AND wau.users_idusers = ?
WHERE w.idwriting = ? AND (w.private = 0 OR wau.readdoc = 1 OR w.users_idusers = ?)
ORDER BY w.published DESC
`

type fetchWritingByIdParams struct {
	UsersIdusers   int32
	Idwriting      int32
	UsersIdusers_2 int32
}

type fetchWritingByIdRow struct {
	Title                            sql.NullString
	Abstract                         sql.NullString
	Writting                         sql.NullString
	Username                         sql.NullString
	Published                        sql.NullTime
	Idwriting                        int32
	Private                          sql.NullBool
	Editdoc                          sql.NullBool
	ForumthreadIdforumthread         int32
	Idusers                          int32
	WritingcategoryIdwritingcategory int32
}

func (q *Queries) fetchWritingById(ctx context.Context, arg fetchWritingByIdParams) ([]*fetchWritingByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingById, arg.UsersIdusers, arg.Idwriting, arg.UsersIdusers_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchWritingByIdRow
	for rows.Next() {
		var i fetchWritingByIdRow
		if err := rows.Scan(
			&i.Title,
			&i.Abstract,
			&i.Writting,
			&i.Username,
			&i.Published,
			&i.Idwriting,
			&i.Private,
			&i.Editdoc,
			&i.ForumthreadIdforumthread,
			&i.Idusers,
			&i.WritingcategoryIdwritingcategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingByIdWithEdit = `-- name: fetchWritingByIdWithEdit :many
SELECT w.title, w.abstract, w.writting, u.username, w.published, w.idwriting, w.private, wau.editdoc, w.forumthread_idforumthread,
u.idusers, w.writingCategory_idwritingCategory
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN writtingApprovedUsers wau ON w.idwriting = wau.writing_idwriting AND wau.users_idusers = ?
WHERE w.idwriting = ? AND w.users_idusers = ? AND (w.private = 0 OR wau.readdoc = 1 OR w.users_idusers = ?)
AND (wau.editdoc = 1 OR w.users_idusers = ?)
ORDER BY w.published DESC
`

type fetchWritingByIdWithEditParams struct {
	UsersIdusers   int32
	Idwriting      int32
	UsersIdusers_2 int32
	UsersIdusers_3 int32
	UsersIdusers_4 int32
}

type fetchWritingByIdWithEditRow struct {
	Title                            sql.NullString
	Abstract                         sql.NullString
	Writting                         sql.NullString
	Username                         sql.NullString
	Published                        sql.NullTime
	Idwriting                        int32
	Private                          sql.NullBool
	Editdoc                          sql.NullBool
	ForumthreadIdforumthread         int32
	Idusers                          int32
	WritingcategoryIdwritingcategory int32
}

func (q *Queries) fetchWritingByIdWithEdit(ctx context.Context, arg fetchWritingByIdWithEditParams) ([]*fetchWritingByIdWithEditRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingByIdWithEdit,
		arg.UsersIdusers,
		arg.Idwriting,
		arg.UsersIdusers_2,
		arg.UsersIdusers_3,
		arg.UsersIdusers_4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchWritingByIdWithEditRow
	for rows.Next() {
		var i fetchWritingByIdWithEditRow
		if err := rows.Scan(
			&i.Title,
			&i.Abstract,
			&i.Writting,
			&i.Username,
			&i.Published,
			&i.Idwriting,
			&i.Private,
			&i.Editdoc,
			&i.ForumthreadIdforumthread,
			&i.Idusers,
			&i.WritingcategoryIdwritingcategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingOwner = `-- name: fetchWritingOwner :many
SELECT users_idusers
FROM writing
WHERE idwriting = ?
`

func (q *Queries) fetchWritingOwner(ctx context.Context, idwriting int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingOwner, idwriting)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var users_idusers int32
		if err := rows.Scan(&users_idusers); err != nil {
			return nil, err
		}
		items = append(items, users_idusers)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findForumTopicByName = `-- name: findForumTopicByName :one
SELECT idforumtopic FROM forumtopic WHERE title=?
`

func (q *Queries) findForumTopicByName(ctx context.Context, title sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, findForumTopicByName, title)
	var idforumtopic int32
	err := row.Scan(&idforumtopic)
	return idforumtopic, err
}

const forumCategories = `-- name: forumCategories :many
SELECT f.idforumcategory, f.forumcategory_idforumcategory, f.title, f.description
FROM forumcategory f
`

func (q *Queries) forumCategories(ctx context.Context) ([]*Forumcategory, error) {
	rows, err := q.db.QueryContext(ctx, forumCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumcategory
	for rows.Next() {
		var i Forumcategory
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTopicRestrictions = `-- name: getAllTopicRestrictions :many
SELECT idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, t.title, r.forumtopic_idforumtopic, r.modlevel, r.adminlevel
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
`

type getAllTopicRestrictionsRow struct {
	Idforumtopic           int32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Title                  sql.NullString
	ForumtopicIdforumtopic sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) getAllTopicRestrictions(ctx context.Context) ([]*getAllTopicRestrictionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllTopicRestrictions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*getAllTopicRestrictionsRow
	for rows.Next() {
		var i getAllTopicRestrictionsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Title,
			&i.ForumtopicIdforumtopic,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTopics = `-- name: getAllTopics :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition
FROM forumtopic t
LEFT JOIN forumcategory c ON t.forumcategory_idforumcategory = c.idforumcategory
GROUP BY t.idforumtopic
`

func (q *Queries) getAllTopics(ctx context.Context) ([]*Forumtopic, error) {
	rows, err := q.db.QueryContext(ctx, getAllTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumtopic
	for rows.Next() {
		var i Forumtopic
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersAllTopicLevels = `-- name: getAllUsersAllTopicLevels :many
SELECT u.idusers, u.email, u.passwd, u.username, t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, utl.users_idusers, utl.forumtopic_idforumtopic, utl.level, utl.invitemax, tr.forumtopic_idforumtopic, tr.viewlevel, tr.replylevel, tr.newthreadlevel, tr.seelevel, tr.invitelevel, tr.readlevel, tr.modlevel, tr.adminlevel
FROM users u
JOIN userstopiclevel utl ON utl.users_idusers=u.idusers
JOIN forumtopic t ON utl.forumtopic_idforumtopic = t.idforumtopic
LEFT JOIN topicrestrictions tr ON t.idforumtopic = tr.forumtopic_idforumtopic
`

type getAllUsersAllTopicLevelsRow struct {
	Idusers                      int32
	Email                        sql.NullString
	Passwd                       sql.NullString
	Username                     sql.NullString
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	UsersIdusers                 int32
	ForumtopicIdforumtopic       int32
	Level                        sql.NullInt32
	Invitemax                    sql.NullInt32
	ForumtopicIdforumtopic_2     sql.NullInt32
	Viewlevel                    sql.NullInt32
	Replylevel                   sql.NullInt32
	Newthreadlevel               sql.NullInt32
	Seelevel                     sql.NullInt32
	Invitelevel                  sql.NullInt32
	Readlevel                    sql.NullInt32
	Modlevel                     sql.NullInt32
	Adminlevel                   sql.NullInt32
}

func (q *Queries) getAllUsersAllTopicLevels(ctx context.Context) ([]*getAllUsersAllTopicLevelsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersAllTopicLevels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*getAllUsersAllTopicLevelsRow
	for rows.Next() {
		var i getAllUsersAllTopicLevelsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.UsersIdusers,
			&i.ForumtopicIdforumtopic,
			&i.Level,
			&i.Invitemax,
			&i.ForumtopicIdforumtopic_2,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersTopicLevelInviteMax = `-- name: getAllUsersTopicLevelInviteMax :one
SELECT invitemax FROM userstopiclevel WHERE forumtopic_idforumtopic = ? AND users_idusers = ?
`

type getAllUsersTopicLevelInviteMaxParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
}

func (q *Queries) getAllUsersTopicLevelInviteMax(ctx context.Context, arg getAllUsersTopicLevelInviteMaxParams) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getAllUsersTopicLevelInviteMax, arg.ForumtopicIdforumtopic, arg.UsersIdusers)
	var invitemax sql.NullInt32
	err := row.Scan(&invitemax)
	return invitemax, err
}

const getComment = `-- name: getComment :one
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text
FROM comments c
WHERE c.Idcomments=?
`

func (q *Queries) getComment(ctx context.Context, idcomments int32) (*Comment, error) {
	row := q.db.QueryRowContext(ctx, getComment, idcomments)
	var i Comment
	err := row.Scan(
		&i.Idcomments,
		&i.ForumthreadIdforumthread,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Written,
		&i.Text,
	)
	return &i, err
}

const getLangs = `-- name: getLangs :one
SELECT language_idlanguage FROM userlang WHERE users_idusers = ?
`

func (q *Queries) getLangs(ctx context.Context, usersIdusers int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getLangs, usersIdusers)
	var language_idlanguage int32
	err := row.Scan(&language_idlanguage)
	return language_idlanguage, err
}

const getNewsThreadId = `-- name: getNewsThreadId :one
SELECT s.forumthread_idforumthread FROM siteNews s, users u
WHERE s.users_idusers = u.idusers AND s.idsiteNews = ?
`

func (q *Queries) getNewsThreadId(ctx context.Context, idsitenews int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNewsThreadId, idsitenews)
	var forumthread_idforumthread int32
	err := row.Scan(&forumthread_idforumthread)
	return forumthread_idforumthread, err
}

const getSecurityLevel = `-- name: getSecurityLevel :one
SELECT level FROM permissions WHERE users_idusers = ? AND (section = ? OR section = 'all')
`

type getSecurityLevelParams struct {
	UsersIdusers int32
	Section      sql.NullString
}

func (q *Queries) getSecurityLevel(ctx context.Context, arg getSecurityLevelParams) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getSecurityLevel, arg.UsersIdusers, arg.Section)
	var level sql.NullString
	err := row.Scan(&level)
	return level, err
}

const getTopicRestrictions = `-- name: getTopicRestrictions :many
SELECT idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, t.title, r.forumtopic_idforumtopic, r.modlevel, r.adminlevel
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
WHERE idforumtopic = ?
`

type getTopicRestrictionsRow struct {
	Idforumtopic           int32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Title                  sql.NullString
	ForumtopicIdforumtopic sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) getTopicRestrictions(ctx context.Context, idforumtopic int32) ([]*getTopicRestrictionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopicRestrictions, idforumtopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*getTopicRestrictionsRow
	for rows.Next() {
		var i getTopicRestrictionsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Title,
			&i.ForumtopicIdforumtopic,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPermissions = `-- name: getUserPermissions :one
SELECT p.idpermissions, p.users_idusers, p.section, p.level
FROM permissions p
WHERE p.users_idusers = ?
`

// This query selects permissions information for admin users.
// Result:
//
//	idpermissions (int)
//	level (int)
//	username (string)
//	email (string)
//	section (string)
func (q *Queries) getUserPermissions(ctx context.Context, usersIdusers int32) (*Permission, error) {
	row := q.db.QueryRowContext(ctx, getUserPermissions, usersIdusers)
	var i Permission
	err := row.Scan(
		&i.Idpermissions,
		&i.UsersIdusers,
		&i.Section,
		&i.Level,
	)
	return &i, err
}

const getUsersAllTopicLevels = `-- name: getUsersAllTopicLevels :many
SELECT u.idusers, u.email, u.passwd, u.username, t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, utl.users_idusers, utl.forumtopic_idforumtopic, utl.level, utl.invitemax, tr.forumtopic_idforumtopic, tr.viewlevel, tr.replylevel, tr.newthreadlevel, tr.seelevel, tr.invitelevel, tr.readlevel, tr.modlevel, tr.adminlevel
FROM users u
JOIN userstopiclevel utl ON utl.users_idusers=u.idusers
JOIN forumtopic t ON utl.forumtopic_idforumtopic = t.idforumtopic
JOIN topicrestrictions tr ON t.idforumtopic = tr.forumtopic_idforumtopic
WHERE u.idusers = ?
`

type getUsersAllTopicLevelsRow struct {
	Idusers                      int32
	Email                        sql.NullString
	Passwd                       sql.NullString
	Username                     sql.NullString
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	UsersIdusers                 int32
	ForumtopicIdforumtopic       int32
	Level                        sql.NullInt32
	Invitemax                    sql.NullInt32
	ForumtopicIdforumtopic_2     int32
	Viewlevel                    sql.NullInt32
	Replylevel                   sql.NullInt32
	Newthreadlevel               sql.NullInt32
	Seelevel                     sql.NullInt32
	Invitelevel                  sql.NullInt32
	Readlevel                    sql.NullInt32
	Modlevel                     sql.NullInt32
	Adminlevel                   sql.NullInt32
}

func (q *Queries) getUsersAllTopicLevels(ctx context.Context, idusers int32) ([]*getUsersAllTopicLevelsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersAllTopicLevels, idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*getUsersAllTopicLevelsRow
	for rows.Next() {
		var i getUsersAllTopicLevelsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.UsersIdusers,
			&i.ForumtopicIdforumtopic,
			&i.Level,
			&i.Invitemax,
			&i.ForumtopicIdforumtopic_2,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersPermissions = `-- name: getUsersPermissions :many
SELECT p.idpermissions, p.users_idusers, p.section, p.level
FROM permissions p
`

// This query selects permissions information for admin users.
// Result:
//
//	idpermissions (int)
//	level (int)
//	username (string)
//	email (string)
//	section (string)
func (q *Queries) getUsersPermissions(ctx context.Context) ([]*Permission, error) {
	rows, err := q.db.QueryContext(ctx, getUsersPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.Idpermissions,
			&i.UsersIdusers,
			&i.Section,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersTopicLevel = `-- name: getUsersTopicLevel :one
SELECT utl.users_idusers, utl.forumtopic_idforumtopic, utl.level, utl.invitemax
FROM userstopiclevel utl
WHERE utl.users_idusers = ? AND utl.forumtopic_idforumtopic = ?
`

type getUsersTopicLevelParams struct {
	UsersIdusers           int32
	ForumtopicIdforumtopic int32
}

// This query selects permissions information for admin users.
// Result:
//
//	idpermissions (int)
//	level (int)
//	username (string)
//	email (string)
//	section (string)
func (q *Queries) getUsersTopicLevel(ctx context.Context, arg getUsersTopicLevelParams) (*Userstopiclevel, error) {
	row := q.db.QueryRowContext(ctx, getUsersTopicLevel, arg.UsersIdusers, arg.ForumtopicIdforumtopic)
	var i Userstopiclevel
	err := row.Scan(
		&i.UsersIdusers,
		&i.ForumtopicIdforumtopic,
		&i.Level,
		&i.Invitemax,
	)
	return &i, err
}

const getWordID = `-- name: getWordID :one
SELECT idsearchwordlist FROM searchwordlist WHERE word = lcase(?)
`

func (q *Queries) getWordID(ctx context.Context, lcase string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getWordID, lcase)
	var idsearchwordlist int32
	err := row.Scan(&idsearchwordlist)
	return idsearchwordlist, err
}

const get_all_user_topics = `-- name: get_all_user_topics :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY t.lastaddition DESC
`

type get_all_user_topicsRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
	Seelevel                     sql.NullInt32
	Level                        sql.NullInt32
}

func (q *Queries) get_all_user_topics(ctx context.Context, usersIdusers int32) ([]*get_all_user_topicsRow, error) {
	rows, err := q.db.QueryContext(ctx, get_all_user_topics, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*get_all_user_topicsRow
	for rows.Next() {
		var i get_all_user_topicsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Lastposterusername,
			&i.Seelevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get_all_user_topics_for_category = `-- name: get_all_user_topics_for_category :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE t.forumcategory_idforumcategory = ? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY t.lastaddition DESC
`

type get_all_user_topics_for_categoryParams struct {
	UsersIdusers                 int32
	ForumcategoryIdforumcategory int32
}

type get_all_user_topics_for_categoryRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
	Seelevel                     sql.NullInt32
	Level                        sql.NullInt32
}

func (q *Queries) get_all_user_topics_for_category(ctx context.Context, arg get_all_user_topics_for_categoryParams) ([]*get_all_user_topics_for_categoryRow, error) {
	rows, err := q.db.QueryContext(ctx, get_all_user_topics_for_category, arg.UsersIdusers, arg.ForumcategoryIdforumcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*get_all_user_topics_for_categoryRow
	for rows.Next() {
		var i get_all_user_topics_for_categoryRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Lastposterusername,
			&i.Seelevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPagePermission = `-- name: insertPagePermission :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES (?, ?, ?)
`

type insertPagePermissionParams struct {
	UsersIdusers int32
	Section      sql.NullString
	Level        sql.NullString
}

func (q *Queries) insertPagePermission(ctx context.Context, arg insertPagePermissionParams) error {
	_, err := q.db.ExecContext(ctx, insertPagePermission, arg.UsersIdusers, arg.Section, arg.Level)
	return err
}

const insertWriting = `-- name: insertWriting :exec
INSERT INTO writing (writingCategory_idwritingCategory, title, abstract, writting, private, language_idlanguage, published, users_idusers)
VALUES (?, ?, ?, ?, ?, ?, NOW(), ?)
`

type insertWritingParams struct {
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Abstract                         sql.NullString
	Writting                         sql.NullString
	Private                          sql.NullBool
	LanguageIdlanguage               int32
	UsersIdusers                     int32
}

func (q *Queries) insertWriting(ctx context.Context, arg insertWritingParams) error {
	_, err := q.db.ExecContext(ctx, insertWriting,
		arg.WritingcategoryIdwritingcategory,
		arg.Title,
		arg.Abstract,
		arg.Writting,
		arg.Private,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
	)
	return err
}

const insertWritingApproval = `-- name: insertWritingApproval :exec
INSERT INTO writtingApprovedUsers (writing_idwriting, users_idusers, readdoc, editdoc)
VALUES (?, ?, ?, ?)
`

type insertWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
	Readdoc          sql.NullBool
	Editdoc          sql.NullBool
}

func (q *Queries) insertWritingApproval(ctx context.Context, arg insertWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, insertWritingApproval,
		arg.WritingIdwriting,
		arg.UsersIdusers,
		arg.Readdoc,
		arg.Editdoc,
	)
	return err
}

const insertWritingCategory = `-- name: insertWritingCategory :exec
INSERT INTO writingCategory (writingCategory_idwritingCategory, title, description)
VALUES (?, ?, ?)
`

type insertWritingCategoryParams struct {
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Description                      sql.NullString
}

func (q *Queries) insertWritingCategory(ctx context.Context, arg insertWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, insertWritingCategory, arg.WritingcategoryIdwritingcategory, arg.Title, arg.Description)
	return err
}

const lang_combobox = `-- name: lang_combobox :many
SELECT l.idlanguage, l.nameof FROM language l
`

func (q *Queries) lang_combobox(ctx context.Context) ([]*Language, error) {
	rows, err := q.db.QueryContext(ctx, lang_combobox)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(&i.Idlanguage, &i.Nameof); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeCategory = `-- name: makeCategory :exec
INSERT INTO forumcategory (forumcategory_idforumcategory, title, description) VALUES (?, ?, ?)
`

type makeCategoryParams struct {
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) makeCategory(ctx context.Context, arg makeCategoryParams) error {
	_, err := q.db.ExecContext(ctx, makeCategory, arg.ForumcategoryIdforumcategory, arg.Title, arg.Description)
	return err
}

const makeImageBoard = `-- name: makeImageBoard :exec
INSERT INTO imageboard (imageboard_idimageboard, title, description) VALUES (?, ?, ?)
`

type makeImageBoardParams struct {
	ImageboardIdimageboard int32
	Title                  sql.NullString
	Description            sql.NullString
}

func (q *Queries) makeImageBoard(ctx context.Context, arg makeImageBoardParams) error {
	_, err := q.db.ExecContext(ctx, makeImageBoard, arg.ImageboardIdimageboard, arg.Title, arg.Description)
	return err
}

const makePost = `-- name: makePost :execlastid
INSERT INTO comments (language_idlanguage, users_idusers, forumthread_idforumthread, text, written)
VALUES (?, ?, ?, ?, NOW())
`

type makePostParams struct {
	LanguageIdlanguage       int32
	UsersIdusers             int32
	ForumthreadIdforumthread int32
	Text                     sql.NullString
}

func (q *Queries) makePost(ctx context.Context, arg makePostParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, makePost,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
		arg.ForumthreadIdforumthread,
		arg.Text,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const makeThread = `-- name: makeThread :execlastid
INSERT INTO forumthread (forumtopic_idforumtopic) VALUES (?)
`

func (q *Queries) makeThread(ctx context.Context, forumtopicIdforumtopic int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, makeThread, forumtopicIdforumtopic)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const makeTopic = `-- name: makeTopic :execlastid
INSERT INTO forumtopic (forumcategory_idforumcategory, title, description) VALUES (?, ?, ?)
`

type makeTopicParams struct {
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) makeTopic(ctx context.Context, arg makeTopicParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, makeTopic, arg.ForumcategoryIdforumcategory, arg.Title, arg.Description)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const modify_faq = `-- name: modify_faq :exec
UPDATE faq
SET answer = ?, question = ?, faqCategories_idfaqCategories = ?
WHERE idfaq = ?
`

type modify_faqParams struct {
	Answer                       sql.NullString
	Question                     sql.NullString
	FaqcategoriesIdfaqcategories int32
	Idfaq                        int32
}

func (q *Queries) modify_faq(ctx context.Context, arg modify_faqParams) error {
	_, err := q.db.ExecContext(ctx, modify_faq,
		arg.Answer,
		arg.Question,
		arg.FaqcategoriesIdfaqcategories,
		arg.Idfaq,
	)
	return err
}

const moveToLinker = `-- name: moveToLinker :many
SELECT l.users_idusers, l.linkerCategory_idlinkerCategory, l.language_idlanguage, l.title, l.url, l.description
FROM linkerQueue l WHERE l.idlinkerQueue = ?
`

type moveToLinkerRow struct {
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	LanguageIdlanguage             int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
}

func (q *Queries) moveToLinker(ctx context.Context, idlinkerqueue int32) ([]*moveToLinkerRow, error) {
	rows, err := q.db.QueryContext(ctx, moveToLinker, idlinkerqueue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*moveToLinkerRow
	for rows.Next() {
		var i moveToLinkerRow
		if err := rows.Scan(
			&i.UsersIdusers,
			&i.LinkercategoryIdlinkercategory,
			&i.LanguageIdlanguage,
			&i.Title,
			&i.Url,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const preferencesRefreshPref = `-- name: preferencesRefreshPref :many
SELECT language_idlanguage FROM preferences WHERE users_idusers = ?
`

func (q *Queries) preferencesRefreshPref(ctx context.Context, usersIdusers int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, preferencesRefreshPref, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var language_idlanguage int32
		if err := rows.Scan(&language_idlanguage); err != nil {
			return nil, err
		}
		items = append(items, language_idlanguage)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printBoardPosts = `-- name: printBoardPosts :many
SELECT i.description, i.thumbnail, i.fullimage, u.username, i.posted, i.idimagepost, IF(th.comments IS NULL, 0, th.comments + 1)
FROM imagepost i
LEFT JOIN users u ON i.users_idusers = u.idusers
LEFT JOIN forumthread th ON i.forumthread_idforumthread = th.idforumthread
WHERE i.imageboard_idimageboard = ?
ORDER BY i.posted DESC
`

type printBoardPostsRow struct {
	Description sql.NullString
	Thumbnail   sql.NullString
	Fullimage   sql.NullString
	Username    sql.NullString
	Posted      sql.NullTime
	Idimagepost int32
	If          interface{}
}

func (q *Queries) printBoardPosts(ctx context.Context, imageboardIdimageboard int32) ([]*printBoardPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, printBoardPosts, imageboardIdimageboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printBoardPostsRow
	for rows.Next() {
		var i printBoardPostsRow
		if err := rows.Scan(
			&i.Description,
			&i.Thumbnail,
			&i.Fullimage,
			&i.Username,
			&i.Posted,
			&i.Idimagepost,
			&i.If,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printImagePost = `-- name: printImagePost :many
SELECT i.description, i.thumbnail, i.fullimage, u.username, i.posted, i.forumthread_idforumthread, i.idimagepost
FROM imagepost i
LEFT JOIN users u ON i.users_idusers = u.idusers
WHERE i.idimagepost = ?
`

type printImagePostRow struct {
	Description              sql.NullString
	Thumbnail                sql.NullString
	Fullimage                sql.NullString
	Username                 sql.NullString
	Posted                   sql.NullTime
	ForumthreadIdforumthread int32
	Idimagepost              int32
}

func (q *Queries) printImagePost(ctx context.Context, idimagepost int32) ([]*printImagePostRow, error) {
	rows, err := q.db.QueryContext(ctx, printImagePost, idimagepost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printImagePostRow
	for rows.Next() {
		var i printImagePostRow
		if err := rows.Scan(
			&i.Description,
			&i.Thumbnail,
			&i.Fullimage,
			&i.Username,
			&i.Posted,
			&i.ForumthreadIdforumthread,
			&i.Idimagepost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printSubBoards = `-- name: printSubBoards :many
SELECT idimageboard, title, description FROM imageboard WHERE imageboard_idimageboard = ?
`

type printSubBoardsRow struct {
	Idimageboard int32
	Title        sql.NullString
	Description  sql.NullString
}

func (q *Queries) printSubBoards(ctx context.Context, imageboardIdimageboard int32) ([]*printSubBoardsRow, error) {
	rows, err := q.db.QueryContext(ctx, printSubBoards, imageboardIdimageboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printSubBoardsRow
	for rows.Next() {
		var i printSubBoardsRow
		if err := rows.Scan(&i.Idimageboard, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reassign_category = `-- name: reassign_category :exec
UPDATE faq
SET faqCategories_idfaqCategories = ?
WHERE idfaq = ?
`

type reassign_categoryParams struct {
	FaqcategoriesIdfaqcategories int32
	Idfaq                        int32
}

func (q *Queries) reassign_category(ctx context.Context, arg reassign_categoryParams) error {
	_, err := q.db.ExecContext(ctx, reassign_category, arg.FaqcategoriesIdfaqcategories, arg.Idfaq)
	return err
}

const remakeBlogSearch = `-- name: remakeBlogSearch :exec
INSERT INTO blogsSearch (text, blogs_idblogs)
SELECT blog, idblogs
FROM blogs
`

// This query selects data from the "blogs" table and populates the "blogsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "blogsSearch" using the "blogs_idblogs".
func (q *Queries) remakeBlogSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeBlogSearch)
	return err
}

const remakeBlogsSearchInsert = `-- name: remakeBlogsSearchInsert :exec
INSERT INTO blogsSearch (text, blogs_idblogs)
SELECT blog, idblogs
FROM blogs
`

// This query selects data from the "blogs" table and populates the "blogsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "blogsSearch" using the "blogs_idblogs".
func (q *Queries) remakeBlogsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeBlogsSearchInsert)
	return err
}

const remakeCommentsSearch = `-- name: remakeCommentsSearch :exec
INSERT INTO commentsSearch (text, comments_idcomments)
SELECT text, idcomments
FROM comments
`

// This query selects data from the "comments" table and populates the "commentsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "commentsSearch" using the "comments_idcomments".
func (q *Queries) remakeCommentsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeCommentsSearch)
	return err
}

const remakeCommentsSearchInsert = `-- name: remakeCommentsSearchInsert :exec
INSERT INTO commentsSearch (text, comments_idcomments)
SELECT text, idcomments
FROM comments
`

// This query selects data from the "comments" table and populates the "commentsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "commentsSearch" using the "comments_idcomments".
func (q *Queries) remakeCommentsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeCommentsSearchInsert)
	return err
}

const remakeLinkerSearch = `-- name: remakeLinkerSearch :exec
INSERT INTO linkerSearch (text, linker_idlinker)
SELECT CONCAT(title, ' ', description), idlinker
FROM linker
`

// This query selects data from the "linker" table and populates the "linkerSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "linkerSearch" using the "linker_idlinker".
func (q *Queries) remakeLinkerSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeLinkerSearch)
	return err
}

const remakeLinkerSearchInsert = `-- name: remakeLinkerSearchInsert :exec
INSERT INTO linkerSearch (text, linker_idlinker)
SELECT CONCAT(title, ' ', description), idlinker
FROM linker
`

// This query selects data from the "linker" table and populates the "linkerSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "linkerSearch" using the "linker_idlinker".
func (q *Queries) remakeLinkerSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeLinkerSearchInsert)
	return err
}

const remakeNewsSearch = `-- name: remakeNewsSearch :exec
INSERT INTO siteNewsSearch (text, siteNews_idsiteNews)
SELECT news, idsiteNews
FROM siteNews
`

// This query selects data from the "siteNews" table and populates the "siteNewsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "siteNewsSearch" using the "siteNews_idsiteNews".
func (q *Queries) remakeNewsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeNewsSearch)
	return err
}

const remakeNewsSearchInsert = `-- name: remakeNewsSearchInsert :exec
INSERT INTO siteNewsSearch (text, siteNews_idsiteNews)
SELECT news, idsiteNews
FROM siteNews
`

// This query selects data from the "siteNews" table and populates the "siteNewsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "siteNewsSearch" using the "siteNews_idsiteNews".
func (q *Queries) remakeNewsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeNewsSearchInsert)
	return err
}

const remakeWritingSearch = `-- name: remakeWritingSearch :exec
INSERT INTO writingSearch (text, writing_idwriting)
SELECT CONCAT(title, ' ', abstract, ' ', writting), idwriting
FROM writing
`

// This query selects data from the "writing" table and populates the "writingSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "writingSearch" using the "writing_idwriting".
func (q *Queries) remakeWritingSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeWritingSearch)
	return err
}

const remakeWritingSearchInsert = `-- name: remakeWritingSearchInsert :exec
INSERT INTO writingSearch (text, writing_idwriting)
SELECT CONCAT(title, ' ', abstract, ' ', writting), idwriting
FROM writing
`

// This query selects data from the "writing" table and populates the "writingSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "writingSearch" using the "writing_idwriting".
func (q *Queries) remakeWritingSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeWritingSearchInsert)
	return err
}

const renameCategory = `-- name: renameCategory :exec
UPDATE linkerCategory SET title = ? WHERE idlinkerCategory = ?
`

type renameCategoryParams struct {
	Title            sql.NullString
	Idlinkercategory int32
}

func (q *Queries) renameCategory(ctx context.Context, arg renameCategoryParams) error {
	_, err := q.db.ExecContext(ctx, renameCategory, arg.Title, arg.Idlinkercategory)
	return err
}

const renameLanguage = `-- name: renameLanguage :exec
UPDATE language
SET nameof = ?
WHERE idlanguage = ?
`

type renameLanguageParams struct {
	Nameof     sql.NullString
	Idlanguage int32
}

// This query updates the "nameof" field in the "language" table based on the provided "cid".
// Parameters:
//
//	? - New name for the language (string)
//	? - Language ID to be updated (int)
func (q *Queries) renameLanguage(ctx context.Context, arg renameLanguageParams) error {
	_, err := q.db.ExecContext(ctx, renameLanguage, arg.Nameof, arg.Idlanguage)
	return err
}

const rename_category = `-- name: rename_category :exec
UPDATE faqCategories
SET name = ?
WHERE idfaqCategories = ?
`

type rename_categoryParams struct {
	Name            sql.NullString
	Idfaqcategories int32
}

func (q *Queries) rename_category(ctx context.Context, arg rename_categoryParams) error {
	_, err := q.db.ExecContext(ctx, rename_category, arg.Name, arg.Idfaqcategories)
	return err
}

const setTopicRestrictions = `-- name: setTopicRestrictions :exec
INSERT INTO topicrestrictions (forumtopic_idforumtopic, viewlevel, replylevel, newthreadlevel, seelevel, invitelevel, readlevel, modlevel, adminlevel)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    viewlevel = VALUES(viewlevel),
    replylevel = VALUES(replylevel),
    newthreadlevel = VALUES(newthreadlevel),
    seelevel = VALUES(seelevel),
    invitelevel = VALUES(invitelevel),
    readlevel = VALUES(readlevel),
    modlevel = VALUES(modlevel),
    adminlevel = VALUES(adminlevel)
`

type setTopicRestrictionsParams struct {
	ForumtopicIdforumtopic int32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) setTopicRestrictions(ctx context.Context, arg setTopicRestrictionsParams) error {
	_, err := q.db.ExecContext(ctx, setTopicRestrictions,
		arg.ForumtopicIdforumtopic,
		arg.Viewlevel,
		arg.Replylevel,
		arg.Newthreadlevel,
		arg.Seelevel,
		arg.Invitelevel,
		arg.Readlevel,
		arg.Modlevel,
		arg.Adminlevel,
	)
	return err
}

const setUsersTopicLevel = `-- name: setUsersTopicLevel :exec
INSERT INTO userstopiclevel (forumtopic_idforumtopic, users_idusers, level, invitemax)
VALUES (?, ?, ?, ?)
ON DUPLICATE KEY UPDATE level = VALUES(level), invitemax = VALUES(invitemax)
`

type setUsersTopicLevelParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
	Level                  sql.NullInt32
	Invitemax              sql.NullInt32
}

func (q *Queries) setUsersTopicLevel(ctx context.Context, arg setUsersTopicLevelParams) error {
	_, err := q.db.ExecContext(ctx, setUsersTopicLevel,
		arg.ForumtopicIdforumtopic,
		arg.UsersIdusers,
		arg.Level,
		arg.Invitemax,
	)
	return err
}

const showAdminQueue = `-- name: showAdminQueue :many
SELECT l.title, l.url, l.description, u.username, l.idlinkerQueue, c.title, c.idlinkerCategory
FROM linkerQueue l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory c ON l.linkerCategory_idlinkerCategory = c.idlinkerCategory
`

type showAdminQueueRow struct {
	Title            sql.NullString
	Url              sql.NullString
	Description      sql.NullString
	Username         sql.NullString
	Idlinkerqueue    int32
	Title_2          sql.NullString
	Idlinkercategory int32
}

func (q *Queries) showAdminQueue(ctx context.Context) ([]*showAdminQueueRow, error) {
	rows, err := q.db.QueryContext(ctx, showAdminQueue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showAdminQueueRow
	for rows.Next() {
		var i showAdminQueueRow
		if err := rows.Scan(
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Username,
			&i.Idlinkerqueue,
			&i.Title_2,
			&i.Idlinkercategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showAllBoards = `-- name: showAllBoards :many
SELECT b.idimageboard, b.title, b.description, b.imageboard_idimageboard, pb.title
FROM imageboard b
LEFT JOIN imageboard pb ON b.imageboard_idimageboard = pb.idimageboard OR b.imageboard_idimageboard = 0
GROUP BY b.idimageboard
`

type showAllBoardsRow struct {
	Idimageboard           int32
	Title                  sql.NullString
	Description            sql.NullString
	ImageboardIdimageboard int32
	Title_2                sql.NullString
}

func (q *Queries) showAllBoards(ctx context.Context) ([]*showAllBoardsRow, error) {
	rows, err := q.db.QueryContext(ctx, showAllBoards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showAllBoardsRow
	for rows.Next() {
		var i showAllBoardsRow
		if err := rows.Scan(
			&i.Idimageboard,
			&i.Title,
			&i.Description,
			&i.ImageboardIdimageboard,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showAllCategories = `-- name: showAllCategories :many
SELECT c.idforumcategory, c.forumcategory_idforumcategory, c.title, c.description, COUNT(c2.idforumcategory) as SubcategoryCount
FROM forumcategory c
LEFT JOIN forumcategory c2 ON c.forumcategory_idforumcategory = c2.idforumcategory
GROUP BY c.idforumcategory
`

type showAllCategoriesRow struct {
	Idforumcategory              int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Subcategorycount             int64
}

func (q *Queries) showAllCategories(ctx context.Context) ([]*showAllCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, showAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showAllCategoriesRow
	for rows.Next() {
		var i showAllCategoriesRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Subcategorycount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showCategories = `-- name: showCategories :many
SELECT idlinkerCategory, title FROM linkerCategory
`

func (q *Queries) showCategories(ctx context.Context) ([]*Linkercategory, error) {
	rows, err := q.db.QueryContext(ctx, showCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Linkercategory
	for rows.Next() {
		var i Linkercategory
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showLatest = `-- name: showLatest :many
SELECT l.title, l.url, l.description, u.username, l.idlinker, l.listed,
       IF(th.comments IS NULL, 0, th.comments+1), lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory lc ON l.linkerCategory_idlinkerCategory = lc.idlinkerCategory
WHERE l.linkerCategory_idlinkerCategory = ?
ORDER BY l.listed DESC
`

type showLatestRow struct {
	Title       sql.NullString
	Url         sql.NullString
	Description sql.NullString
	Username    sql.NullString
	Idlinker    int32
	Listed      sql.NullTime
	If          interface{}
	Title_2     sql.NullString
}

func (q *Queries) showLatest(ctx context.Context, linkercategoryIdlinkercategory int32) ([]*showLatestRow, error) {
	rows, err := q.db.QueryContext(ctx, showLatest, linkercategoryIdlinkercategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showLatestRow
	for rows.Next() {
		var i showLatestRow
		if err := rows.Scan(
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Username,
			&i.Idlinker,
			&i.Listed,
			&i.If,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showLinkComments = `-- name: showLinkComments :many
SELECT l.title, l.url, l.description, u.username, l.listed, l.forumthread_idforumthread, lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory lc ON l.linkerCategory_idlinkerCategory = lc.idlinkerCategory
WHERE l.idlinker = ?
`

type showLinkCommentsRow struct {
	Title                    sql.NullString
	Url                      sql.NullString
	Description              sql.NullString
	Username                 sql.NullString
	Listed                   sql.NullTime
	ForumthreadIdforumthread int32
	Title_2                  sql.NullString
}

func (q *Queries) showLinkComments(ctx context.Context, idlinker int32) ([]*showLinkCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, showLinkComments, idlinker)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showLinkCommentsRow
	for rows.Next() {
		var i showLinkCommentsRow
		if err := rows.Scan(
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Username,
			&i.Listed,
			&i.ForumthreadIdforumthread,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showPost = `-- name: showPost :many
SELECT u.username, s.news, s.occured, s.idsiteNews, u.idusers, s.forumthread_idforumthread
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
WHERE s.idsiteNews = ?
`

type showPostRow struct {
	Username                 sql.NullString
	News                     sql.NullString
	Occured                  sql.NullTime
	Idsitenews               int32
	Idusers                  sql.NullInt32
	ForumthreadIdforumthread int32
}

func (q *Queries) showPost(ctx context.Context, idsitenews int32) ([]*showPostRow, error) {
	rows, err := q.db.QueryContext(ctx, showPost, idsitenews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showPostRow
	for rows.Next() {
		var i showPostRow
		if err := rows.Scan(
			&i.Username,
			&i.News,
			&i.Occured,
			&i.Idsitenews,
			&i.Idusers,
			&i.ForumthreadIdforumthread,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showTopicUserLevels = `-- name: showTopicUserLevels :one
SELECT r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, r.modlevel, r.adminlevel
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
WHERE idforumtopic = ?
`

type showTopicUserLevelsRow struct {
	Viewlevel      sql.NullInt32
	Replylevel     sql.NullInt32
	Newthreadlevel sql.NullInt32
	Seelevel       sql.NullInt32
	Invitelevel    sql.NullInt32
	Readlevel      sql.NullInt32
	Modlevel       sql.NullInt32
	Adminlevel     sql.NullInt32
}

func (q *Queries) showTopicUserLevels(ctx context.Context, idforumtopic int32) (*showTopicUserLevelsRow, error) {
	row := q.db.QueryRowContext(ctx, showTopicUserLevels, idforumtopic)
	var i showTopicUserLevelsRow
	err := row.Scan(
		&i.Viewlevel,
		&i.Replylevel,
		&i.Newthreadlevel,
		&i.Seelevel,
		&i.Invitelevel,
		&i.Readlevel,
		&i.Modlevel,
		&i.Adminlevel,
	)
	return &i, err
}

const show_blog = `-- name: show_blog :one
SELECT b.blog, b.written, u.username, b.idblogs, coalesce(th.comments, 0), b.users_idusers, b.forumthread_idforumthread
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE b.idblogs = ?
LIMIT 1
`

type show_blogRow struct {
	Blog                     sql.NullString
	Written                  time.Time
	Username                 sql.NullString
	Idblogs                  int32
	Comments                 int32
	UsersIdusers             int32
	ForumthreadIdforumthread int32
}

func (q *Queries) show_blog(ctx context.Context, idblogs int32) (*show_blogRow, error) {
	row := q.db.QueryRowContext(ctx, show_blog, idblogs)
	var i show_blogRow
	err := row.Scan(
		&i.Blog,
		&i.Written,
		&i.Username,
		&i.Idblogs,
		&i.Comments,
		&i.UsersIdusers,
		&i.ForumthreadIdforumthread,
	)
	return &i, err
}

const show_blog_edit = `-- name: show_blog_edit :one
SELECT b.blog, b.language_idlanguage
FROM blogs b, users u
WHERE b.users_idusers = u.idusers AND b.idblogs = ?
LIMIT 1
`

type show_blog_editRow struct {
	Blog               sql.NullString
	LanguageIdlanguage int32
}

func (q *Queries) show_blog_edit(ctx context.Context, idblogs int32) (*show_blog_editRow, error) {
	row := q.db.QueryRowContext(ctx, show_blog_edit, idblogs)
	var i show_blog_editRow
	err := row.Scan(&i.Blog, &i.LanguageIdlanguage)
	return &i, err
}

const show_blogger_list = `-- name: show_blogger_list :many
SELECT u.username, COUNT(b.idblogs)
FROM blogs b, users u
WHERE b.users_idusers = u.idusers
GROUP BY u.idusers
`

type show_blogger_listRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) show_blogger_list(ctx context.Context) ([]*show_blogger_listRow, error) {
	rows, err := q.db.QueryContext(ctx, show_blogger_list)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_blogger_listRow
	for rows.Next() {
		var i show_blogger_listRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_bookmarks = `-- name: show_bookmarks :one
SELECT Idbookmarks, list
FROM bookmarks
WHERE users_idusers = ?
`

type show_bookmarksRow struct {
	Idbookmarks int32
	List        sql.NullString
}

// This query retrieves the "list" from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) show_bookmarks(ctx context.Context, usersIdusers int32) (*show_bookmarksRow, error) {
	row := q.db.QueryRowContext(ctx, show_bookmarks, usersIdusers)
	var i show_bookmarksRow
	err := row.Scan(&i.Idbookmarks, &i.List)
	return &i, err
}

const show_categories = `-- name: show_categories :exec
SELECT f.idforumcategory, f.title, f.description
FROM forumcategory f WHERE f.forumcategory_idforumcategory = ?
`

type show_categoriesRow struct {
	Idforumcategory int32
	Title           sql.NullString
	Description     sql.NullString
}

func (q *Queries) show_categories(ctx context.Context, forumcategoryIdforumcategory int32) error {
	_, err := q.db.ExecContext(ctx, show_categories, forumcategoryIdforumcategory)
	return err
}

const show_latest_blogs = `-- name: show_latest_blogs :many
SELECT b.blog, b.written, u.username, b.idblogs, coalesce(th.comments, 0), b.users_idusers
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE (b.language_idlanguage = ? OR ? = 0) and (b.users_idusers = ? OR ? = 0)
ORDER BY b.written DESC
LIMIT ? OFFSET ?
`

type show_latest_blogsParams struct {
	LanguageIdlanguage int32
	UsersIdusers       int32
	Limit              int32
	Offset             int32
}

type show_latest_blogsRow struct {
	Blog         sql.NullString
	Written      time.Time
	Username     sql.NullString
	Idblogs      int32
	Comments     int32
	UsersIdusers int32
}

func (q *Queries) show_latest_blogs(ctx context.Context, arg show_latest_blogsParams) ([]*show_latest_blogsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_latest_blogs,
		arg.LanguageIdlanguage,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
		arg.UsersIdusers,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_latest_blogsRow
	for rows.Next() {
		var i show_latest_blogsRow
		if err := rows.Scan(
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Idblogs,
			&i.Comments,
			&i.UsersIdusers,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_questions = `-- name: show_questions :many
SELECT c.idfaqCategories, c.name, f.question, f.answer
FROM faq f
LEFT JOIN faqCategories c ON c.idfaqCategories = f.faqCategories_idfaqCategories
WHERE c.idfaqCategories <> 0 AND f.answer IS NOT NULL
ORDER BY c.idfaqCategories
`

type show_questionsRow struct {
	Idfaqcategories sql.NullInt32
	Name            sql.NullString
	Question        sql.NullString
	Answer          sql.NullString
}

func (q *Queries) show_questions(ctx context.Context) ([]*show_questionsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_questions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_questionsRow
	for rows.Next() {
		var i show_questionsRow
		if err := rows.Scan(
			&i.Idfaqcategories,
			&i.Name,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const somethingNotifyBlogs = `-- name: somethingNotifyBlogs :many
SELECT u.email FROM blogs t, users u, preferences p
WHERE t.idblogs=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type somethingNotifyBlogsParams struct {
	Idblogs int32
	Idusers int32
}

func (q *Queries) somethingNotifyBlogs(ctx context.Context, arg somethingNotifyBlogsParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, somethingNotifyBlogs, arg.Idblogs, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const somethingNotifyLinker = `-- name: somethingNotifyLinker :many
SELECT u.email FROM linker t, users u, preferences p
WHERE t.idlinker=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type somethingNotifyLinkerParams struct {
	Idlinker int32
	Idusers  int32
}

func (q *Queries) somethingNotifyLinker(ctx context.Context, arg somethingNotifyLinkerParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, somethingNotifyLinker, arg.Idlinker, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const somethingNotifyWriting = `-- name: somethingNotifyWriting :many
SELECT u.email FROM writing t, users u, preferences p
WHERE t.idwriting=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type somethingNotifyWritingParams struct {
	Idwriting int32
	Idusers   int32
}

func (q *Queries) somethingNotifyWriting(ctx context.Context, arg somethingNotifyWritingParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, somethingNotifyWriting, arg.Idwriting, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const threadAllowThis = `-- name: threadAllowThis :one
SELECT r.forumtopic_idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, r.modlevel, r.adminlevel, u.level FROM forumthread t
LEFT JOIN topicrestrictions r ON t.forumtopic_idforumtopic=r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic=t.forumtopic_idforumtopic AND u.users_idusers=?
WHERE t.idforumthread=? LIMIT 1
`

type threadAllowThisParams struct {
	UsersIdusers  int32
	Idforumthread int32
}

type threadAllowThisRow struct {
	ForumtopicIdforumtopic sql.NullInt32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
	Level                  sql.NullInt32
}

func (q *Queries) threadAllowThis(ctx context.Context, arg threadAllowThisParams) (*threadAllowThisRow, error) {
	row := q.db.QueryRowContext(ctx, threadAllowThis, arg.UsersIdusers, arg.Idforumthread)
	var i threadAllowThisRow
	err := row.Scan(
		&i.ForumtopicIdforumtopic,
		&i.Viewlevel,
		&i.Replylevel,
		&i.Newthreadlevel,
		&i.Seelevel,
		&i.Invitelevel,
		&i.Readlevel,
		&i.Modlevel,
		&i.Adminlevel,
		&i.Level,
	)
	return &i, err
}

const threadNotify = `-- name: threadNotify :many
SELECT u.email FROM comments c, users u, preferences p
WHERE c.forumthread_idforumthread=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=c.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type threadNotifyParams struct {
	ForumthreadIdforumthread int32
	Idusers                  int32
}

func (q *Queries) threadNotify(ctx context.Context, arg threadNotifyParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, threadNotify, arg.ForumthreadIdforumthread, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const topicAllowThis = `-- name: topicAllowThis :one
SELECT r.forumtopic_idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, r.modlevel, r.adminlevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic=r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic=t.idforumtopic AND u.users_idusers=?
WHERE t.idforumtopic=? LIMIT 1
`

type topicAllowThisParams struct {
	UsersIdusers int32
	Idforumtopic int32
}

type topicAllowThisRow struct {
	ForumtopicIdforumtopic sql.NullInt32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
	Level                  sql.NullInt32
}

func (q *Queries) topicAllowThis(ctx context.Context, arg topicAllowThisParams) (*topicAllowThisRow, error) {
	row := q.db.QueryRowContext(ctx, topicAllowThis, arg.UsersIdusers, arg.Idforumtopic)
	var i topicAllowThisRow
	err := row.Scan(
		&i.ForumtopicIdforumtopic,
		&i.Viewlevel,
		&i.Replylevel,
		&i.Newthreadlevel,
		&i.Seelevel,
		&i.Invitelevel,
		&i.Readlevel,
		&i.Modlevel,
		&i.Adminlevel,
		&i.Level,
	)
	return &i, err
}

const updateQueue = `-- name: updateQueue :exec
UPDATE linkerQueue SET linkerCategory_idlinkerCategory = ?, title = ?, url = ?, description = ? WHERE idlinkerQueue = ?
`

type updateQueueParams struct {
	LinkercategoryIdlinkercategory int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
	Idlinkerqueue                  int32
}

func (q *Queries) updateQueue(ctx context.Context, arg updateQueueParams) error {
	_, err := q.db.ExecContext(ctx, updateQueue,
		arg.LinkercategoryIdlinkercategory,
		arg.Title,
		arg.Url,
		arg.Description,
		arg.Idlinkerqueue,
	)
	return err
}

const updateWriting = `-- name: updateWriting :exec
UPDATE writing
SET writingCategory_idwritingCategory = ?, title = ?, abstract = ?, writting = ?, private = ?, language_idlanguage = ?
WHERE idwriting = ?
`

type updateWritingParams struct {
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Abstract                         sql.NullString
	Writting                         sql.NullString
	Private                          sql.NullBool
	LanguageIdlanguage               int32
	Idwriting                        int32
}

func (q *Queries) updateWriting(ctx context.Context, arg updateWritingParams) error {
	_, err := q.db.ExecContext(ctx, updateWriting,
		arg.WritingcategoryIdwritingcategory,
		arg.Title,
		arg.Abstract,
		arg.Writting,
		arg.Private,
		arg.LanguageIdlanguage,
		arg.Idwriting,
	)
	return err
}

const updateWritingApproval = `-- name: updateWritingApproval :exec
UPDATE writtingApprovedUsers
SET readdoc = ?, editdoc = ?
WHERE writing_idwriting = ? AND users_idusers = ?
`

type updateWritingApprovalParams struct {
	Readdoc          sql.NullBool
	Editdoc          sql.NullBool
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) updateWritingApproval(ctx context.Context, arg updateWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingApproval,
		arg.Readdoc,
		arg.Editdoc,
		arg.WritingIdwriting,
		arg.UsersIdusers,
	)
	return err
}

const updateWritingCategory = `-- name: updateWritingCategory :exec
UPDATE writingCategory
SET title = ?, description = ?, writingCategory_idwritingCategory = ?
WHERE idwritingCategory = ?
`

type updateWritingCategoryParams struct {
	Title                            sql.NullString
	Description                      sql.NullString
	WritingcategoryIdwritingcategory int32
	Idwritingcategory                int32
}

func (q *Queries) updateWritingCategory(ctx context.Context, arg updateWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingCategory,
		arg.Title,
		arg.Description,
		arg.WritingcategoryIdwritingcategory,
		arg.Idwritingcategory,
	)
	return err
}

const updateWritingForumThreadId = `-- name: updateWritingForumThreadId :exec
UPDATE writing
SET forumthread_idforumthread = ?
WHERE idwriting = ?
`

type updateWritingForumThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idwriting                int32
}

func (q *Queries) updateWritingForumThreadId(ctx context.Context, arg updateWritingForumThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingForumThreadId, arg.ForumthreadIdforumthread, arg.Idwriting)
	return err
}

const update_blog = `-- name: update_blog :exec
UPDATE blogs
SET language_idlanguage = ?, blog = ?
WHERE idblogs = ?
`

type update_blogParams struct {
	LanguageIdlanguage int32
	Blog               sql.NullString
	Idblogs            int32
}

func (q *Queries) update_blog(ctx context.Context, arg update_blogParams) error {
	_, err := q.db.ExecContext(ctx, update_blog, arg.LanguageIdlanguage, arg.Blog, arg.Idblogs)
	return err
}

const update_bookmarks = `-- name: update_bookmarks :exec
UPDATE bookmarks
SET list = ?
WHERE users_idusers = ?
`

type update_bookmarksParams struct {
	List         sql.NullString
	UsersIdusers int32
}

// This query updates the "list" column in the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) update_bookmarks(ctx context.Context, arg update_bookmarksParams) error {
	_, err := q.db.ExecContext(ctx, update_bookmarks, arg.List, arg.UsersIdusers)
	return err
}

const update_comment = `-- name: update_comment :exec
UPDATE comments
SET language_idlanguage = ?, text = ?
WHERE idcomments = ?
`

type update_commentParams struct {
	LanguageIdlanguage int32
	Text               sql.NullString
	Idcomments         int32
}

func (q *Queries) update_comment(ctx context.Context, arg update_commentParams) error {
	_, err := q.db.ExecContext(ctx, update_comment, arg.LanguageIdlanguage, arg.Text, arg.Idcomments)
	return err
}

const update_forumthread = `-- name: update_forumthread :exec
UPDATE forumthread
SET lastaddition = (
    SELECT written
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
), comments = (
    SELECT COUNT(users_idusers) - 1
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
), lastposter = (
    SELECT users_idusers
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
), firstpost = (
    SELECT idcomments
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    LIMIT 1
)
WHERE idforumthread = ?
`

func (q *Queries) update_forumthread(ctx context.Context, idforumthread int32) error {
	_, err := q.db.ExecContext(ctx, update_forumthread, idforumthread)
	return err
}

const update_forumthreads = `-- name: update_forumthreads :exec
UPDATE forumthread
SET lastaddition = (
    SELECT written
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
), comments = (
    SELECT COUNT(users_idusers) - 1
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
), lastposter = (
    SELECT users_idusers
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
), firstpost = (
    SELECT idcomments
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    LIMIT 1
)
`

func (q *Queries) update_forumthreads(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthreads)
	return err
}

const update_forumtopic = `-- name: update_forumtopic :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
), lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
WHERE idforumtopic = ?
`

func (q *Queries) update_forumtopic(ctx context.Context, idforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic, idforumtopic)
	return err
}

const update_forumtopics = `-- name: update_forumtopics :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
), lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
`

func (q *Queries) update_forumtopics(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopics)
	return err
}

const userAllow = `-- name: userAllow :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES (?, ?, ?)
`

type userAllowParams struct {
	UsersIdusers int32
	Section      sql.NullString
	Level        sql.NullString
}

// This query inserts a new permission into the "permissions" table.
// Parameters:
//
//	? - User ID to be associated with the permission (int)
//	? - Section for which the permission is granted (string)
//	? - Level of the permission (string)
func (q *Queries) userAllow(ctx context.Context, arg userAllowParams) error {
	_, err := q.db.ExecContext(ctx, userAllow, arg.UsersIdusers, arg.Section, arg.Level)
	return err
}

const userDisallow = `-- name: userDisallow :exec
DELETE FROM permissions
WHERE idpermissions = ?
`

// This query deletes a permission from the "permissions" table based on the provided "permid".
// Parameters:
//
//	? - Permission ID to be deleted (int)
func (q *Queries) userDisallow(ctx context.Context, idpermissions int32) error {
	_, err := q.db.ExecContext(ctx, userDisallow, idpermissions)
	return err
}

const user_allow = `-- name: user_allow :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES (?, ?, ?)
`

type user_allowParams struct {
	UsersIdusers int32
	Section      sql.NullString
	Level        sql.NullString
}

func (q *Queries) user_allow(ctx context.Context, arg user_allowParams) error {
	_, err := q.db.ExecContext(ctx, user_allow, arg.UsersIdusers, arg.Section, arg.Level)
	return err
}

const user_disallow = `-- name: user_disallow :exec
DELETE FROM permissions
WHERE idpermissions = ? AND section = ?
`

type user_disallowParams struct {
	Idpermissions int32
	Section       sql.NullString
}

func (q *Queries) user_disallow(ctx context.Context, arg user_disallowParams) error {
	_, err := q.db.ExecContext(ctx, user_disallow, arg.Idpermissions, arg.Section)
	return err
}

const user_get_all_comments_for_thread = `-- name: user_get_all_comments_for_thread :many
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text, pu.username AS posterusername
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_idforumthread=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users pu ON pu.idusers = c.users_idusers
WHERE c.forumthread_idforumthread=? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY c.written
`

type user_get_all_comments_for_threadParams struct {
	UsersIdusers             int32
	ForumthreadIdforumthread int32
}

type user_get_all_comments_for_threadRow struct {
	Idcomments               int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Written                  sql.NullTime
	Text                     sql.NullString
	Posterusername           sql.NullString
}

func (q *Queries) user_get_all_comments_for_thread(ctx context.Context, arg user_get_all_comments_for_threadParams) ([]*user_get_all_comments_for_threadRow, error) {
	rows, err := q.db.QueryContext(ctx, user_get_all_comments_for_thread, arg.UsersIdusers, arg.ForumthreadIdforumthread)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*user_get_all_comments_for_threadRow
	for rows.Next() {
		var i user_get_all_comments_for_threadRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const user_get_comment = `-- name: user_get_comment :one
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text, pu.Username
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_idforumthread=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users pu ON pu.idusers = c.users_idusers
WHERE c.idcomments = ? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
LIMIT 1
`

type user_get_commentParams struct {
	UsersIdusers int32
	Idcomments   int32
}

type user_get_commentRow struct {
	Idcomments               int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Written                  sql.NullTime
	Text                     sql.NullString
	Username                 sql.NullString
}

func (q *Queries) user_get_comment(ctx context.Context, arg user_get_commentParams) (*user_get_commentRow, error) {
	row := q.db.QueryRowContext(ctx, user_get_comment, arg.UsersIdusers, arg.Idcomments)
	var i user_get_commentRow
	err := row.Scan(
		&i.Idcomments,
		&i.ForumthreadIdforumthread,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Written,
		&i.Text,
		&i.Username,
	)
	return &i, err
}

const user_get_thread = `-- name: user_get_thread :one
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked, lu.username AS LastPosterUsername, r.seelevel, u.level
FROM forumthread th
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0) AND th.idforumthread=?
ORDER BY t.lastaddition DESC
`

type user_get_threadParams struct {
	UsersIdusers  int32
	Idforumthread int32
}

type user_get_threadRow struct {
	Idforumthread          int32
	Firstpost              int32
	Lastposter             int32
	ForumtopicIdforumtopic int32
	Comments               sql.NullInt32
	Lastaddition           sql.NullTime
	Locked                 sql.NullBool
	Lastposterusername     sql.NullString
	Seelevel               sql.NullInt32
	Level                  sql.NullInt32
}

func (q *Queries) user_get_thread(ctx context.Context, arg user_get_threadParams) (*user_get_threadRow, error) {
	row := q.db.QueryRowContext(ctx, user_get_thread, arg.UsersIdusers, arg.Idforumthread)
	var i user_get_threadRow
	err := row.Scan(
		&i.Idforumthread,
		&i.Firstpost,
		&i.Lastposter,
		&i.ForumtopicIdforumtopic,
		&i.Comments,
		&i.Lastaddition,
		&i.Locked,
		&i.Lastposterusername,
		&i.Seelevel,
		&i.Level,
	)
	return &i, err
}

const user_get_threads_for_topic = `-- name: user_get_threads_for_topic :many
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked, lu.username AS lastposterusername, lu.idusers AS lastposterid, fcu.username as firstpostusername, fc.written as firstpostwritten, fc.text as firstposttext
FROM forumthread th
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
LEFT JOIN comments fc ON th.firstpost=fc.idcomments
LEFT JOIN users fcu ON fcu.idusers = fc.users_idusers
WHERE th.forumtopic_idforumtopic=? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY th.lastaddition DESC
`

type user_get_threads_for_topicParams struct {
	UsersIdusers           int32
	ForumtopicIdforumtopic int32
}

type user_get_threads_for_topicRow struct {
	Idforumthread          int32
	Firstpost              int32
	Lastposter             int32
	ForumtopicIdforumtopic int32
	Comments               sql.NullInt32
	Lastaddition           sql.NullTime
	Locked                 sql.NullBool
	Lastposterusername     sql.NullString
	Lastposterid           sql.NullInt32
	Firstpostusername      sql.NullString
	Firstpostwritten       sql.NullTime
	Firstposttext          sql.NullString
}

func (q *Queries) user_get_threads_for_topic(ctx context.Context, arg user_get_threads_for_topicParams) ([]*user_get_threads_for_topicRow, error) {
	rows, err := q.db.QueryContext(ctx, user_get_threads_for_topic, arg.UsersIdusers, arg.ForumtopicIdforumtopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*user_get_threads_for_topicRow
	for rows.Next() {
		var i user_get_threads_for_topicRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Firstpost,
			&i.Lastposter,
			&i.ForumtopicIdforumtopic,
			&i.Comments,
			&i.Lastaddition,
			&i.Locked,
			&i.Lastposterusername,
			&i.Lastposterid,
			&i.Firstpostusername,
			&i.Firstpostwritten,
			&i.Firstposttext,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const user_get_topic = `-- name: user_get_topic :one
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0) AND t.idforumtopic=?
ORDER BY t.lastaddition DESC
`

type user_get_topicParams struct {
	UsersIdusers int32
	Idforumtopic int32
}

type user_get_topicRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
	Seelevel                     sql.NullInt32
	Level                        sql.NullInt32
}

func (q *Queries) user_get_topic(ctx context.Context, arg user_get_topicParams) (*user_get_topicRow, error) {
	row := q.db.QueryRowContext(ctx, user_get_topic, arg.UsersIdusers, arg.Idforumtopic)
	var i user_get_topicRow
	err := row.Scan(
		&i.Idforumtopic,
		&i.Lastposter,
		&i.ForumcategoryIdforumcategory,
		&i.Title,
		&i.Description,
		&i.Threads,
		&i.Comments,
		&i.Lastaddition,
		&i.Lastposterusername,
		&i.Seelevel,
		&i.Level,
	)
	return &i, err
}

const usernametouid = `-- name: usernametouid :one

SELECT idusers FROM users WHERE username = ?
`

// -- name: forumTopicSearch :many
// SELECT * FROM comments c
// LEFT JOIN forumthread th ON th.idforumthread = c.forumthread_idforumthread
// LEFT JOIN forumtopic t ON t.idforumtopic = th.forumtopic_idforumtopic
// LEFT JOIN userstopiclevel utl ON t.idforumtopic = utl.forumtopic_idforumtopic AND utl.users_idusers = ?
// LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
//
//	WHERE c.idcomments IN (?) AND th.idforumthread != 0 AND t.idforumtopic = ?
//
// AND ((r.readlevel <= utl.level AND r.viewlevel <= utl.level AND r.seelevel <= utl.level));
//
// -- name: forumSearch :many
// SELECT c.forumthread_idforumthread FROM comments c
// LEFT JOIN forumthread th ON th.idforumthread = c.forumthread_idforumthread
// LEFT JOIN forumtopic t ON t.idforumtopic = th.forumtopic_idforumtopic
// LEFT JOIN forumcategory fc ON fc.idforumcategory = t.forumcategory_idforumcategory
// LEFT JOIN userstopiclevel utl ON t.idforumtopic = utl.forumtopic_idforumtopic AND utl.users_idusers = ?
// LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
// WHERE c.idcomments IN (?) AND th.idforumthread != 0 AND t.idforumtopic != 0
// AND ((r.readlevel <= utl.level AND r.viewlevel <= utl.level AND r.seelevel <= utl.level) OR ?)
// AND fc.idforumcategory != 0
// GROUP BY c.forumthread_idforumthread;
func (q *Queries) usernametouid(ctx context.Context, username sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, usernametouid, username)
	var idusers int32
	err := row.Scan(&idusers)
	return idusers, err
}

const users_bookmarks = `-- name: users_bookmarks :one
SELECT list
FROM bookmarks
WHERE users_idusers = ?
`

// This query retrieves the "list" from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) users_bookmarks(ctx context.Context, usersIdusers int32) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, users_bookmarks, usersIdusers)
	var list sql.NullString
	err := row.Scan(&list)
	return list, err
}

const writeLinkerRSS = `-- name: writeLinkerRSS :many
SELECT l.idlinker, l.title, l.description, l.url
FROM linker l
WHERE l.linkerCategory_idlinkerCategory = ?
ORDER BY l.listed DESC
`

type writeLinkerRSSRow struct {
	Idlinker    int32
	Title       sql.NullString
	Description sql.NullString
	Url         sql.NullString
}

func (q *Queries) writeLinkerRSS(ctx context.Context, linkercategoryIdlinkercategory int32) ([]*writeLinkerRSSRow, error) {
	rows, err := q.db.QueryContext(ctx, writeLinkerRSS, linkercategoryIdlinkercategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*writeLinkerRSSRow
	for rows.Next() {
		var i writeLinkerRSSRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.Title,
			&i.Description,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const writeNewsPost = `-- name: writeNewsPost :exec
INSERT INTO siteNews (news, users_idusers, occured, language_idlanguage)
VALUES (?, ?, NOW(), ?)
`

type writeNewsPostParams struct {
	News               sql.NullString
	UsersIdusers       int32
	LanguageIdlanguage int32
}

func (q *Queries) writeNewsPost(ctx context.Context, arg writeNewsPostParams) error {
	_, err := q.db.ExecContext(ctx, writeNewsPost, arg.News, arg.UsersIdusers, arg.LanguageIdlanguage)
	return err
}

const writeRSS = `-- name: writeRSS :exec
SELECT title, description FROM imageboard WHERE idimageboard = ?
`

type writeRSSRow struct {
	Title       sql.NullString
	Description sql.NullString
}

func (q *Queries) writeRSS(ctx context.Context, idimageboard int32) error {
	_, err := q.db.ExecContext(ctx, writeRSS, idimageboard)
	return err
}

const writeSiteNewsRSS = `-- name: writeSiteNewsRSS :many
SELECT s.idsiteNews, s.occured, s.news
FROM siteNews s
ORDER BY s.occured DESC LIMIT 15
`

type writeSiteNewsRSSRow struct {
	Idsitenews int32
	Occured    sql.NullTime
	News       sql.NullString
}

func (q *Queries) writeSiteNewsRSS(ctx context.Context) ([]*writeSiteNewsRSSRow, error) {
	rows, err := q.db.QueryContext(ctx, writeSiteNewsRSS)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*writeSiteNewsRSSRow
	for rows.Next() {
		var i writeSiteNewsRSSRow
		if err := rows.Scan(&i.Idsitenews, &i.Occured, &i.News); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const write_blog_atom = `-- name: write_blog_atom :many
SELECT b.idblogs, LEFT(b.written, 255), b.blog, u.username
FROM blogs b, users u
WHERE u.idusers = b.users_idusers AND b.users_idusers = ?
ORDER BY b.written DESC
LIMIT ?
`

type write_blog_atomParams struct {
	UsersIdusers int32
	Limit        int32
}

type write_blog_atomRow struct {
	Idblogs  int32
	Left     string
	Blog     sql.NullString
	Username sql.NullString
}

func (q *Queries) write_blog_atom(ctx context.Context, arg write_blog_atomParams) ([]*write_blog_atomRow, error) {
	rows, err := q.db.QueryContext(ctx, write_blog_atom, arg.UsersIdusers, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*write_blog_atomRow
	for rows.Next() {
		var i write_blog_atomRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.Left,
			&i.Blog,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const write_blog_rss = `-- name: write_blog_rss :many
SELECT b.idblogs, LEFT(b.written, 255), b.blog, u.username
FROM blogs b, users u
WHERE u.idusers = b.users_idusers AND b.users_idusers= ?
ORDER BY b.written DESC
LIMIT ?
`

type write_blog_rssParams struct {
	UsersIdusers int32
	Limit        int32
}

type write_blog_rssRow struct {
	Idblogs  int32
	Left     string
	Blog     sql.NullString
	Username sql.NullString
}

func (q *Queries) write_blog_rss(ctx context.Context, arg write_blog_rssParams) ([]*write_blog_rssRow, error) {
	rows, err := q.db.QueryContext(ctx, write_blog_rss, arg.UsersIdusers, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*write_blog_rssRow
	for rows.Next() {
		var i write_blog_rssRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.Left,
			&i.Blog,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
