// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: queries.sql

package main

import (
	"context"
	"database/sql"
)

const checkExistingUser = `-- name: CheckExistingUser :one
SELECT username FROM users WHERE username = ?
`

func (q *Queries) CheckExistingUser(ctx context.Context, username sql.NullString) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, checkExistingUser, username)
	err := row.Scan(&username)
	return username, err
}

const insertSID = `-- name: InsertSID :exec
INSERT INTO sidTable (sid, loginTime, users_idusers)
VALUES (?, NOW(), ?)
`

type InsertSIDParams struct {
	Sid          sql.NullString
	UsersIdusers int32
}

func (q *Queries) InsertSID(ctx context.Context, arg InsertSIDParams) error {
	_, err := q.db.ExecContext(ctx, insertSID, arg.Sid, arg.UsersIdusers)
	return err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO users (username, passwd, email)
VALUES (?, MD5(?), ?)
`

type InsertUserParams struct {
	Username sql.NullString
	MD5      string
	Email    sql.NullString
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.ExecContext(ctx, insertUser, arg.Username, arg.MD5, arg.Email)
	return err
}

const login = `-- name: Login :one
SELECT idusers FROM users
WHERE username = ? AND passwd = md5(?)
`

type LoginParams struct {
	Username sql.NullString
	MD5      string
}

func (q *Queries) Login(ctx context.Context, arg LoginParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, login, arg.Username, arg.MD5)
	var idusers int32
	err := row.Scan(&idusers)
	return idusers, err
}

const sIDExpired = `-- name: SIDExpired :one
SELECT idsidTable, loginTime, users_idusers FROM sidTable
WHERE sid = ? LIMIT 1
`

type SIDExpiredRow struct {
	Idsidtable   int32
	Logintime    sql.NullTime
	UsersIdusers int32
}

func (q *Queries) SIDExpired(ctx context.Context, sid sql.NullString) (*SIDExpiredRow, error) {
	row := q.db.QueryRowContext(ctx, sIDExpired, sid)
	var i SIDExpiredRow
	err := row.Scan(&i.Idsidtable, &i.Logintime, &i.UsersIdusers)
	return &i, err
}

const selectLanguages = `-- name: SelectLanguages :many
SELECT idlanguage, nameof
FROM language
`

// This query selects all languages from the "language" table.
// Result:
//
//	idlanguage (int)
//	nameof (string)
func (q *Queries) SelectLanguages(ctx context.Context) ([]*Language, error) {
	rows, err := q.db.QueryContext(ctx, selectLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(&i.Idlanguage, &i.Nameof); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUserBySID = `-- name: SelectUserBySID :one
SELECT idsidTable, loginTime, users_idusers
FROM sidTable
WHERE sid = ?
`

type SelectUserBySIDRow struct {
	Idsidtable   int32
	Logintime    sql.NullTime
	UsersIdusers int32
}

func (q *Queries) SelectUserBySID(ctx context.Context, sid sql.NullString) (*SelectUserBySIDRow, error) {
	row := q.db.QueryRowContext(ctx, selectUserBySID, sid)
	var i SelectUserBySIDRow
	err := row.Scan(&i.Idsidtable, &i.Logintime, &i.UsersIdusers)
	return &i, err
}

const updateLoginTimeAndUser = `-- name: UpdateLoginTimeAndUser :exec
UPDATE sidTable SET loginTime = NOW(), users_idusers = ?
WHERE sid = ?
`

type UpdateLoginTimeAndUserParams struct {
	UsersIdusers int32
	Sid          sql.NullString
}

func (q *Queries) UpdateLoginTimeAndUser(ctx context.Context, arg UpdateLoginTimeAndUserParams) error {
	_, err := q.db.ExecContext(ctx, updateLoginTimeAndUser, arg.UsersIdusers, arg.Sid)
	return err
}

const addImage = `-- name: addImage :exec
INSERT INTO imagepost (imageboard_idimageboard, thumbnail, fullimage, users_idusers, description, posted)
VALUES (?, ?, ?, ?, ?, NOW())
`

type addImageParams struct {
	ImageboardIdimageboard int32
	Thumbnail              sql.NullString
	Fullimage              sql.NullString
	UsersIdusers           int32
	Description            sql.NullString
}

func (q *Queries) addImage(ctx context.Context, arg addImageParams) error {
	_, err := q.db.ExecContext(ctx, addImage,
		arg.ImageboardIdimageboard,
		arg.Thumbnail,
		arg.Fullimage,
		arg.UsersIdusers,
		arg.Description,
	)
	return err
}

const addToLinker = `-- name: addToLinker :exec
INSERT INTO linker (users_idusers, linkerCategory_idlinkerCategory, title, url, description, listed)
VALUES (?, ?, ?, ?, ?, NOW())
`

type addToLinkerParams struct {
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
}

func (q *Queries) addToLinker(ctx context.Context, arg addToLinkerParams) error {
	_, err := q.db.ExecContext(ctx, addToLinker,
		arg.UsersIdusers,
		arg.LinkercategoryIdlinkercategory,
		arg.Title,
		arg.Url,
		arg.Description,
	)
	return err
}

const addToQueue = `-- name: addToQueue :exec
INSERT INTO linkerQueue (users_idusers, linkerCategory_idlinkerCategory, title, url, description) VALUES (?, ?, ?, ?, ?)
`

type addToQueueParams struct {
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
}

func (q *Queries) addToQueue(ctx context.Context, arg addToQueueParams) error {
	_, err := q.db.ExecContext(ctx, addToQueue,
		arg.UsersIdusers,
		arg.LinkercategoryIdlinkercategory,
		arg.Title,
		arg.Url,
		arg.Description,
	)
	return err
}

const addTopicRestrictions = `-- name: addTopicRestrictions :exec
INSERT INTO topicrestrictions (forumtopic_idforumtopic, viewlevel, replylevel, newthreadlevel, seelevel, invitelevel, readlevel, modlevel, adminlevel)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type addTopicRestrictionsParams struct {
	ForumtopicIdforumtopic int32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) addTopicRestrictions(ctx context.Context, arg addTopicRestrictionsParams) error {
	_, err := q.db.ExecContext(ctx, addTopicRestrictions,
		arg.ForumtopicIdforumtopic,
		arg.Viewlevel,
		arg.Replylevel,
		arg.Newthreadlevel,
		arg.Seelevel,
		arg.Invitelevel,
		arg.Readlevel,
		arg.Modlevel,
		arg.Adminlevel,
	)
	return err
}

const addUsersTopicLevel = `-- name: addUsersTopicLevel :exec
INSERT INTO userstopiclevel (forumtopic_idforumtopic, users_idusers, level, invitemax)
VALUES (?, ?, ?, ?)
`

type addUsersTopicLevelParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
	Level                  sql.NullInt32
	Invitemax              sql.NullInt32
}

func (q *Queries) addUsersTopicLevel(ctx context.Context, arg addUsersTopicLevelParams) error {
	_, err := q.db.ExecContext(ctx, addUsersTopicLevel,
		arg.ForumtopicIdforumtopic,
		arg.UsersIdusers,
		arg.Level,
		arg.Invitemax,
	)
	return err
}

const addWord = `-- name: addWord :exec
INSERT INTO searchwordlist (word) VALUES (lcase(?))
`

func (q *Queries) addWord(ctx context.Context, lcase string) error {
	_, err := q.db.ExecContext(ctx, addWord, lcase)
	return err
}

const add_blog = `-- name: add_blog :exec
INSERT INTO blogs (users_idusers, language_idlanguage, blog, written)
VALUES (?, ?, ?, NOW())
`

type add_blogParams struct {
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
}

func (q *Queries) add_blog(ctx context.Context, arg add_blogParams) error {
	_, err := q.db.ExecContext(ctx, add_blog, arg.UsersIdusers, arg.LanguageIdlanguage, arg.Blog)
	return err
}

const add_bookmarks = `-- name: add_bookmarks :exec
INSERT INTO bookmarks (users_idusers, list)
VALUES (?, ?)
`

type add_bookmarksParams struct {
	UsersIdusers int32
	List         sql.NullString
}

// This query adds a new entry to the "bookmarks" table and returns the last inserted ID as "returnthis".
func (q *Queries) add_bookmarks(ctx context.Context, arg add_bookmarksParams) error {
	_, err := q.db.ExecContext(ctx, add_bookmarks, arg.UsersIdusers, arg.List)
	return err
}

const add_question = `-- name: add_question :exec
INSERT INTO faq (question, users_idusers, language_idlanguage)
VALUES (?, ?, ?)
`

type add_questionParams struct {
	Question           sql.NullString
	UsersIdusers       int32
	LanguageIdlanguage int32
}

func (q *Queries) add_question(ctx context.Context, arg add_questionParams) error {
	_, err := q.db.ExecContext(ctx, add_question, arg.Question, arg.UsersIdusers, arg.LanguageIdlanguage)
	return err
}

const adminCategories = `-- name: adminCategories :many
SELECT idlinkerCategory, title FROM linkerCategory
`

func (q *Queries) adminCategories(ctx context.Context) ([]*Linkercategory, error) {
	rows, err := q.db.QueryContext(ctx, adminCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Linkercategory
	for rows.Next() {
		var i Linkercategory
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUserPermissions = `-- name: adminUserPermissions :many
SELECT p.idpermissions, p.level, u.username, u.email, p.section
FROM permissions p, users u
WHERE u.idusers = p.users_idusers
ORDER BY p.level
`

type adminUserPermissionsRow struct {
	Idpermissions int32
	Level         sql.NullString
	Username      sql.NullString
	Email         sql.NullString
	Section       sql.NullString
}

// This query selects permissions information for admin users.
// Result:
//
//	idpermissions (int)
//	level (int)
//	username (string)
//	email (string)
//	section (string)
func (q *Queries) adminUserPermissions(ctx context.Context) ([]*adminUserPermissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminUserPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*adminUserPermissionsRow
	for rows.Next() {
		var i adminUserPermissionsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.Level,
			&i.Username,
			&i.Email,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUsers = `-- name: adminUsers :many
SELECT u.idusers, u.username, u.email
FROM users u
`

type adminUsersRow struct {
	Idusers  int32
	Username sql.NullString
	Email    sql.NullString
}

// This query selects all admin users from the "users" table.
// Result:
//
//	idusers (int)
//	username (string)
//	email (string)
func (q *Queries) adminUsers(ctx context.Context) ([]*adminUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, adminUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*adminUsersRow
	for rows.Next() {
		var i adminUsersRow
		if err := rows.Scan(&i.Idusers, &i.Username, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const admin_categories = `-- name: admin_categories :many
SELECT idfaqCategories, name
FROM faqCategories
`

func (q *Queries) admin_categories(ctx context.Context) ([]*Faqcategory, error) {
	rows, err := q.db.QueryContext(ctx, admin_categories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faqcategory
	for rows.Next() {
		var i Faqcategory
		if err := rows.Scan(&i.Idfaqcategories, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const admin_user_permissions = `-- name: admin_user_permissions :many
SELECT p.idpermissions, p.level, u.username, u.email, p.section
FROM permissions p, users u
WHERE u.idusers = p.users_idusers AND p.section = ?
ORDER BY p.level
`

type admin_user_permissionsRow struct {
	Idpermissions int32
	Level         sql.NullString
	Username      sql.NullString
	Email         sql.NullString
	Section       sql.NullString
}

func (q *Queries) admin_user_permissions(ctx context.Context, section sql.NullString) ([]*admin_user_permissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, admin_user_permissions, section)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*admin_user_permissionsRow
	for rows.Next() {
		var i admin_user_permissionsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.Level,
			&i.Username,
			&i.Email,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const assignImagePostThisThreadId = `-- name: assignImagePostThisThreadId :exec
UPDATE imagepost SET forumthread_idforumthread = ? WHERE idimagepost = ?
`

type assignImagePostThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idimagepost              int32
}

func (q *Queries) assignImagePostThisThreadId(ctx context.Context, arg assignImagePostThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignImagePostThisThreadId, arg.ForumthreadIdforumthread, arg.Idimagepost)
	return err
}

const assignLinkerThisThreadId = `-- name: assignLinkerThisThreadId :exec
UPDATE linker SET forumthread_idforumthread = ? WHERE idlinker = ?
`

type assignLinkerThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idlinker                 int32
}

func (q *Queries) assignLinkerThisThreadId(ctx context.Context, arg assignLinkerThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignLinkerThisThreadId, arg.ForumthreadIdforumthread, arg.Idlinker)
	return err
}

const assignNewsThisThreadId = `-- name: assignNewsThisThreadId :exec
UPDATE siteNews SET forumthread_idforumthread = ? WHERE idsiteNews = ?
`

type assignNewsThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idsitenews               int32
}

func (q *Queries) assignNewsThisThreadId(ctx context.Context, arg assignNewsThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignNewsThisThreadId, arg.ForumthreadIdforumthread, arg.Idsitenews)
	return err
}

const assign_answer = `-- name: assign_answer :exec
UPDATE faq
SET answer = ?
WHERE idfaq = ?
`

type assign_answerParams struct {
	Answer sql.NullString
	Idfaq  int32
}

func (q *Queries) assign_answer(ctx context.Context, arg assign_answerParams) error {
	_, err := q.db.ExecContext(ctx, assign_answer, arg.Answer, arg.Idfaq)
	return err
}

const assign_blog_to_thread = `-- name: assign_blog_to_thread :exec
UPDATE blogs
SET forumthread_idforumthread = ?
WHERE idblogs = ?
`

type assign_blog_to_threadParams struct {
	ForumthreadIdforumthread int32
	Idblogs                  int32
}

func (q *Queries) assign_blog_to_thread(ctx context.Context, arg assign_blog_to_threadParams) error {
	_, err := q.db.ExecContext(ctx, assign_blog_to_thread, arg.ForumthreadIdforumthread, arg.Idblogs)
	return err
}

const blogid_to_userid = `-- name: blogid_to_userid :one
SELECT idusers
FROM users u, blogs b
WHERE u.idusers = b.users_idusers AND b.idblogs = ?
`

func (q *Queries) blogid_to_userid(ctx context.Context, idblogs int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, blogid_to_userid, idblogs)
	var idusers int32
	err := row.Scan(&idusers)
	return idusers, err
}

const categories = `-- name: categories :one
SELECT idfaqCategories, name
FROM faqCategories
`

func (q *Queries) categories(ctx context.Context) (*Faqcategory, error) {
	row := q.db.QueryRowContext(ctx, categories)
	var i Faqcategory
	err := row.Scan(&i.Idfaqcategories, &i.Name)
	return &i, err
}

const category_combobox = `-- name: category_combobox :many
SELECT idlinkerCategory, title FROM linkerCategory
`

func (q *Queries) category_combobox(ctx context.Context) ([]*Linkercategory, error) {
	rows, err := q.db.QueryContext(ctx, category_combobox)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Linkercategory
	for rows.Next() {
		var i Linkercategory
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const category_faqs = `-- name: category_faqs :many
SELECT question, idfaq, answer, faqCategories_idfaqCategories
FROM faq
WHERE faqCategories_idfaqCategories = ? OR answer IS NULL
`

type category_faqsRow struct {
	Question                     sql.NullString
	Idfaq                        int32
	Answer                       sql.NullString
	FaqcategoriesIdfaqcategories int32
}

func (q *Queries) category_faqs(ctx context.Context, faqcategoriesIdfaqcategories int32) ([]*category_faqsRow, error) {
	rows, err := q.db.QueryContext(ctx, category_faqs, faqcategoriesIdfaqcategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*category_faqsRow
	for rows.Next() {
		var i category_faqsRow
		if err := rows.Scan(
			&i.Question,
			&i.Idfaq,
			&i.Answer,
			&i.FaqcategoriesIdfaqcategories,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const changeCategory = `-- name: changeCategory :exec
UPDATE forumcategory SET title = ?, description = ? WHERE idforumcategory = ?
`

type changeCategoryParams struct {
	Title           sql.NullString
	Description     sql.NullString
	Idforumcategory int32
}

func (q *Queries) changeCategory(ctx context.Context, arg changeCategoryParams) error {
	_, err := q.db.ExecContext(ctx, changeCategory, arg.Title, arg.Description, arg.Idforumcategory)
	return err
}

const changeImageBoard = `-- name: changeImageBoard :exec
UPDATE imageboard SET title = ?, description = ?, imageboard_idimageboard = ? WHERE idimageboard = ?
`

type changeImageBoardParams struct {
	Title                  sql.NullString
	Description            sql.NullString
	ImageboardIdimageboard int32
	Idimageboard           int32
}

func (q *Queries) changeImageBoard(ctx context.Context, arg changeImageBoardParams) error {
	_, err := q.db.ExecContext(ctx, changeImageBoard,
		arg.Title,
		arg.Description,
		arg.ImageboardIdimageboard,
		arg.Idimageboard,
	)
	return err
}

const changeTopic = `-- name: changeTopic :exec
UPDATE forumtopic SET title = ?, description = ? WHERE idforumtopic = ?
`

type changeTopicParams struct {
	Title        sql.NullString
	Description  sql.NullString
	Idforumtopic int32
}

func (q *Queries) changeTopic(ctx context.Context, arg changeTopicParams) error {
	_, err := q.db.ExecContext(ctx, changeTopic, arg.Title, arg.Description, arg.Idforumtopic)
	return err
}

const completeWordList = `-- name: completeWordList :exec
SELECT word
FROM searchwordlist
`

// This query selects all words from the "searchwordlist" table and prints them.
func (q *Queries) completeWordList(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, completeWordList)
	return err
}

const countCategories = `-- name: countCategories :one
SELECT COUNT(*) AS count
FROM language
`

// This query returns the count of all records in the "language" table.
// Result:
//
//	count(*) - The count of rows in the "language" table (int)
func (q *Queries) countCategories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCategories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLinkerCategories = `-- name: countLinkerCategories :one


SELECT COUNT(*) FROM linkerCategory
`

// -- name: showNews :one
// SELECT count(idsiteNews) FROM siteNews
// WHERE ? AND ?;
// -- name: showNewsPosts :many
// SELECT u.username, s.news, s.occured, s.idsiteNews, u.idusers, IF(th.comments IS NULL, 0, th.comments + 1)
// FROM siteNews s
// LEFT JOIN users u ON s.users_idusers = u.idusers
// LEFT JOIN forumthread th ON s.forumthread_idforumthread = th.idforumthread
// WHERE ? AND ?
// ORDER BY s.occured DESC
// LIMIT 10;
func (q *Queries) countLinkerCategories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLinkerCategories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const count_categories = `-- name: count_categories :one
SELECT COUNT(*) FROM faqCategories
`

func (q *Queries) count_categories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, count_categories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCategory = `-- name: createCategory :exec
INSERT INTO linkerCategory (title) VALUES (?)
`

func (q *Queries) createCategory(ctx context.Context, title sql.NullString) error {
	_, err := q.db.ExecContext(ctx, createCategory, title)
	return err
}

const createLanguage = `-- name: createLanguage :exec
INSERT INTO language (nameof)
VALUES (?)
`

// This query inserts a new record into the "language" table.
// Parameters:
//
//	? - Name of the new language (string)
func (q *Queries) createLanguage(ctx context.Context, nameof sql.NullString) error {
	_, err := q.db.ExecContext(ctx, createLanguage, nameof)
	return err
}

const create_category = `-- name: create_category :exec
INSERT INTO faqCategories (name)
VALUES (?)
`

func (q *Queries) create_category(ctx context.Context, name sql.NullString) error {
	_, err := q.db.ExecContext(ctx, create_category, name)
	return err
}

const deleteBlogsSearch = `-- name: deleteBlogsSearch :exec
DELETE FROM blogsSearch
`

// This query deletes all data from the "blogsSearch" table.
func (q *Queries) deleteBlogsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteBlogsSearch)
	return err
}

const deleteCategory = `-- name: deleteCategory :exec
DELETE FROM linkerCategory WHERE idlinkerCategory = ?
`

func (q *Queries) deleteCategory(ctx context.Context, idlinkercategory int32) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, idlinkercategory)
	return err
}

const deleteCommentsSearch = `-- name: deleteCommentsSearch :exec
DELETE FROM commentsSearch
`

// This query deletes all data from the "commentsSearch" table.
func (q *Queries) deleteCommentsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteCommentsSearch)
	return err
}

const deleteLanguage = `-- name: deleteLanguage :exec
DELETE FROM language
WHERE idlanguage = ?
`

// This query deletes a record from the "language" table based on the provided "cid".
// Parameters:
//
//	? - Language ID to be deleted (int)
func (q *Queries) deleteLanguage(ctx context.Context, idlanguage int32) error {
	_, err := q.db.ExecContext(ctx, deleteLanguage, idlanguage)
	return err
}

const deleteLinkerSearch = `-- name: deleteLinkerSearch :exec
DELETE FROM linkerSearch
`

// This query deletes all data from the "linkerSearch" table.
func (q *Queries) deleteLinkerSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteLinkerSearch)
	return err
}

const deletePagePermission = `-- name: deletePagePermission :exec
DELETE FROM permissions WHERE idpermissions = ? AND section = ?
`

type deletePagePermissionParams struct {
	Idpermissions int32
	Section       sql.NullString
}

func (q *Queries) deletePagePermission(ctx context.Context, arg deletePagePermissionParams) error {
	_, err := q.db.ExecContext(ctx, deletePagePermission, arg.Idpermissions, arg.Section)
	return err
}

const deleteQueueItem = `-- name: deleteQueueItem :exec
DELETE FROM linkerQueue WHERE idlinkerQueue = ?
`

func (q *Queries) deleteQueueItem(ctx context.Context, idlinkerqueue int32) error {
	_, err := q.db.ExecContext(ctx, deleteQueueItem, idlinkerqueue)
	return err
}

const deleteSiteNewsSearch = `-- name: deleteSiteNewsSearch :exec
DELETE FROM siteNewsSearch
`

// This query deletes all data from the "siteNewsSearch" table.
func (q *Queries) deleteSiteNewsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteSiteNewsSearch)
	return err
}

const deleteTopicRestrictions = `-- name: deleteTopicRestrictions :exec
DELETE FROM topicrestrictions WHERE forumtopic_idforumtopic = ?
`

func (q *Queries) deleteTopicRestrictions(ctx context.Context, forumtopicIdforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, deleteTopicRestrictions, forumtopicIdforumtopic)
	return err
}

const deleteUserLanguage = `-- name: deleteUserLanguage :exec
DELETE FROM userlang WHERE users_idusers = ?
`

func (q *Queries) deleteUserLanguage(ctx context.Context, usersIdusers int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserLanguage, usersIdusers)
	return err
}

const deleteUsersTopicLevel = `-- name: deleteUsersTopicLevel :exec
DELETE FROM userstopiclevel WHERE forumtopic_idforumtopic = ? AND users_idusers = ?
`

type deleteUsersTopicLevelParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
}

func (q *Queries) deleteUsersTopicLevel(ctx context.Context, arg deleteUsersTopicLevelParams) error {
	_, err := q.db.ExecContext(ctx, deleteUsersTopicLevel, arg.ForumtopicIdforumtopic, arg.UsersIdusers)
	return err
}

const deleteWritingApproval = `-- name: deleteWritingApproval :exec
DELETE FROM writtingApprovedUsers
WHERE writing_idwriting = ? AND users_idusers = ?
`

type deleteWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) deleteWritingApproval(ctx context.Context, arg deleteWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, deleteWritingApproval, arg.WritingIdwriting, arg.UsersIdusers)
	return err
}

const deleteWritingSearch = `-- name: deleteWritingSearch :exec
DELETE FROM writingSearch
`

// This query deletes all data from the "writingSearch" table.
func (q *Queries) deleteWritingSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteWritingSearch)
	return err
}

const delete_blog = `-- name: delete_blog :exec
DELETE FROM blogs
WHERE idblogs = ?
`

func (q *Queries) delete_blog(ctx context.Context, idblogs int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog, idblogs)
	return err
}

const delete_blog_comments = `-- name: delete_blog_comments :exec
DELETE FROM comments
WHERE forumthread_idforumthread = ?
`

func (q *Queries) delete_blog_comments(ctx context.Context, forumthreadIdforumthread int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog_comments, forumthreadIdforumthread)
	return err
}

const delete_blog_search = `-- name: delete_blog_search :exec
DELETE FROM blogsSearch
WHERE blogs_idblogs = ?
`

func (q *Queries) delete_blog_search(ctx context.Context, blogsIdblogs int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog_search, blogsIdblogs)
	return err
}

const delete_bookmarks = `-- name: delete_bookmarks :exec
DELETE FROM bookmarks
WHERE users_idusers = ?
`

// This query deletes all entries from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) delete_bookmarks(ctx context.Context, usersIdusers int32) error {
	_, err := q.db.ExecContext(ctx, delete_bookmarks, usersIdusers)
	return err
}

const delete_category = `-- name: delete_category :exec
DELETE FROM faqCategories
WHERE idfaqCategories = ?
`

func (q *Queries) delete_category(ctx context.Context, idfaqcategories int32) error {
	_, err := q.db.ExecContext(ctx, delete_category, idfaqcategories)
	return err
}

const doCalled = `-- name: doCalled :many
SELECT s.news, s.idsiteNews, u.idusers, s.language_idlanguage
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
WHERE s.idsiteNews = ?
`

type doCalledRow struct {
	News               sql.NullString
	Idsitenews         int32
	Idusers            sql.NullInt32
	LanguageIdlanguage int32
}

func (q *Queries) doCalled(ctx context.Context, idsitenews int32) ([]*doCalledRow, error) {
	rows, err := q.db.QueryContext(ctx, doCalled, idsitenews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*doCalledRow
	for rows.Next() {
		var i doCalledRow
		if err := rows.Scan(
			&i.News,
			&i.Idsitenews,
			&i.Idusers,
			&i.LanguageIdlanguage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const editNewsPost = `-- name: editNewsPost :exec
UPDATE siteNews SET news = ?, language_idlanguage = ? WHERE idsiteNews = ?
`

type editNewsPostParams struct {
	News               sql.NullString
	LanguageIdlanguage int32
	Idsitenews         int32
}

func (q *Queries) editNewsPost(ctx context.Context, arg editNewsPostParams) error {
	_, err := q.db.ExecContext(ctx, editNewsPost, arg.News, arg.LanguageIdlanguage, arg.Idsitenews)
	return err
}

const existsTopicRestrictions = `-- name: existsTopicRestrictions :one
SELECT (forumtopic_idforumtopic) FROM topicrestrictions WHERE forumtopic_idforumtopic = ?
`

func (q *Queries) existsTopicRestrictions(ctx context.Context, forumtopicIdforumtopic int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, existsTopicRestrictions, forumtopicIdforumtopic)
	var forumtopic_idforumtopic int32
	err := row.Scan(&forumtopic_idforumtopic)
	return forumtopic_idforumtopic, err
}

const expandCategories = `-- name: expandCategories :many
SELECT f.idforumcategory, f.title, f.description
FROM forumcategory f WHERE f.forumcategory_idforumcategory = ?
`

type expandCategoriesRow struct {
	Idforumcategory int32
	Title           sql.NullString
	Description     sql.NullString
}

func (q *Queries) expandCategories(ctx context.Context, forumcategoryIdforumcategory int32) ([]*expandCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, expandCategories, forumcategoryIdforumcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*expandCategoriesRow
	for rows.Next() {
		var i expandCategoriesRow
		if err := rows.Scan(&i.Idforumcategory, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchCategories = `-- name: fetchCategories :many
SELECT idwritingCategory, title, description
FROM writingCategory
WHERE writingCategory_idwritingCategory = ?
`

type fetchCategoriesRow struct {
	Idwritingcategory int32
	Title             sql.NullString
	Description       sql.NullString
}

func (q *Queries) fetchCategories(ctx context.Context, writingcategoryIdwritingcategory int32) ([]*fetchCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchCategories, writingcategoryIdwritingcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchCategoriesRow
	for rows.Next() {
		var i fetchCategoriesRow
		if err := rows.Scan(&i.Idwritingcategory, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChildCategories = `-- name: fetchChildCategories :many
SELECT c3.idwritingCategory, c3.title, c2.idwritingCategory, c2.title
FROM writingCategory c1
LEFT JOIN writingCategory c2 ON c2.idwritingCategory = c1.writingCategory_idwritingCategory
LEFT JOIN writingCategory c3 ON c3.idwritingCategory = c2.writingCategory_idwritingCategory
WHERE c1.idwritingCategory = ?
`

type fetchChildCategoriesRow struct {
	Idwritingcategory   sql.NullInt32
	Title               sql.NullString
	Idwritingcategory_2 sql.NullInt32
	Title_2             sql.NullString
}

func (q *Queries) fetchChildCategories(ctx context.Context, idwritingcategory int32) ([]*fetchChildCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchChildCategories, idwritingcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchChildCategoriesRow
	for rows.Next() {
		var i fetchChildCategoriesRow
		if err := rows.Scan(
			&i.Idwritingcategory,
			&i.Title,
			&i.Idwritingcategory_2,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLanguages = `-- name: fetchLanguages :many
SELECT idlanguage, nameof FROM language
`

func (q *Queries) fetchLanguages(ctx context.Context) ([]*Language, error) {
	rows, err := q.db.QueryContext(ctx, fetchLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(&i.Idlanguage, &i.Nameof); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPagePermissions = `-- name: fetchPagePermissions :many
SELECT p.idpermissions, p.level, u.username, u.email, p.section
FROM permissions p
JOIN users u ON u.idusers = p.users_idusers
WHERE p.section = ?
ORDER BY p.level
`

type fetchPagePermissionsRow struct {
	Idpermissions int32
	Level         sql.NullString
	Username      sql.NullString
	Email         sql.NullString
	Section       sql.NullString
}

func (q *Queries) fetchPagePermissions(ctx context.Context, section sql.NullString) ([]*fetchPagePermissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPagePermissions, section)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchPagePermissionsRow
	for rows.Next() {
		var i fetchPagePermissionsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.Level,
			&i.Username,
			&i.Email,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPublicWritings = `-- name: fetchPublicWritings :many
SELECT w.title, w.abstract, w.idwriting, w.private, w.writingCategory_idwritingCategory
FROM writing w
WHERE w.private = 0
ORDER BY w.published DESC LIMIT 15
`

type fetchPublicWritingsRow struct {
	Title                            sql.NullString
	Abstract                         sql.NullString
	Idwriting                        int32
	Private                          sql.NullBool
	WritingcategoryIdwritingcategory int32
}

func (q *Queries) fetchPublicWritings(ctx context.Context) ([]*fetchPublicWritingsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPublicWritings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchPublicWritingsRow
	for rows.Next() {
		var i fetchPublicWritingsRow
		if err := rows.Scan(
			&i.Title,
			&i.Abstract,
			&i.Idwriting,
			&i.Private,
			&i.WritingcategoryIdwritingcategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPublicWritingsByCategory = `-- name: fetchPublicWritingsByCategory :many
SELECT w.title, w.abstract, u.username, w.published, w.idwriting, w.private, IF(th.comments IS NULL, 0, th.comments + 1)
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN forumthread th ON w.forumthread_idforumthread = th.idforumthread
LEFT JOIN writtingApprovedUsers wau ON w.idwriting = wau.writing_idwriting AND wau.users_idusers = ?
WHERE w.writingCategory_idwritingCategory = ? AND (w.private = 0 OR wau.readdoc = 1 OR w.users_idusers = ?)
ORDER BY w.published DESC
`

type fetchPublicWritingsByCategoryParams struct {
	UsersIdusers                     int32
	WritingcategoryIdwritingcategory int32
	UsersIdusers_2                   int32
}

type fetchPublicWritingsByCategoryRow struct {
	Title     sql.NullString
	Abstract  sql.NullString
	Username  sql.NullString
	Published sql.NullTime
	Idwriting int32
	Private   sql.NullBool
	If        interface{}
}

func (q *Queries) fetchPublicWritingsByCategory(ctx context.Context, arg fetchPublicWritingsByCategoryParams) ([]*fetchPublicWritingsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPublicWritingsByCategory, arg.UsersIdusers, arg.WritingcategoryIdwritingcategory, arg.UsersIdusers_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchPublicWritingsByCategoryRow
	for rows.Next() {
		var i fetchPublicWritingsByCategoryRow
		if err := rows.Scan(
			&i.Title,
			&i.Abstract,
			&i.Username,
			&i.Published,
			&i.Idwriting,
			&i.Private,
			&i.If,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserEmailForumUpdates = `-- name: fetchUserEmailForumUpdates :many

SELECT emailforumupdates FROM preferences WHERE users_idusers = ?
`

// -- name: updateOrInsertEmailForumUpdates :exec
// WITH email_updates AS (
//
//	SELECT emailforumupdates FROM preferences WHERE users_idusers = ?
//
// )
// INSERT INTO preferences (emailforumupdates, users_idusers)
// VALUES (?, ?)
// ON DUPLICATE KEY UPDATE
//
//	emailforumupdates = VALUES(emailforumupdates);
func (q *Queries) fetchUserEmailForumUpdates(ctx context.Context, usersIdusers int32) ([]sql.NullBool, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserEmailForumUpdates, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullBool
	for rows.Next() {
		var emailforumupdates sql.NullBool
		if err := rows.Scan(&emailforumupdates); err != nil {
			return nil, err
		}
		items = append(items, emailforumupdates)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserLanguagePreferences = `-- name: fetchUserLanguagePreferences :many

SELECT idlanguage, nameof, (
  SELECT COUNT(sul.iduserlang) FROM userlang sul
  WHERE sul.language_idlanguage = l.idlanguage AND sul.users_idusers = ?
) AS user_lang_pref
FROM language l
`

type fetchUserLanguagePreferencesRow struct {
	Idlanguage   int32
	Nameof       sql.NullString
	UserLangPref int64
}

// -- name: updateOrInsertUserLanguage :exec
// WITH pref_count AS (
//
//	SELECT COUNT(users_idusers) AS prefcount FROM preferences WHERE users_idusers = ?
//
// )
// INSERT INTO preferences (language_idlanguage, users_idusers)
// VALUES (?, ?)
// ON DUPLICATE KEY UPDATE
//
//	language_idlanguage = VALUES(language_idlanguage);
func (q *Queries) fetchUserLanguagePreferences(ctx context.Context, usersIdusers int32) ([]*fetchUserLanguagePreferencesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserLanguagePreferences, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchUserLanguagePreferencesRow
	for rows.Next() {
		var i fetchUserLanguagePreferencesRow
		if err := rows.Scan(&i.Idlanguage, &i.Nameof, &i.UserLangPref); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingApproval = `-- name: fetchWritingApproval :many
SELECT editdoc
FROM writtingApprovedUsers
WHERE writing_idwriting = ? AND users_idusers = ?
`

type fetchWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) fetchWritingApproval(ctx context.Context, arg fetchWritingApprovalParams) ([]sql.NullBool, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingApproval, arg.WritingIdwriting, arg.UsersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullBool
	for rows.Next() {
		var editdoc sql.NullBool
		if err := rows.Scan(&editdoc); err != nil {
			return nil, err
		}
		items = append(items, editdoc)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingApprovals = `-- name: fetchWritingApprovals :many
SELECT idusers, u.username, wau.readdoc, wau.editdoc
FROM writtingApprovedUsers wau
LEFT JOIN users u ON idusers = wau.users_idusers
WHERE writing_idwriting = ?
`

type fetchWritingApprovalsRow struct {
	Idusers  int32
	Username sql.NullString
	Readdoc  sql.NullBool
	Editdoc  sql.NullBool
}

func (q *Queries) fetchWritingApprovals(ctx context.Context, writingIdwriting int32) ([]*fetchWritingApprovalsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingApprovals, writingIdwriting)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchWritingApprovalsRow
	for rows.Next() {
		var i fetchWritingApprovalsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Username,
			&i.Readdoc,
			&i.Editdoc,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingById = `-- name: fetchWritingById :many
SELECT w.title, w.abstract, w.writting, u.username, w.published, w.idwriting, w.private, wau.editdoc, w.forumthread_idforumthread,
u.idusers, w.writingCategory_idwritingCategory
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN writtingApprovedUsers wau ON w.idwriting = wau.writing_idwriting AND wau.users_idusers = ?
WHERE w.idwriting = ? AND (w.private = 0 OR wau.readdoc = 1 OR w.users_idusers = ?)
ORDER BY w.published DESC
`

type fetchWritingByIdParams struct {
	UsersIdusers   int32
	Idwriting      int32
	UsersIdusers_2 int32
}

type fetchWritingByIdRow struct {
	Title                            sql.NullString
	Abstract                         sql.NullString
	Writting                         sql.NullString
	Username                         sql.NullString
	Published                        sql.NullTime
	Idwriting                        int32
	Private                          sql.NullBool
	Editdoc                          sql.NullBool
	ForumthreadIdforumthread         int32
	Idusers                          int32
	WritingcategoryIdwritingcategory int32
}

func (q *Queries) fetchWritingById(ctx context.Context, arg fetchWritingByIdParams) ([]*fetchWritingByIdRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingById, arg.UsersIdusers, arg.Idwriting, arg.UsersIdusers_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchWritingByIdRow
	for rows.Next() {
		var i fetchWritingByIdRow
		if err := rows.Scan(
			&i.Title,
			&i.Abstract,
			&i.Writting,
			&i.Username,
			&i.Published,
			&i.Idwriting,
			&i.Private,
			&i.Editdoc,
			&i.ForumthreadIdforumthread,
			&i.Idusers,
			&i.WritingcategoryIdwritingcategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingByIdWithEdit = `-- name: fetchWritingByIdWithEdit :many
SELECT w.title, w.abstract, w.writting, u.username, w.published, w.idwriting, w.private, wau.editdoc, w.forumthread_idforumthread,
u.idusers, w.writingCategory_idwritingCategory
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN writtingApprovedUsers wau ON w.idwriting = wau.writing_idwriting AND wau.users_idusers = ?
WHERE w.idwriting = ? AND w.users_idusers = ? AND (w.private = 0 OR wau.readdoc = 1 OR w.users_idusers = ?)
AND (wau.editdoc = 1 OR w.users_idusers = ?)
ORDER BY w.published DESC
`

type fetchWritingByIdWithEditParams struct {
	UsersIdusers   int32
	Idwriting      int32
	UsersIdusers_2 int32
	UsersIdusers_3 int32
	UsersIdusers_4 int32
}

type fetchWritingByIdWithEditRow struct {
	Title                            sql.NullString
	Abstract                         sql.NullString
	Writting                         sql.NullString
	Username                         sql.NullString
	Published                        sql.NullTime
	Idwriting                        int32
	Private                          sql.NullBool
	Editdoc                          sql.NullBool
	ForumthreadIdforumthread         int32
	Idusers                          int32
	WritingcategoryIdwritingcategory int32
}

func (q *Queries) fetchWritingByIdWithEdit(ctx context.Context, arg fetchWritingByIdWithEditParams) ([]*fetchWritingByIdWithEditRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingByIdWithEdit,
		arg.UsersIdusers,
		arg.Idwriting,
		arg.UsersIdusers_2,
		arg.UsersIdusers_3,
		arg.UsersIdusers_4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*fetchWritingByIdWithEditRow
	for rows.Next() {
		var i fetchWritingByIdWithEditRow
		if err := rows.Scan(
			&i.Title,
			&i.Abstract,
			&i.Writting,
			&i.Username,
			&i.Published,
			&i.Idwriting,
			&i.Private,
			&i.Editdoc,
			&i.ForumthreadIdforumthread,
			&i.Idusers,
			&i.WritingcategoryIdwritingcategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingOwner = `-- name: fetchWritingOwner :many
SELECT users_idusers
FROM writing
WHERE idwriting = ?
`

func (q *Queries) fetchWritingOwner(ctx context.Context, idwriting int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingOwner, idwriting)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var users_idusers int32
		if err := rows.Scan(&users_idusers); err != nil {
			return nil, err
		}
		items = append(items, users_idusers)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findForumTopicByName = `-- name: findForumTopicByName :one
SELECT idforumtopic FROM forumtopic WHERE title=?
`

func (q *Queries) findForumTopicByName(ctx context.Context, title sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, findForumTopicByName, title)
	var idforumtopic int32
	err := row.Scan(&idforumtopic)
	return idforumtopic, err
}

const getLangs = `-- name: getLangs :one
SELECT language_idlanguage FROM userlang WHERE users_idusers = ?
`

func (q *Queries) getLangs(ctx context.Context, usersIdusers int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getLangs, usersIdusers)
	var language_idlanguage int32
	err := row.Scan(&language_idlanguage)
	return language_idlanguage, err
}

const getNewsThreadId = `-- name: getNewsThreadId :one
SELECT s.forumthread_idforumthread FROM siteNews s, users u
WHERE s.users_idusers = u.idusers AND s.idsiteNews = ?
`

func (q *Queries) getNewsThreadId(ctx context.Context, idsitenews int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNewsThreadId, idsitenews)
	var forumthread_idforumthread int32
	err := row.Scan(&forumthread_idforumthread)
	return forumthread_idforumthread, err
}

const getSecurityLevel = `-- name: getSecurityLevel :one
SELECT level FROM permissions WHERE users_idusers = ? AND (section = ? OR section = 'all')
`

type getSecurityLevelParams struct {
	UsersIdusers int32
	Section      sql.NullString
}

func (q *Queries) getSecurityLevel(ctx context.Context, arg getSecurityLevelParams) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getSecurityLevel, arg.UsersIdusers, arg.Section)
	var level sql.NullString
	err := row.Scan(&level)
	return level, err
}

const getUsersTopicLevel = `-- name: getUsersTopicLevel :one
SELECT level FROM userstopiclevel WHERE forumtopic_idforumtopic = ? AND users_idusers = ?
`

type getUsersTopicLevelParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
}

func (q *Queries) getUsersTopicLevel(ctx context.Context, arg getUsersTopicLevelParams) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getUsersTopicLevel, arg.ForumtopicIdforumtopic, arg.UsersIdusers)
	var level sql.NullInt32
	err := row.Scan(&level)
	return level, err
}

const getUsersTopicLevelInviteMax = `-- name: getUsersTopicLevelInviteMax :one
SELECT invitemax FROM userstopiclevel WHERE forumtopic_idforumtopic = ? AND users_idusers = ?
`

type getUsersTopicLevelInviteMaxParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
}

func (q *Queries) getUsersTopicLevelInviteMax(ctx context.Context, arg getUsersTopicLevelInviteMaxParams) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getUsersTopicLevelInviteMax, arg.ForumtopicIdforumtopic, arg.UsersIdusers)
	var invitemax sql.NullInt32
	err := row.Scan(&invitemax)
	return invitemax, err
}

const getWordID = `-- name: getWordID :one
SELECT idsearchwordlist FROM searchwordlist WHERE word = lcase(?)
`

func (q *Queries) getWordID(ctx context.Context, lcase string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getWordID, lcase)
	var idsearchwordlist int32
	err := row.Scan(&idsearchwordlist)
	return idsearchwordlist, err
}

const insertPagePermission = `-- name: insertPagePermission :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES (?, ?, ?)
`

type insertPagePermissionParams struct {
	UsersIdusers int32
	Section      sql.NullString
	Level        sql.NullString
}

func (q *Queries) insertPagePermission(ctx context.Context, arg insertPagePermissionParams) error {
	_, err := q.db.ExecContext(ctx, insertPagePermission, arg.UsersIdusers, arg.Section, arg.Level)
	return err
}

const insertWriting = `-- name: insertWriting :exec
INSERT INTO writing (writingCategory_idwritingCategory, title, abstract, writting, private, language_idlanguage, published, users_idusers)
VALUES (?, ?, ?, ?, ?, ?, NOW(), ?)
`

type insertWritingParams struct {
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Abstract                         sql.NullString
	Writting                         sql.NullString
	Private                          sql.NullBool
	LanguageIdlanguage               int32
	UsersIdusers                     int32
}

func (q *Queries) insertWriting(ctx context.Context, arg insertWritingParams) error {
	_, err := q.db.ExecContext(ctx, insertWriting,
		arg.WritingcategoryIdwritingcategory,
		arg.Title,
		arg.Abstract,
		arg.Writting,
		arg.Private,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
	)
	return err
}

const insertWritingApproval = `-- name: insertWritingApproval :exec
INSERT INTO writtingApprovedUsers (writing_idwriting, users_idusers, readdoc, editdoc)
VALUES (?, ?, ?, ?)
`

type insertWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
	Readdoc          sql.NullBool
	Editdoc          sql.NullBool
}

func (q *Queries) insertWritingApproval(ctx context.Context, arg insertWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, insertWritingApproval,
		arg.WritingIdwriting,
		arg.UsersIdusers,
		arg.Readdoc,
		arg.Editdoc,
	)
	return err
}

const insertWritingCategory = `-- name: insertWritingCategory :exec
INSERT INTO writingCategory (writingCategory_idwritingCategory, title, description)
VALUES (?, ?, ?)
`

type insertWritingCategoryParams struct {
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Description                      sql.NullString
}

func (q *Queries) insertWritingCategory(ctx context.Context, arg insertWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, insertWritingCategory, arg.WritingcategoryIdwritingcategory, arg.Title, arg.Description)
	return err
}

const lang_combobox = `-- name: lang_combobox :many
SELECT l.idlanguage, l.nameof FROM language l
`

func (q *Queries) lang_combobox(ctx context.Context) ([]*Language, error) {
	rows, err := q.db.QueryContext(ctx, lang_combobox)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(&i.Idlanguage, &i.Nameof); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeCategory = `-- name: makeCategory :exec
INSERT INTO forumcategory (forumcategory_idforumcategory, title, description) VALUES (?, ?, ?)
`

type makeCategoryParams struct {
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) makeCategory(ctx context.Context, arg makeCategoryParams) error {
	_, err := q.db.ExecContext(ctx, makeCategory, arg.ForumcategoryIdforumcategory, arg.Title, arg.Description)
	return err
}

const makeImageBoard = `-- name: makeImageBoard :exec
INSERT INTO imageboard (imageboard_idimageboard, title, description) VALUES (?, ?, ?)
`

type makeImageBoardParams struct {
	ImageboardIdimageboard int32
	Title                  sql.NullString
	Description            sql.NullString
}

func (q *Queries) makeImageBoard(ctx context.Context, arg makeImageBoardParams) error {
	_, err := q.db.ExecContext(ctx, makeImageBoard, arg.ImageboardIdimageboard, arg.Title, arg.Description)
	return err
}

const makePost = `-- name: makePost :exec
INSERT INTO comments (language_idlanguage, users_idusers, forumthread_idforumthread, text, written)
VALUES (?, ?, ?, ?, NOW())
`

type makePostParams struct {
	LanguageIdlanguage       int32
	UsersIdusers             int32
	ForumthreadIdforumthread int32
	Text                     sql.NullString
}

func (q *Queries) makePost(ctx context.Context, arg makePostParams) error {
	_, err := q.db.ExecContext(ctx, makePost,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
		arg.ForumthreadIdforumthread,
		arg.Text,
	)
	return err
}

const makeThread = `-- name: makeThread :exec
INSERT INTO forumthread (forumtopic_idforumtopic) VALUES (?)
`

func (q *Queries) makeThread(ctx context.Context, forumtopicIdforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, makeThread, forumtopicIdforumtopic)
	return err
}

const makeTopic = `-- name: makeTopic :exec
INSERT INTO forumtopic (forumcategory_idforumcategory, title, description) VALUES (?, ?, ?)
`

type makeTopicParams struct {
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) makeTopic(ctx context.Context, arg makeTopicParams) error {
	_, err := q.db.ExecContext(ctx, makeTopic, arg.ForumcategoryIdforumcategory, arg.Title, arg.Description)
	return err
}

const modify_faq = `-- name: modify_faq :exec
UPDATE faq
SET answer = ?, question = ?, faqCategories_idfaqCategories = ?
WHERE idfaq = ?
`

type modify_faqParams struct {
	Answer                       sql.NullString
	Question                     sql.NullString
	FaqcategoriesIdfaqcategories int32
	Idfaq                        int32
}

func (q *Queries) modify_faq(ctx context.Context, arg modify_faqParams) error {
	_, err := q.db.ExecContext(ctx, modify_faq,
		arg.Answer,
		arg.Question,
		arg.FaqcategoriesIdfaqcategories,
		arg.Idfaq,
	)
	return err
}

const moveToLinker = `-- name: moveToLinker :many
SELECT l.users_idusers, l.linkerCategory_idlinkerCategory, l.language_idlanguage, l.title, l.url, l.description
FROM linkerQueue l WHERE l.idlinkerQueue = ?
`

type moveToLinkerRow struct {
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	LanguageIdlanguage             int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
}

func (q *Queries) moveToLinker(ctx context.Context, idlinkerqueue int32) ([]*moveToLinkerRow, error) {
	rows, err := q.db.QueryContext(ctx, moveToLinker, idlinkerqueue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*moveToLinkerRow
	for rows.Next() {
		var i moveToLinkerRow
		if err := rows.Scan(
			&i.UsersIdusers,
			&i.LinkercategoryIdlinkercategory,
			&i.LanguageIdlanguage,
			&i.Title,
			&i.Url,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notifyChange = `-- name: notifyChange :many

SELECT email FROM users WHERE idusers = ?
`

// -- name: addToGeneralSearch :exec
// INSERT INTO ? (?, searchwordlist_idsearchwordlist) VALUES (?, ?)
func (q *Queries) notifyChange(ctx context.Context, idusers int32) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, notifyChange, idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postUpdate = `-- name: postUpdate :exec
UPDATE comments c, forumthread th, forumtopic t
SET
th.lastposter=c.users_idusers, t.lastposter=c.users_idusers,
th.lastaddition=c.written, t.lastaddition=c.written,
t.comments=IF(th.comments IS NULL, 0, t.comments+1),
t.threads=IF(th.comments IS NULL, IF(t.threads IS NULL, 1, t.threads+1), t.threads),
th.comments=IF(th.comments IS NULL, 0, th.comments+1),
th.firstpost=IF(th.firstpost=0, c.idcomments, th.firstpost)
WHERE c.idcomments=?
`

func (q *Queries) postUpdate(ctx context.Context, idcomments int32) error {
	_, err := q.db.ExecContext(ctx, postUpdate, idcomments)
	return err
}

const preferencesRefreshPref = `-- name: preferencesRefreshPref :many
SELECT language_idlanguage FROM preferences WHERE users_idusers = ?
`

func (q *Queries) preferencesRefreshPref(ctx context.Context, usersIdusers int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, preferencesRefreshPref, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var language_idlanguage int32
		if err := rows.Scan(&language_idlanguage); err != nil {
			return nil, err
		}
		items = append(items, language_idlanguage)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printBoardPosts = `-- name: printBoardPosts :many
SELECT i.description, i.thumbnail, i.fullimage, u.username, i.posted, i.idimagepost, IF(th.comments IS NULL, 0, th.comments + 1)
FROM imagepost i
LEFT JOIN users u ON i.users_idusers = u.idusers
LEFT JOIN forumthread th ON i.forumthread_idforumthread = th.idforumthread
WHERE i.imageboard_idimageboard = ?
ORDER BY i.posted DESC
`

type printBoardPostsRow struct {
	Description sql.NullString
	Thumbnail   sql.NullString
	Fullimage   sql.NullString
	Username    sql.NullString
	Posted      sql.NullTime
	Idimagepost int32
	If          interface{}
}

func (q *Queries) printBoardPosts(ctx context.Context, imageboardIdimageboard int32) ([]*printBoardPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, printBoardPosts, imageboardIdimageboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printBoardPostsRow
	for rows.Next() {
		var i printBoardPostsRow
		if err := rows.Scan(
			&i.Description,
			&i.Thumbnail,
			&i.Fullimage,
			&i.Username,
			&i.Posted,
			&i.Idimagepost,
			&i.If,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printCategoryRoots = `-- name: printCategoryRoots :many
SELECT c3.idforumcategory, c3.title, c2.idforumcategory, c2.title, c1.title
FROM forumcategory c1
LEFT JOIN forumcategory c2 ON c2.idforumcategory = c1.forumcategory_idforumcategory
LEFT JOIN forumcategory c3 ON c3.idforumcategory = c2.forumcategory_idforumcategory
WHERE c1.idforumcategory = ?
`

type printCategoryRootsRow struct {
	Idforumcategory   sql.NullInt32
	Title             sql.NullString
	Idforumcategory_2 sql.NullInt32
	Title_2           sql.NullString
	Title_3           sql.NullString
}

func (q *Queries) printCategoryRoots(ctx context.Context, idforumcategory int32) ([]*printCategoryRootsRow, error) {
	rows, err := q.db.QueryContext(ctx, printCategoryRoots, idforumcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printCategoryRootsRow
	for rows.Next() {
		var i printCategoryRootsRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.Title,
			&i.Idforumcategory_2,
			&i.Title_2,
			&i.Title_3,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printImagePost = `-- name: printImagePost :many
SELECT i.description, i.thumbnail, i.fullimage, u.username, i.posted, i.forumthread_idforumthread, i.idimagepost
FROM imagepost i
LEFT JOIN users u ON i.users_idusers = u.idusers
WHERE i.idimagepost = ?
`

type printImagePostRow struct {
	Description              sql.NullString
	Thumbnail                sql.NullString
	Fullimage                sql.NullString
	Username                 sql.NullString
	Posted                   sql.NullTime
	ForumthreadIdforumthread int32
	Idimagepost              int32
}

func (q *Queries) printImagePost(ctx context.Context, idimagepost int32) ([]*printImagePostRow, error) {
	rows, err := q.db.QueryContext(ctx, printImagePost, idimagepost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printImagePostRow
	for rows.Next() {
		var i printImagePostRow
		if err := rows.Scan(
			&i.Description,
			&i.Thumbnail,
			&i.Fullimage,
			&i.Username,
			&i.Posted,
			&i.ForumthreadIdforumthread,
			&i.Idimagepost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printSubBoards = `-- name: printSubBoards :many
SELECT idimageboard, title, description FROM imageboard WHERE imageboard_idimageboard = ?
`

type printSubBoardsRow struct {
	Idimageboard int32
	Title        sql.NullString
	Description  sql.NullString
}

func (q *Queries) printSubBoards(ctx context.Context, imageboardIdimageboard int32) ([]*printSubBoardsRow, error) {
	rows, err := q.db.QueryContext(ctx, printSubBoards, imageboardIdimageboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printSubBoardsRow
	for rows.Next() {
		var i printSubBoardsRow
		if err := rows.Scan(&i.Idimageboard, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printThread = `-- name: printThread :many
SELECT c.idcomments, c.text, c.written, u.username, u.idusers FROM comments c, users u
WHERE c.users_idusers=u.idusers AND c.forumthread_idforumthread=?
ORDER BY c.written
`

type printThreadRow struct {
	Idcomments int32
	Text       sql.NullString
	Written    sql.NullTime
	Username   sql.NullString
	Idusers    int32
}

func (q *Queries) printThread(ctx context.Context, forumthreadIdforumthread int32) ([]*printThreadRow, error) {
	rows, err := q.db.QueryContext(ctx, printThread, forumthreadIdforumthread)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printThreadRow
	for rows.Next() {
		var i printThreadRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.Text,
			&i.Written,
			&i.Username,
			&i.Idusers,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printTopic = `-- name: printTopic :many
SELECT LEFT(c.text, 255), fu.username, c.written, lu.username, t.lastaddition, t.idforumthread, t.comments, r.viewlevel, u.level
FROM forumthread t
LEFT JOIN topicrestrictions r ON t.forumtopic_idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.forumtopic_idforumtopic AND u.users_idusers = ?
LEFT JOIN comments c ON c.idcomments = t.firstpost
LEFT JOIN users fu ON fu.idusers = c.users_idusers
LEFT JOIN users lu ON lu.idusers = t.lastposter
ORDER BY t.lastaddition DESC
`

type printTopicRow struct {
	Left          string
	Username      sql.NullString
	Written       sql.NullTime
	Username_2    sql.NullString
	Lastaddition  sql.NullTime
	Idforumthread int32
	Comments      sql.NullInt32
	Viewlevel     sql.NullInt32
	Level         sql.NullInt32
}

// WHERE t.forumtopic_idforumcategory = ?
func (q *Queries) printTopic(ctx context.Context, usersIdusers int32) ([]*printTopicRow, error) {
	rows, err := q.db.QueryContext(ctx, printTopic, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printTopicRow
	for rows.Next() {
		var i printTopicRow
		if err := rows.Scan(
			&i.Left,
			&i.Username,
			&i.Written,
			&i.Username_2,
			&i.Lastaddition,
			&i.Idforumthread,
			&i.Comments,
			&i.Viewlevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printTopicRestrictions = `-- name: printTopicRestrictions :many
SELECT idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, t.title, r.forumtopic_idforumtopic, r.modlevel, r.adminlevel
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
WHERE idforumtopic = ?
`

type printTopicRestrictionsRow struct {
	Idforumtopic           int32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Title                  sql.NullString
	ForumtopicIdforumtopic sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) printTopicRestrictions(ctx context.Context, idforumtopic int32) ([]*printTopicRestrictionsRow, error) {
	rows, err := q.db.QueryContext(ctx, printTopicRestrictions, idforumtopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printTopicRestrictionsRow
	for rows.Next() {
		var i printTopicRestrictionsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Title,
			&i.ForumtopicIdforumtopic,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printTopicRoots = `-- name: printTopicRoots :many
SELECT c3.idforumcategory, c3.title, c2.idforumcategory, c2.title, c1.idforumcategory, c1.title, t.title
FROM forumtopic t
LEFT JOIN forumcategory c1 ON c1.idforumcategory = t.forumcategory_idforumcategory
LEFT JOIN forumcategory c2 ON c2.idforumcategory = c1.forumcategory_idforumcategory
LEFT JOIN forumcategory c3 ON c3.idforumcategory = c2.forumcategory_idforumcategory
WHERE t.idforumtopic = ?
`

type printTopicRootsRow struct {
	Idforumcategory   sql.NullInt32
	Title             sql.NullString
	Idforumcategory_2 sql.NullInt32
	Title_2           sql.NullString
	Idforumcategory_3 sql.NullInt32
	Title_3           sql.NullString
	Title_4           sql.NullString
}

func (q *Queries) printTopicRoots(ctx context.Context, idforumtopic int32) ([]*printTopicRootsRow, error) {
	rows, err := q.db.QueryContext(ctx, printTopicRoots, idforumtopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printTopicRootsRow
	for rows.Next() {
		var i printTopicRootsRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.Title,
			&i.Idforumcategory_2,
			&i.Title_2,
			&i.Idforumcategory_3,
			&i.Title_3,
			&i.Title_4,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reassign_category = `-- name: reassign_category :exec
UPDATE faq
SET faqCategories_idfaqCategories = ?
WHERE idfaq = ?
`

type reassign_categoryParams struct {
	FaqcategoriesIdfaqcategories int32
	Idfaq                        int32
}

func (q *Queries) reassign_category(ctx context.Context, arg reassign_categoryParams) error {
	_, err := q.db.ExecContext(ctx, reassign_category, arg.FaqcategoriesIdfaqcategories, arg.Idfaq)
	return err
}

const remakeBlogSearch = `-- name: remakeBlogSearch :exec
INSERT INTO blogsSearch (text, blogs_idblogs)
SELECT blog, idblogs
FROM blogs
`

// This query selects data from the "blogs" table and populates the "blogsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "blogsSearch" using the "blogs_idblogs".
func (q *Queries) remakeBlogSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeBlogSearch)
	return err
}

const remakeBlogsSearchInsert = `-- name: remakeBlogsSearchInsert :exec
INSERT INTO blogsSearch (text, blogs_idblogs)
SELECT blog, idblogs
FROM blogs
`

// This query selects data from the "blogs" table and populates the "blogsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "blogsSearch" using the "blogs_idblogs".
func (q *Queries) remakeBlogsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeBlogsSearchInsert)
	return err
}

const remakeCommentsSearch = `-- name: remakeCommentsSearch :exec
INSERT INTO commentsSearch (text, comments_idcomments)
SELECT text, idcomments
FROM comments
`

// This query selects data from the "comments" table and populates the "commentsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "commentsSearch" using the "comments_idcomments".
func (q *Queries) remakeCommentsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeCommentsSearch)
	return err
}

const remakeCommentsSearchInsert = `-- name: remakeCommentsSearchInsert :exec
INSERT INTO commentsSearch (text, comments_idcomments)
SELECT text, idcomments
FROM comments
`

// This query selects data from the "comments" table and populates the "commentsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "commentsSearch" using the "comments_idcomments".
func (q *Queries) remakeCommentsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeCommentsSearchInsert)
	return err
}

const remakeLinkerSearch = `-- name: remakeLinkerSearch :exec
INSERT INTO linkerSearch (text, linker_idlinker)
SELECT CONCAT(title, ' ', description), idlinker
FROM linker
`

// This query selects data from the "linker" table and populates the "linkerSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "linkerSearch" using the "linker_idlinker".
func (q *Queries) remakeLinkerSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeLinkerSearch)
	return err
}

const remakeLinkerSearchInsert = `-- name: remakeLinkerSearchInsert :exec
INSERT INTO linkerSearch (text, linker_idlinker)
SELECT CONCAT(title, ' ', description), idlinker
FROM linker
`

// This query selects data from the "linker" table and populates the "linkerSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "linkerSearch" using the "linker_idlinker".
func (q *Queries) remakeLinkerSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeLinkerSearchInsert)
	return err
}

const remakeNewsSearch = `-- name: remakeNewsSearch :exec
INSERT INTO siteNewsSearch (text, siteNews_idsiteNews)
SELECT news, idsiteNews
FROM siteNews
`

// This query selects data from the "siteNews" table and populates the "siteNewsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "siteNewsSearch" using the "siteNews_idsiteNews".
func (q *Queries) remakeNewsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeNewsSearch)
	return err
}

const remakeNewsSearchInsert = `-- name: remakeNewsSearchInsert :exec
INSERT INTO siteNewsSearch (text, siteNews_idsiteNews)
SELECT news, idsiteNews
FROM siteNews
`

// This query selects data from the "siteNews" table and populates the "siteNewsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "siteNewsSearch" using the "siteNews_idsiteNews".
func (q *Queries) remakeNewsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeNewsSearchInsert)
	return err
}

const remakeWritingSearch = `-- name: remakeWritingSearch :exec
INSERT INTO writingSearch (text, writing_idwriting)
SELECT CONCAT(title, ' ', abstract, ' ', writting), idwriting
FROM writing
`

// This query selects data from the "writing" table and populates the "writingSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "writingSearch" using the "writing_idwriting".
func (q *Queries) remakeWritingSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeWritingSearch)
	return err
}

const remakeWritingSearchInsert = `-- name: remakeWritingSearchInsert :exec
INSERT INTO writingSearch (text, writing_idwriting)
SELECT CONCAT(title, ' ', abstract, ' ', writting), idwriting
FROM writing
`

// This query selects data from the "writing" table and populates the "writingSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "writingSearch" using the "writing_idwriting".
func (q *Queries) remakeWritingSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeWritingSearchInsert)
	return err
}

const renameCategory = `-- name: renameCategory :exec
UPDATE linkerCategory SET title = ? WHERE idlinkerCategory = ?
`

type renameCategoryParams struct {
	Title            sql.NullString
	Idlinkercategory int32
}

func (q *Queries) renameCategory(ctx context.Context, arg renameCategoryParams) error {
	_, err := q.db.ExecContext(ctx, renameCategory, arg.Title, arg.Idlinkercategory)
	return err
}

const renameLanguage = `-- name: renameLanguage :exec
UPDATE language
SET nameof = ?
WHERE idlanguage = ?
`

type renameLanguageParams struct {
	Nameof     sql.NullString
	Idlanguage int32
}

// This query updates the "nameof" field in the "language" table based on the provided "cid".
// Parameters:
//
//	? - New name for the language (string)
//	? - Language ID to be updated (int)
func (q *Queries) renameLanguage(ctx context.Context, arg renameLanguageParams) error {
	_, err := q.db.ExecContext(ctx, renameLanguage, arg.Nameof, arg.Idlanguage)
	return err
}

const rename_category = `-- name: rename_category :exec
UPDATE faqCategories
SET name = ?
WHERE idfaqCategories = ?
`

type rename_categoryParams struct {
	Name            sql.NullString
	Idfaqcategories int32
}

func (q *Queries) rename_category(ctx context.Context, arg rename_categoryParams) error {
	_, err := q.db.ExecContext(ctx, rename_category, arg.Name, arg.Idfaqcategories)
	return err
}

const setTopicRestrictions = `-- name: setTopicRestrictions :exec
UPDATE topicrestrictions SET viewlevel = ?, replylevel = ?, newthreadlevel = ?, seelevel = ?, invitelevel = ?, readlevel = ?, modlevel = ?, adminlevel = ?
WHERE forumtopic_idforumtopic = ?
`

type setTopicRestrictionsParams struct {
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
	ForumtopicIdforumtopic int32
}

func (q *Queries) setTopicRestrictions(ctx context.Context, arg setTopicRestrictionsParams) error {
	_, err := q.db.ExecContext(ctx, setTopicRestrictions,
		arg.Viewlevel,
		arg.Replylevel,
		arg.Newthreadlevel,
		arg.Seelevel,
		arg.Invitelevel,
		arg.Readlevel,
		arg.Modlevel,
		arg.Adminlevel,
		arg.ForumtopicIdforumtopic,
	)
	return err
}

const setUsersTopicLevel = `-- name: setUsersTopicLevel :exec
UPDATE userstopiclevel SET level = ?, invitemax = ? WHERE forumtopic_idforumtopic = ? AND users_idusers = ?
`

type setUsersTopicLevelParams struct {
	Level                  sql.NullInt32
	Invitemax              sql.NullInt32
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
}

func (q *Queries) setUsersTopicLevel(ctx context.Context, arg setUsersTopicLevelParams) error {
	_, err := q.db.ExecContext(ctx, setUsersTopicLevel,
		arg.Level,
		arg.Invitemax,
		arg.ForumtopicIdforumtopic,
		arg.UsersIdusers,
	)
	return err
}

const showAdminQueue = `-- name: showAdminQueue :many
SELECT l.title, l.url, l.description, u.username, l.idlinkerQueue, c.title, c.idlinkerCategory
FROM linkerQueue l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory c ON l.linkerCategory_idlinkerCategory = c.idlinkerCategory
`

type showAdminQueueRow struct {
	Title            sql.NullString
	Url              sql.NullString
	Description      sql.NullString
	Username         sql.NullString
	Idlinkerqueue    int32
	Title_2          sql.NullString
	Idlinkercategory int32
}

func (q *Queries) showAdminQueue(ctx context.Context) ([]*showAdminQueueRow, error) {
	rows, err := q.db.QueryContext(ctx, showAdminQueue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showAdminQueueRow
	for rows.Next() {
		var i showAdminQueueRow
		if err := rows.Scan(
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Username,
			&i.Idlinkerqueue,
			&i.Title_2,
			&i.Idlinkercategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showAllBoards = `-- name: showAllBoards :many
SELECT b.idimageboard, b.title, b.description, b.imageboard_idimageboard, pb.title
FROM imageboard b
LEFT JOIN imageboard pb ON b.imageboard_idimageboard = pb.idimageboard OR b.imageboard_idimageboard = 0
GROUP BY b.idimageboard
`

type showAllBoardsRow struct {
	Idimageboard           int32
	Title                  sql.NullString
	Description            sql.NullString
	ImageboardIdimageboard int32
	Title_2                sql.NullString
}

func (q *Queries) showAllBoards(ctx context.Context) ([]*showAllBoardsRow, error) {
	rows, err := q.db.QueryContext(ctx, showAllBoards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showAllBoardsRow
	for rows.Next() {
		var i showAllBoardsRow
		if err := rows.Scan(
			&i.Idimageboard,
			&i.Title,
			&i.Description,
			&i.ImageboardIdimageboard,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showAllCategories = `-- name: showAllCategories :many
SELECT c.idforumcategory, c.title, c.description, c.forumcategory_idforumcategory, c2.title
FROM forumcategory c
LEFT JOIN forumcategory c2 ON c.forumcategory_idforumcategory = c2.idforumcategory
`

type showAllCategoriesRow struct {
	Idforumcategory              int32
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	Title_2                      sql.NullString
}

func (q *Queries) showAllCategories(ctx context.Context) ([]*showAllCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, showAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showAllCategoriesRow
	for rows.Next() {
		var i showAllCategoriesRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.Title,
			&i.Description,
			&i.ForumcategoryIdforumcategory,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showAllTopics = `-- name: showAllTopics :many
SELECT t.idforumtopic, t.title, t.description, t.forumcategory_idforumcategory, c.title
FROM forumtopic t
LEFT JOIN forumcategory c ON t.forumcategory_idforumcategory = c.idforumcategory
GROUP BY t.idforumtopic
`

type showAllTopicsRow struct {
	Idforumtopic                 int32
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	Title_2                      sql.NullString
}

func (q *Queries) showAllTopics(ctx context.Context) ([]*showAllTopicsRow, error) {
	rows, err := q.db.QueryContext(ctx, showAllTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showAllTopicsRow
	for rows.Next() {
		var i showAllTopicsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Title,
			&i.Description,
			&i.ForumcategoryIdforumcategory,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showCategories = `-- name: showCategories :many
SELECT idlinkerCategory, title FROM linkerCategory
`

func (q *Queries) showCategories(ctx context.Context) ([]*Linkercategory, error) {
	rows, err := q.db.QueryContext(ctx, showCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Linkercategory
	for rows.Next() {
		var i Linkercategory
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showLatest = `-- name: showLatest :many
SELECT l.title, l.url, l.description, u.username, l.idlinker, l.listed,
       IF(th.comments IS NULL, 0, th.comments+1), lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory lc ON l.linkerCategory_idlinkerCategory = lc.idlinkerCategory
WHERE l.linkerCategory_idlinkerCategory = ?
ORDER BY l.listed DESC
`

type showLatestRow struct {
	Title       sql.NullString
	Url         sql.NullString
	Description sql.NullString
	Username    sql.NullString
	Idlinker    int32
	Listed      sql.NullTime
	If          interface{}
	Title_2     sql.NullString
}

func (q *Queries) showLatest(ctx context.Context, linkercategoryIdlinkercategory int32) ([]*showLatestRow, error) {
	rows, err := q.db.QueryContext(ctx, showLatest, linkercategoryIdlinkercategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showLatestRow
	for rows.Next() {
		var i showLatestRow
		if err := rows.Scan(
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Username,
			&i.Idlinker,
			&i.Listed,
			&i.If,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showLinkComments = `-- name: showLinkComments :many
SELECT l.title, l.url, l.description, u.username, l.listed, l.forumthread_idforumthread, lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory lc ON l.linkerCategory_idlinkerCategory = lc.idlinkerCategory
WHERE l.idlinker = ?
`

type showLinkCommentsRow struct {
	Title                    sql.NullString
	Url                      sql.NullString
	Description              sql.NullString
	Username                 sql.NullString
	Listed                   sql.NullTime
	ForumthreadIdforumthread int32
	Title_2                  sql.NullString
}

func (q *Queries) showLinkComments(ctx context.Context, idlinker int32) ([]*showLinkCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, showLinkComments, idlinker)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showLinkCommentsRow
	for rows.Next() {
		var i showLinkCommentsRow
		if err := rows.Scan(
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Username,
			&i.Listed,
			&i.ForumthreadIdforumthread,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showPost = `-- name: showPost :many
SELECT u.username, s.news, s.occured, s.idsiteNews, u.idusers, s.forumthread_idforumthread
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
WHERE s.idsiteNews = ?
`

type showPostRow struct {
	Username                 sql.NullString
	News                     sql.NullString
	Occured                  sql.NullTime
	Idsitenews               int32
	Idusers                  sql.NullInt32
	ForumthreadIdforumthread int32
}

func (q *Queries) showPost(ctx context.Context, idsitenews int32) ([]*showPostRow, error) {
	rows, err := q.db.QueryContext(ctx, showPost, idsitenews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showPostRow
	for rows.Next() {
		var i showPostRow
		if err := rows.Scan(
			&i.Username,
			&i.News,
			&i.Occured,
			&i.Idsitenews,
			&i.Idusers,
			&i.ForumthreadIdforumthread,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showTableTopics = `-- name: showTableTopics :many
SELECT t.idforumtopic, t.title, t.description, t.comments, t.threads, t.lastaddition, lu.username, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE forumcategory_idforumcategory = ? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY t.lastaddition DESC
`

type showTableTopicsParams struct {
	UsersIdusers                 int32
	ForumcategoryIdforumcategory int32
}

type showTableTopicsRow struct {
	Idforumtopic int32
	Title        sql.NullString
	Description  sql.NullString
	Comments     sql.NullInt32
	Threads      sql.NullInt32
	Lastaddition sql.NullTime
	Username     sql.NullString
	Seelevel     sql.NullInt32
	Level        sql.NullInt32
}

func (q *Queries) showTableTopics(ctx context.Context, arg showTableTopicsParams) ([]*showTableTopicsRow, error) {
	rows, err := q.db.QueryContext(ctx, showTableTopics, arg.UsersIdusers, arg.ForumcategoryIdforumcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showTableTopicsRow
	for rows.Next() {
		var i showTableTopicsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Title,
			&i.Description,
			&i.Comments,
			&i.Threads,
			&i.Lastaddition,
			&i.Username,
			&i.Seelevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showTopicUserLevels = `-- name: showTopicUserLevels :one
SELECT r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, r.modlevel, r.adminlevel
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
WHERE idforumtopic = ?
`

type showTopicUserLevelsRow struct {
	Viewlevel      sql.NullInt32
	Replylevel     sql.NullInt32
	Newthreadlevel sql.NullInt32
	Seelevel       sql.NullInt32
	Invitelevel    sql.NullInt32
	Readlevel      sql.NullInt32
	Modlevel       sql.NullInt32
	Adminlevel     sql.NullInt32
}

func (q *Queries) showTopicUserLevels(ctx context.Context, idforumtopic int32) (*showTopicUserLevelsRow, error) {
	row := q.db.QueryRowContext(ctx, showTopicUserLevels, idforumtopic)
	var i showTopicUserLevelsRow
	err := row.Scan(
		&i.Viewlevel,
		&i.Replylevel,
		&i.Newthreadlevel,
		&i.Seelevel,
		&i.Invitelevel,
		&i.Readlevel,
		&i.Modlevel,
		&i.Adminlevel,
	)
	return &i, err
}

const show_blog_comments = `-- name: show_blog_comments :many
SELECT b.blog, b.written, u.username, b.idblogs, b.forumthread_idforumthread
FROM blogs b, users u
WHERE b.users_idusers = u.idusers AND b.idblogs = ?
`

type show_blog_commentsRow struct {
	Blog                     sql.NullString
	Written                  sql.NullTime
	Username                 sql.NullString
	Idblogs                  int32
	ForumthreadIdforumthread int32
}

func (q *Queries) show_blog_comments(ctx context.Context, idblogs int32) ([]*show_blog_commentsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_blog_comments, idblogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_blog_commentsRow
	for rows.Next() {
		var i show_blog_commentsRow
		if err := rows.Scan(
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Idblogs,
			&i.ForumthreadIdforumthread,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_blog_edit = `-- name: show_blog_edit :many
SELECT b.blog, b.language_idlanguage
FROM blogs b, users u
WHERE b.users_idusers = u.idusers AND b.idblogs = ?
`

type show_blog_editRow struct {
	Blog               sql.NullString
	LanguageIdlanguage int32
}

func (q *Queries) show_blog_edit(ctx context.Context, idblogs int32) ([]*show_blog_editRow, error) {
	rows, err := q.db.QueryContext(ctx, show_blog_edit, idblogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_blog_editRow
	for rows.Next() {
		var i show_blog_editRow
		if err := rows.Scan(&i.Blog, &i.LanguageIdlanguage); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_blogger_list = `-- name: show_blogger_list :many
SELECT u.username, COUNT(b.idblogs)
FROM blogs b, users u
WHERE b.users_idusers = u.idusers
GROUP BY u.idusers
`

type show_blogger_listRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) show_blogger_list(ctx context.Context) ([]*show_blogger_listRow, error) {
	rows, err := q.db.QueryContext(ctx, show_blogger_list)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_blogger_listRow
	for rows.Next() {
		var i show_blogger_listRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_bookmarks = `-- name: show_bookmarks :one
SELECT list
FROM bookmarks
WHERE users_idusers = ?
`

// This query retrieves the "list" from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) show_bookmarks(ctx context.Context, usersIdusers int32) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, show_bookmarks, usersIdusers)
	var list sql.NullString
	err := row.Scan(&list)
	return list, err
}

const show_categories = `-- name: show_categories :exec
SELECT f.idforumcategory, f.title, f.description
FROM forumcategory f WHERE f.forumcategory_idforumcategory = ?
`

type show_categoriesRow struct {
	Idforumcategory int32
	Title           sql.NullString
	Description     sql.NullString
}

func (q *Queries) show_categories(ctx context.Context, forumcategoryIdforumcategory int32) error {
	_, err := q.db.ExecContext(ctx, show_categories, forumcategoryIdforumcategory)
	return err
}

const show_latest_blogs = `-- name: show_latest_blogs :many
SELECT b.blog, b.written, u.username, b.idblogs, IF(th.comments IS NULL, 0, th.comments + 1), b.users_idusers
FROM blogs b, users u
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE b.users_idusers = ? AND (b.language_idlanguage = ?)
ORDER BY b.written DESC
LIMIT ? OFFSET ?
`

type show_latest_blogsParams struct {
	UsersIdusers       int32
	LanguageIdlanguage int32
	Limit              int32
	Offset             int32
}

type show_latest_blogsRow struct {
	Blog         sql.NullString
	Written      sql.NullTime
	Username     sql.NullString
	Idblogs      int32
	If           interface{}
	UsersIdusers int32
}

func (q *Queries) show_latest_blogs(ctx context.Context, arg show_latest_blogsParams) ([]*show_latest_blogsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_latest_blogs,
		arg.UsersIdusers,
		arg.LanguageIdlanguage,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_latest_blogsRow
	for rows.Next() {
		var i show_latest_blogsRow
		if err := rows.Scan(
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Idblogs,
			&i.If,
			&i.UsersIdusers,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_questions = `-- name: show_questions :many
SELECT c.idfaqCategories, c.name, f.question, f.answer
FROM faq f, faqCategories c
WHERE c.idfaqCategories <> ? AND f.answer IS NOT NULL AND c.idfaqCategories = f.faqCategories_idfaqCategories AND (c.idfaqCategories = ?)
ORDER BY c.idfaqCategories
`

type show_questionsParams struct {
	Idfaqcategories   int32
	Idfaqcategories_2 int32
}

type show_questionsRow struct {
	Idfaqcategories int32
	Name            sql.NullString
	Question        sql.NullString
	Answer          sql.NullString
}

func (q *Queries) show_questions(ctx context.Context, arg show_questionsParams) ([]*show_questionsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_questions, arg.Idfaqcategories, arg.Idfaqcategories_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_questionsRow
	for rows.Next() {
		var i show_questionsRow
		if err := rows.Scan(
			&i.Idfaqcategories,
			&i.Name,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_topics = `-- name: show_topics :many
SELECT t.idforumtopic, t.title, t.description, t.comments, t.threads, t.lastaddition, lu.username, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE t.forumcategory_idforumcategory = ?
ORDER BY t.lastaddition DESC
`

type show_topicsParams struct {
	UsersIdusers                 int32
	ForumcategoryIdforumcategory int32
}

type show_topicsRow struct {
	Idforumtopic int32
	Title        sql.NullString
	Description  sql.NullString
	Comments     sql.NullInt32
	Threads      sql.NullInt32
	Lastaddition sql.NullTime
	Username     sql.NullString
	Seelevel     sql.NullInt32
	Level        sql.NullInt32
}

func (q *Queries) show_topics(ctx context.Context, arg show_topicsParams) ([]*show_topicsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_topics, arg.UsersIdusers, arg.ForumcategoryIdforumcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_topicsRow
	for rows.Next() {
		var i show_topicsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Title,
			&i.Description,
			&i.Comments,
			&i.Threads,
			&i.Lastaddition,
			&i.Username,
			&i.Seelevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const somethingNotifyBlogs = `-- name: somethingNotifyBlogs :exec
SELECT u.email FROM blogs t, users u, preferences p
WHERE t.idblogs=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type somethingNotifyBlogsParams struct {
	Idblogs int32
	Idusers int32
}

func (q *Queries) somethingNotifyBlogs(ctx context.Context, arg somethingNotifyBlogsParams) error {
	_, err := q.db.ExecContext(ctx, somethingNotifyBlogs, arg.Idblogs, arg.Idusers)
	return err
}

const somethingNotifyLinker = `-- name: somethingNotifyLinker :exec
SELECT u.email FROM linker t, users u, preferences p
WHERE t.idlinker=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type somethingNotifyLinkerParams struct {
	Idlinker int32
	Idusers  int32
}

func (q *Queries) somethingNotifyLinker(ctx context.Context, arg somethingNotifyLinkerParams) error {
	_, err := q.db.ExecContext(ctx, somethingNotifyLinker, arg.Idlinker, arg.Idusers)
	return err
}

const somethingNotifyWriting = `-- name: somethingNotifyWriting :exec
SELECT u.email FROM writing t, users u, preferences p
WHERE t.idwriting=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type somethingNotifyWritingParams struct {
	Idwriting int32
	Idusers   int32
}

func (q *Queries) somethingNotifyWriting(ctx context.Context, arg somethingNotifyWritingParams) error {
	_, err := q.db.ExecContext(ctx, somethingNotifyWriting, arg.Idwriting, arg.Idusers)
	return err
}

const threadAllowThis = `-- name: threadAllowThis :one
SELECT r.forumtopic_idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, r.modlevel, r.adminlevel, u.level FROM forumthread t
LEFT JOIN topicrestrictions r ON t.forumtopic_idforumtopic=r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic=t.forumtopic_idforumtopic AND u.users_idusers=?
WHERE t.idforumthread=? LIMIT 1
`

type threadAllowThisParams struct {
	UsersIdusers  int32
	Idforumthread int32
}

type threadAllowThisRow struct {
	ForumtopicIdforumtopic sql.NullInt32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
	Level                  sql.NullInt32
}

func (q *Queries) threadAllowThis(ctx context.Context, arg threadAllowThisParams) (*threadAllowThisRow, error) {
	row := q.db.QueryRowContext(ctx, threadAllowThis, arg.UsersIdusers, arg.Idforumthread)
	var i threadAllowThisRow
	err := row.Scan(
		&i.ForumtopicIdforumtopic,
		&i.Viewlevel,
		&i.Replylevel,
		&i.Newthreadlevel,
		&i.Seelevel,
		&i.Invitelevel,
		&i.Readlevel,
		&i.Modlevel,
		&i.Adminlevel,
		&i.Level,
	)
	return &i, err
}

const threadNotify = `-- name: threadNotify :exec
SELECT u.email FROM comments c, users u, preferences p
WHERE c.forumthread_idforumthread=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=c.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type threadNotifyParams struct {
	ForumthreadIdforumthread int32
	Idusers                  int32
}

func (q *Queries) threadNotify(ctx context.Context, arg threadNotifyParams) error {
	_, err := q.db.ExecContext(ctx, threadNotify, arg.ForumthreadIdforumthread, arg.Idusers)
	return err
}

const topicAllowThis = `-- name: topicAllowThis :one
SELECT r.forumtopic_idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, r.modlevel, r.adminlevel, u.level FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic=r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic=t.idforumtopic AND u.users_idusers=?
WHERE t.idforumtopic=? LIMIT 1
`

type topicAllowThisParams struct {
	UsersIdusers int32
	Idforumtopic int32
}

type topicAllowThisRow struct {
	ForumtopicIdforumtopic sql.NullInt32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
	Level                  sql.NullInt32
}

func (q *Queries) topicAllowThis(ctx context.Context, arg topicAllowThisParams) (*topicAllowThisRow, error) {
	row := q.db.QueryRowContext(ctx, topicAllowThis, arg.UsersIdusers, arg.Idforumtopic)
	var i topicAllowThisRow
	err := row.Scan(
		&i.ForumtopicIdforumtopic,
		&i.Viewlevel,
		&i.Replylevel,
		&i.Newthreadlevel,
		&i.Seelevel,
		&i.Invitelevel,
		&i.Readlevel,
		&i.Modlevel,
		&i.Adminlevel,
		&i.Level,
	)
	return &i, err
}

const updateQueue = `-- name: updateQueue :exec
UPDATE linkerQueue SET linkerCategory_idlinkerCategory = ?, title = ?, url = ?, description = ? WHERE idlinkerQueue = ?
`

type updateQueueParams struct {
	LinkercategoryIdlinkercategory int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
	Idlinkerqueue                  int32
}

func (q *Queries) updateQueue(ctx context.Context, arg updateQueueParams) error {
	_, err := q.db.ExecContext(ctx, updateQueue,
		arg.LinkercategoryIdlinkercategory,
		arg.Title,
		arg.Url,
		arg.Description,
		arg.Idlinkerqueue,
	)
	return err
}

const updateWriting = `-- name: updateWriting :exec
UPDATE writing
SET writingCategory_idwritingCategory = ?, title = ?, abstract = ?, writting = ?, private = ?, language_idlanguage = ?
WHERE idwriting = ?
`

type updateWritingParams struct {
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Abstract                         sql.NullString
	Writting                         sql.NullString
	Private                          sql.NullBool
	LanguageIdlanguage               int32
	Idwriting                        int32
}

func (q *Queries) updateWriting(ctx context.Context, arg updateWritingParams) error {
	_, err := q.db.ExecContext(ctx, updateWriting,
		arg.WritingcategoryIdwritingcategory,
		arg.Title,
		arg.Abstract,
		arg.Writting,
		arg.Private,
		arg.LanguageIdlanguage,
		arg.Idwriting,
	)
	return err
}

const updateWritingApproval = `-- name: updateWritingApproval :exec
UPDATE writtingApprovedUsers
SET readdoc = ?, editdoc = ?
WHERE writing_idwriting = ? AND users_idusers = ?
`

type updateWritingApprovalParams struct {
	Readdoc          sql.NullBool
	Editdoc          sql.NullBool
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) updateWritingApproval(ctx context.Context, arg updateWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingApproval,
		arg.Readdoc,
		arg.Editdoc,
		arg.WritingIdwriting,
		arg.UsersIdusers,
	)
	return err
}

const updateWritingCategory = `-- name: updateWritingCategory :exec
UPDATE writingCategory
SET title = ?, description = ?, writingCategory_idwritingCategory = ?
WHERE idwritingCategory = ?
`

type updateWritingCategoryParams struct {
	Title                            sql.NullString
	Description                      sql.NullString
	WritingcategoryIdwritingcategory int32
	Idwritingcategory                int32
}

func (q *Queries) updateWritingCategory(ctx context.Context, arg updateWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingCategory,
		arg.Title,
		arg.Description,
		arg.WritingcategoryIdwritingcategory,
		arg.Idwritingcategory,
	)
	return err
}

const updateWritingForumThreadId = `-- name: updateWritingForumThreadId :exec
UPDATE writing
SET forumthread_idforumthread = ?
WHERE idwriting = ?
`

type updateWritingForumThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idwriting                int32
}

func (q *Queries) updateWritingForumThreadId(ctx context.Context, arg updateWritingForumThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingForumThreadId, arg.ForumthreadIdforumthread, arg.Idwriting)
	return err
}

const update_blog = `-- name: update_blog :exec
UPDATE blogs
SET language_idlanguage = ?, blog = ?
WHERE idblogs = ?
`

type update_blogParams struct {
	LanguageIdlanguage int32
	Blog               sql.NullString
	Idblogs            int32
}

func (q *Queries) update_blog(ctx context.Context, arg update_blogParams) error {
	_, err := q.db.ExecContext(ctx, update_blog, arg.LanguageIdlanguage, arg.Blog, arg.Idblogs)
	return err
}

const update_bookmarks = `-- name: update_bookmarks :exec
UPDATE bookmarks
SET list = ?
WHERE users_idusers = ?
`

type update_bookmarksParams struct {
	List         sql.NullString
	UsersIdusers int32
}

// This query updates the "list" column in the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) update_bookmarks(ctx context.Context, arg update_bookmarksParams) error {
	_, err := q.db.ExecContext(ctx, update_bookmarks, arg.List, arg.UsersIdusers)
	return err
}

const update_forumthread_comments = `-- name: update_forumthread_comments :exec
UPDATE forumthread
SET comments = (
    SELECT COUNT(users_idusers) - 1
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
)
`

// This query updates the "comments" column in the "forumthread" table.
// It sets the "comments" column to the count of users (excluding the thread creator) from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_comments(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_comments)
	return err
}

const update_forumthread_firstpost = `-- name: update_forumthread_firstpost :exec
UPDATE forumthread
SET firstpost = (
    SELECT idcomments
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    LIMIT 1
)
`

// This query updates the "firstpost" column in the "forumthread" table.
// It sets the "firstpost" column to the ID of the first comment from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_firstpost(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_firstpost)
	return err
}

const update_forumthread_lastaddition = `-- name: update_forumthread_lastaddition :exec
UPDATE forumthread
SET lastaddition = (
    SELECT written
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
)
`

// This query updates the "lastaddition" column in the "forumthread" table.
// It sets the "lastaddition" column to the latest "written" value from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_lastaddition(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_lastaddition)
	return err
}

const update_forumthread_lastposter = `-- name: update_forumthread_lastposter :exec
UPDATE forumthread
SET lastposter = (
    SELECT users_idusers
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
)
`

// This query updates the "lastposter" column in the "forumthread" table.
// It sets the "lastposter" column to the latest "users_idusers" value from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_lastposter(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_lastposter)
	return err
}

const update_forumtopic_comments = `-- name: update_forumtopic_comments :exec
UPDATE forumtopic
SET comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
)
`

// This query updates the "comments" column in the "forumtopic" table.
// It sets the "comments" column to the sum of comments from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
func (q *Queries) update_forumtopic_comments(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic_comments)
	return err
}

const update_forumtopic_lastaddition_lastposter = `-- name: update_forumtopic_lastaddition_lastposter :exec
UPDATE forumtopic
SET lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
),
lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
`

// This query updates the "lastaddition" and "lastposter" columns in the "forumtopic" table.
// It sets the "lastaddition" column to the latest "lastaddition" value from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
// It sets the "lastposter" column to the latest "lastposter" value from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
func (q *Queries) update_forumtopic_lastaddition_lastposter(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic_lastaddition_lastposter)
	return err
}

const update_forumtopic_threads = `-- name: update_forumtopic_threads :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
)
`

// This query updates the "threads" column in the "forumtopic" table.
// It sets the "threads" column to the count of forum threads from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
func (q *Queries) update_forumtopic_threads(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic_threads)
	return err
}

const userAllow = `-- name: userAllow :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES (?, ?, ?)
`

type userAllowParams struct {
	UsersIdusers int32
	Section      sql.NullString
	Level        sql.NullString
}

// This query inserts a new permission into the "permissions" table.
// Parameters:
//
//	? - User ID to be associated with the permission (int)
//	? - Section for which the permission is granted (string)
//	? - Level of the permission (string)
func (q *Queries) userAllow(ctx context.Context, arg userAllowParams) error {
	_, err := q.db.ExecContext(ctx, userAllow, arg.UsersIdusers, arg.Section, arg.Level)
	return err
}

const userDisallow = `-- name: userDisallow :exec
DELETE FROM permissions
WHERE idpermissions = ?
`

// This query deletes a permission from the "permissions" table based on the provided "permid".
// Parameters:
//
//	? - Permission ID to be deleted (int)
func (q *Queries) userDisallow(ctx context.Context, idpermissions int32) error {
	_, err := q.db.ExecContext(ctx, userDisallow, idpermissions)
	return err
}

const user_allow = `-- name: user_allow :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES (?, ?, ?)
`

type user_allowParams struct {
	UsersIdusers int32
	Section      sql.NullString
	Level        sql.NullString
}

func (q *Queries) user_allow(ctx context.Context, arg user_allowParams) error {
	_, err := q.db.ExecContext(ctx, user_allow, arg.UsersIdusers, arg.Section, arg.Level)
	return err
}

const user_disallow = `-- name: user_disallow :exec
DELETE FROM permissions
WHERE idpermissions = ? AND section = ?
`

type user_disallowParams struct {
	Idpermissions int32
	Section       sql.NullString
}

func (q *Queries) user_disallow(ctx context.Context, arg user_disallowParams) error {
	_, err := q.db.ExecContext(ctx, user_disallow, arg.Idpermissions, arg.Section)
	return err
}

const usernametouid = `-- name: usernametouid :one

SELECT idusers FROM users WHERE username = ?
`

// -- name: forumTopicSearch :many
// SELECT * FROM comments c
// LEFT JOIN forumthread th ON th.idforumthread = c.forumthread_idforumthread
// LEFT JOIN forumtopic t ON t.idforumtopic = th.forumtopic_idforumtopic
// LEFT JOIN userstopiclevel utl ON t.idforumtopic = utl.forumtopic_idforumtopic AND utl.users_idusers = ?
// LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
//
//	WHERE c.idcomments IN (?) AND th.idforumthread != 0 AND t.idforumtopic = ?
//
// AND ((r.readlevel <= utl.level AND r.viewlevel <= utl.level AND r.seelevel <= utl.level));
//
// -- name: forumSearch :many
// SELECT c.forumthread_idforumthread FROM comments c
// LEFT JOIN forumthread th ON th.idforumthread = c.forumthread_idforumthread
// LEFT JOIN forumtopic t ON t.idforumtopic = th.forumtopic_idforumtopic
// LEFT JOIN forumcategory fc ON fc.idforumcategory = t.forumcategory_idforumcategory
// LEFT JOIN userstopiclevel utl ON t.idforumtopic = utl.forumtopic_idforumtopic AND utl.users_idusers = ?
// LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
// WHERE c.idcomments IN (?) AND th.idforumthread != 0 AND t.idforumtopic != 0
// AND ((r.readlevel <= utl.level AND r.viewlevel <= utl.level AND r.seelevel <= utl.level) OR ?)
// AND fc.idforumcategory != 0
// GROUP BY c.forumthread_idforumthread;
func (q *Queries) usernametouid(ctx context.Context, username sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, usernametouid, username)
	var idusers int32
	err := row.Scan(&idusers)
	return idusers, err
}

const users_bookmarks = `-- name: users_bookmarks :one
SELECT list
FROM bookmarks
WHERE users_idusers = ?
`

// This query retrieves the "list" from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) users_bookmarks(ctx context.Context, usersIdusers int32) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, users_bookmarks, usersIdusers)
	var list sql.NullString
	err := row.Scan(&list)
	return list, err
}

const writeLinkerRSS = `-- name: writeLinkerRSS :many
SELECT l.idlinker, l.title, l.description, l.url
FROM linker l
WHERE l.linkerCategory_idlinkerCategory = ?
ORDER BY l.listed DESC
`

type writeLinkerRSSRow struct {
	Idlinker    int32
	Title       sql.NullString
	Description sql.NullString
	Url         sql.NullString
}

func (q *Queries) writeLinkerRSS(ctx context.Context, linkercategoryIdlinkercategory int32) ([]*writeLinkerRSSRow, error) {
	rows, err := q.db.QueryContext(ctx, writeLinkerRSS, linkercategoryIdlinkercategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*writeLinkerRSSRow
	for rows.Next() {
		var i writeLinkerRSSRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.Title,
			&i.Description,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const writeNewsPost = `-- name: writeNewsPost :exec
INSERT INTO siteNews (news, users_idusers, occured, language_idlanguage)
VALUES (?, ?, NOW(), ?)
`

type writeNewsPostParams struct {
	News               sql.NullString
	UsersIdusers       int32
	LanguageIdlanguage int32
}

func (q *Queries) writeNewsPost(ctx context.Context, arg writeNewsPostParams) error {
	_, err := q.db.ExecContext(ctx, writeNewsPost, arg.News, arg.UsersIdusers, arg.LanguageIdlanguage)
	return err
}

const writeRSS = `-- name: writeRSS :exec
SELECT title, description FROM imageboard WHERE idimageboard = ?
`

type writeRSSRow struct {
	Title       sql.NullString
	Description sql.NullString
}

func (q *Queries) writeRSS(ctx context.Context, idimageboard int32) error {
	_, err := q.db.ExecContext(ctx, writeRSS, idimageboard)
	return err
}

const writeSiteNewsRSS = `-- name: writeSiteNewsRSS :many
SELECT s.idsiteNews, s.occured, s.news
FROM siteNews s
ORDER BY s.occured DESC LIMIT 15
`

type writeSiteNewsRSSRow struct {
	Idsitenews int32
	Occured    sql.NullTime
	News       sql.NullString
}

func (q *Queries) writeSiteNewsRSS(ctx context.Context) ([]*writeSiteNewsRSSRow, error) {
	rows, err := q.db.QueryContext(ctx, writeSiteNewsRSS)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*writeSiteNewsRSSRow
	for rows.Next() {
		var i writeSiteNewsRSSRow
		if err := rows.Scan(&i.Idsitenews, &i.Occured, &i.News); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const write_blog_atom = `-- name: write_blog_atom :many
SELECT b.idblogs, LEFT(b.written, 255), b.blog, u.username
FROM blogs b, users u
WHERE u.idusers = b.users_idusers AND b.users_idusers = ?
ORDER BY b.written DESC
LIMIT ?
`

type write_blog_atomParams struct {
	UsersIdusers int32
	Limit        int32
}

type write_blog_atomRow struct {
	Idblogs  int32
	Left     string
	Blog     sql.NullString
	Username sql.NullString
}

func (q *Queries) write_blog_atom(ctx context.Context, arg write_blog_atomParams) ([]*write_blog_atomRow, error) {
	rows, err := q.db.QueryContext(ctx, write_blog_atom, arg.UsersIdusers, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*write_blog_atomRow
	for rows.Next() {
		var i write_blog_atomRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.Left,
			&i.Blog,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const write_blog_rss = `-- name: write_blog_rss :many
SELECT b.idblogs, LEFT(b.written, 255), b.blog, u.username
FROM blogs b, users u
WHERE u.idusers = b.users_idusers AND b.users_idusers= ?
ORDER BY b.written DESC
LIMIT ?
`

type write_blog_rssParams struct {
	UsersIdusers int32
	Limit        int32
}

type write_blog_rssRow struct {
	Idblogs  int32
	Left     string
	Blog     sql.NullString
	Username sql.NullString
}

func (q *Queries) write_blog_rss(ctx context.Context, arg write_blog_rssParams) ([]*write_blog_rssRow, error) {
	rows, err := q.db.QueryContext(ctx, write_blog_rss, arg.UsersIdusers, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*write_blog_rssRow
	for rows.Next() {
		var i write_blog_rssRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.Left,
			&i.Blog,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
