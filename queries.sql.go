// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: queries.sql

package main

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const addImage = `-- name: AddImage :exec
INSERT INTO imagepost (imageboard_idimageboard, thumbnail, fullimage, users_idusers, description, posted)
VALUES (?, ?, ?, ?, ?, NOW())
`

type AddImageParams struct {
	ImageboardIdimageboard int32
	Thumbnail              sql.NullString
	Fullimage              sql.NullString
	UsersIdusers           int32
	Description            sql.NullString
}

func (q *Queries) AddImage(ctx context.Context, arg AddImageParams) error {
	_, err := q.db.ExecContext(ctx, addImage,
		arg.ImageboardIdimageboard,
		arg.Thumbnail,
		arg.Fullimage,
		arg.UsersIdusers,
		arg.Description,
	)
	return err
}

const addToForumCommentSearch = `-- name: AddToForumCommentSearch :exec
INSERT IGNORE INTO commentsSearch
(comments_idcomments, searchwordlist_idsearchwordlist)
VALUES (?, ?)
`

type AddToForumCommentSearchParams struct {
	CommentsIdcomments             int32
	SearchwordlistIdsearchwordlist int32
}

func (q *Queries) AddToForumCommentSearch(ctx context.Context, arg AddToForumCommentSearchParams) error {
	_, err := q.db.ExecContext(ctx, addToForumCommentSearch, arg.CommentsIdcomments, arg.SearchwordlistIdsearchwordlist)
	return err
}

const addToForumWritingSearch = `-- name: AddToForumWritingSearch :exec
INSERT IGNORE INTO writingSearch
(writing_idwriting, searchwordlist_idsearchwordlist)
VALUES (?, ?)
`

type AddToForumWritingSearchParams struct {
	WritingIdwriting               int32
	SearchwordlistIdsearchwordlist int32
}

func (q *Queries) AddToForumWritingSearch(ctx context.Context, arg AddToForumWritingSearchParams) error {
	_, err := q.db.ExecContext(ctx, addToForumWritingSearch, arg.WritingIdwriting, arg.SearchwordlistIdsearchwordlist)
	return err
}

const addToLinker = `-- name: AddToLinker :exec
INSERT INTO linker (users_idusers, linkerCategory_idlinkerCategory, title, url, description, listed)
VALUES (?, ?, ?, ?, ?, NOW())
`

type AddToLinkerParams struct {
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
}

func (q *Queries) AddToLinker(ctx context.Context, arg AddToLinkerParams) error {
	_, err := q.db.ExecContext(ctx, addToLinker,
		arg.UsersIdusers,
		arg.LinkercategoryIdlinkercategory,
		arg.Title,
		arg.Url,
		arg.Description,
	)
	return err
}

const addToQueue = `-- name: AddToQueue :exec
INSERT INTO linkerQueue (users_idusers, linkerCategory_idlinkerCategory, title, url, description) VALUES (?, ?, ?, ?, ?)
`

type AddToQueueParams struct {
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
}

func (q *Queries) AddToQueue(ctx context.Context, arg AddToQueueParams) error {
	_, err := q.db.ExecContext(ctx, addToQueue,
		arg.UsersIdusers,
		arg.LinkercategoryIdlinkercategory,
		arg.Title,
		arg.Url,
		arg.Description,
	)
	return err
}

const addWord = `-- name: AddWord :execlastid
INSERT IGNORE INTO searchwordlist (word)
VALUES (lcase(?))
`

func (q *Queries) AddWord(ctx context.Context, word string) (int64, error) {
	result, err := q.db.ExecContext(ctx, addWord, word)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const add_blog = `-- name: Add_blog :execlastid
INSERT INTO blogs (users_idusers, language_idlanguage, blog, written)
VALUES (?, ?, ?, NOW())
`

type Add_blogParams struct {
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
}

func (q *Queries) Add_blog(ctx context.Context, arg Add_blogParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, add_blog, arg.UsersIdusers, arg.LanguageIdlanguage, arg.Blog)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const add_bookmarks = `-- name: Add_bookmarks :exec
INSERT INTO bookmarks (users_idusers, list)
VALUES (?, ?)
`

type Add_bookmarksParams struct {
	UsersIdusers int32
	List         sql.NullString
}

// This query adds a new entry to the "bookmarks" table and returns the last inserted ID as "returnthis".
func (q *Queries) Add_bookmarks(ctx context.Context, arg Add_bookmarksParams) error {
	_, err := q.db.ExecContext(ctx, add_bookmarks, arg.UsersIdusers, arg.List)
	return err
}

const add_question = `-- name: Add_question :exec
INSERT INTO faq (question, users_idusers, language_idlanguage)
VALUES (?, ?, ?)
`

type Add_questionParams struct {
	Question           sql.NullString
	UsersIdusers       int32
	LanguageIdlanguage int32
}

func (q *Queries) Add_question(ctx context.Context, arg Add_questionParams) error {
	_, err := q.db.ExecContext(ctx, add_question, arg.Question, arg.UsersIdusers, arg.LanguageIdlanguage)
	return err
}

const adminCategories = `-- name: AdminCategories :many
SELECT idlinkerCategory, title FROM linkerCategory
`

func (q *Queries) AdminCategories(ctx context.Context) ([]*Linkercategory, error) {
	rows, err := q.db.QueryContext(ctx, adminCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Linkercategory
	for rows.Next() {
		var i Linkercategory
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allQuestions = `-- name: AllQuestions :many
SELECT idfaq, faqcategories_idfaqcategories, language_idlanguage, users_idusers, answer, question
FROM faq
`

func (q *Queries) AllQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, allQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allUsers = `-- name: AllUsers :many
SELECT u.idusers, u.email, u.passwd, u.username
FROM users u
`

// This query selects all admin users from the "users" table.
// Result:
//
//	idusers (int)
//	username (string)
//	email (string)
func (q *Queries) AllUsers(ctx context.Context) ([]*User, error) {
	rows, err := q.db.QueryContext(ctx, allUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const assignImagePostThisThreadId = `-- name: AssignImagePostThisThreadId :exec
UPDATE imagepost SET forumthread_idforumthread = ? WHERE idimagepost = ?
`

type AssignImagePostThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idimagepost              int32
}

func (q *Queries) AssignImagePostThisThreadId(ctx context.Context, arg AssignImagePostThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignImagePostThisThreadId, arg.ForumthreadIdforumthread, arg.Idimagepost)
	return err
}

const assignLinkerThisThreadId = `-- name: AssignLinkerThisThreadId :exec
UPDATE linker SET forumthread_idforumthread = ? WHERE idlinker = ?
`

type AssignLinkerThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idlinker                 int32
}

func (q *Queries) AssignLinkerThisThreadId(ctx context.Context, arg AssignLinkerThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignLinkerThisThreadId, arg.ForumthreadIdforumthread, arg.Idlinker)
	return err
}

const assignNewsThisThreadId = `-- name: AssignNewsThisThreadId :exec
UPDATE siteNews SET forumthread_idforumthread = ? WHERE idsiteNews = ?
`

type AssignNewsThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idsitenews               int32
}

func (q *Queries) AssignNewsThisThreadId(ctx context.Context, arg AssignNewsThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignNewsThisThreadId, arg.ForumthreadIdforumthread, arg.Idsitenews)
	return err
}

const assignWritingThisThreadId = `-- name: AssignWritingThisThreadId :exec
UPDATE writing SET forumthread_idforumthread = ? WHERE idwriting = ?
`

type AssignWritingThisThreadIdParams struct {
	ForumthreadIdforumthread int32
	Idwriting                int32
}

func (q *Queries) AssignWritingThisThreadId(ctx context.Context, arg AssignWritingThisThreadIdParams) error {
	_, err := q.db.ExecContext(ctx, assignWritingThisThreadId, arg.ForumthreadIdforumthread, arg.Idwriting)
	return err
}

const assign_blog_to_thread = `-- name: Assign_blog_to_thread :exec
UPDATE blogs
SET forumthread_idforumthread = ?
WHERE idblogs = ?
`

type Assign_blog_to_threadParams struct {
	ForumthreadIdforumthread int32
	Idblogs                  int32
}

func (q *Queries) Assign_blog_to_thread(ctx context.Context, arg Assign_blog_to_threadParams) error {
	_, err := q.db.ExecContext(ctx, assign_blog_to_thread, arg.ForumthreadIdforumthread, arg.Idblogs)
	return err
}

const blog_atom = `-- name: Blog_atom :many
SELECT b.idblogs, LEFT(b.written, 255), b.blog, u.username
FROM blogs b, users u
WHERE u.idusers = b.users_idusers AND b.users_idusers = ?
ORDER BY b.written DESC
LIMIT ?
`

type Blog_atomParams struct {
	UsersIdusers int32
	Limit        int32
}

type Blog_atomRow struct {
	Idblogs  int32
	Left     string
	Blog     sql.NullString
	Username sql.NullString
}

func (q *Queries) Blog_atom(ctx context.Context, arg Blog_atomParams) ([]*Blog_atomRow, error) {
	rows, err := q.db.QueryContext(ctx, blog_atom, arg.UsersIdusers, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Blog_atomRow
	for rows.Next() {
		var i Blog_atomRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.Left,
			&i.Blog,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const blog_rss = `-- name: Blog_rss :many
SELECT b.idblogs, LEFT(b.written, 255), b.blog, u.username
FROM blogs b, users u
WHERE u.idusers = b.users_idusers AND b.users_idusers= ?
ORDER BY b.written DESC
LIMIT ?
`

type Blog_rssParams struct {
	UsersIdusers int32
	Limit        int32
}

type Blog_rssRow struct {
	Idblogs  int32
	Left     string
	Blog     sql.NullString
	Username sql.NullString
}

func (q *Queries) Blog_rss(ctx context.Context, arg Blog_rssParams) ([]*Blog_rssRow, error) {
	rows, err := q.db.QueryContext(ctx, blog_rss, arg.UsersIdusers, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Blog_rssRow
	for rows.Next() {
		var i Blog_rssRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.Left,
			&i.Blog,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const blogsSearchFirst = `-- name: BlogsSearchFirst :many
SELECT DISTINCT cs.blogs_idblogs
FROM blogsSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
`

func (q *Queries) BlogsSearchFirst(ctx context.Context, word sql.NullString) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, blogsSearchFirst, word)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var blogs_idblogs int32
		if err := rows.Scan(&blogs_idblogs); err != nil {
			return nil, err
		}
		items = append(items, blogs_idblogs)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const blogsSearchNext = `-- name: BlogsSearchNext :many
SELECT DISTINCT cs.blogs_idblogs
FROM blogsSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
AND cs.blogs_idblogs IN (/*SLICE:ids*/?)
`

type BlogsSearchNextParams struct {
	Word sql.NullString
	Ids  []int32
}

func (q *Queries) BlogsSearchNext(ctx context.Context, arg BlogsSearchNextParams) ([]int32, error) {
	query := blogsSearchNext
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var blogs_idblogs int32
		if err := rows.Scan(&blogs_idblogs); err != nil {
			return nil, err
		}
		items = append(items, blogs_idblogs)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const blogsUserPermissions = `-- name: BlogsUserPermissions :many
SELECT p.idpermissions, p.level, u.username, u.email, p.section
FROM permissions p, users u
WHERE u.idusers = p.users_idusers AND p.section = "blogs"
ORDER BY p.level
`

type BlogsUserPermissionsRow struct {
	Idpermissions int32
	Level         sql.NullString
	Username      sql.NullString
	Email         sql.NullString
	Section       sql.NullString
}

func (q *Queries) BlogsUserPermissions(ctx context.Context) ([]*BlogsUserPermissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, blogsUserPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*BlogsUserPermissionsRow
	for rows.Next() {
		var i BlogsUserPermissionsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.Level,
			&i.Username,
			&i.Email,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const changeCategory = `-- name: ChangeCategory :exec
UPDATE forumcategory SET title = ?, description = ?, forumcategory_idforumcategory = ? WHERE idforumcategory = ?
`

type ChangeCategoryParams struct {
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	Idforumcategory              int32
}

func (q *Queries) ChangeCategory(ctx context.Context, arg ChangeCategoryParams) error {
	_, err := q.db.ExecContext(ctx, changeCategory,
		arg.Title,
		arg.Description,
		arg.ForumcategoryIdforumcategory,
		arg.Idforumcategory,
	)
	return err
}

const changeImageBoard = `-- name: ChangeImageBoard :exec
UPDATE imageboard SET title = ?, description = ?, imageboard_idimageboard = ? WHERE idimageboard = ?
`

type ChangeImageBoardParams struct {
	Title                  sql.NullString
	Description            sql.NullString
	ImageboardIdimageboard int32
	Idimageboard           int32
}

func (q *Queries) ChangeImageBoard(ctx context.Context, arg ChangeImageBoardParams) error {
	_, err := q.db.ExecContext(ctx, changeImageBoard,
		arg.Title,
		arg.Description,
		arg.ImageboardIdimageboard,
		arg.Idimageboard,
	)
	return err
}

const changeTopic = `-- name: ChangeTopic :exec
UPDATE forumtopic SET title = ?, description = ?, forumcategory_idforumcategory = ? WHERE idforumtopic = ?
`

type ChangeTopicParams struct {
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	Idforumtopic                 int32
}

func (q *Queries) ChangeTopic(ctx context.Context, arg ChangeTopicParams) error {
	_, err := q.db.ExecContext(ctx, changeTopic,
		arg.Title,
		arg.Description,
		arg.ForumcategoryIdforumcategory,
		arg.Idforumtopic,
	)
	return err
}

const commentsSearchFirstInRestrictedTopic = `-- name: CommentsSearchFirstInRestrictedTopic :many
SELECT DISTINCT cs.comments_idcomments
FROM commentsSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
LEFT JOIN comments c ON c.idcomments=cs.comments_idcomments
LEFT JOIN forumthread fth ON fth.idforumthread=c.forumthread_idforumthread
WHERE swl.word=?
AND fth.forumtopic_idforumtopic IN (/*SLICE:ftids*/?)
`

type CommentsSearchFirstInRestrictedTopicParams struct {
	Word  sql.NullString
	Ftids []int32
}

func (q *Queries) CommentsSearchFirstInRestrictedTopic(ctx context.Context, arg CommentsSearchFirstInRestrictedTopicParams) ([]int32, error) {
	query := commentsSearchFirstInRestrictedTopic
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ftids) > 0 {
		for _, v := range arg.Ftids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ftids*/?", strings.Repeat(",?", len(arg.Ftids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ftids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var comments_idcomments int32
		if err := rows.Scan(&comments_idcomments); err != nil {
			return nil, err
		}
		items = append(items, comments_idcomments)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const commentsSearchFirstNotInRestrictedTopic = `-- name: CommentsSearchFirstNotInRestrictedTopic :many
SELECT DISTINCT cs.comments_idcomments
FROM commentsSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
LEFT JOIN comments c ON c.idcomments=cs.comments_idcomments
LEFT JOIN forumthread fth ON fth.idforumthread=c.forumthread_idforumthread
LEFT JOIN forumtopic ft ON ft.idforumtopic=fth.forumtopic_idforumtopic
WHERE swl.word=?
AND ft.forumcategory_idforumcategory!=0
`

func (q *Queries) CommentsSearchFirstNotInRestrictedTopic(ctx context.Context, word sql.NullString) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, commentsSearchFirstNotInRestrictedTopic, word)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var comments_idcomments int32
		if err := rows.Scan(&comments_idcomments); err != nil {
			return nil, err
		}
		items = append(items, comments_idcomments)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const commentsSearchNextInRestrictedTopic = `-- name: CommentsSearchNextInRestrictedTopic :many
SELECT DISTINCT cs.comments_idcomments
FROM commentsSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
LEFT JOIN comments c ON c.idcomments=cs.comments_idcomments
LEFT JOIN forumthread fth ON fth.idforumthread=c.forumthread_idforumthread
WHERE swl.word=?
AND cs.comments_idcomments IN (/*SLICE:ids*/?)
AND fth.forumtopic_idforumtopic IN (/*SLICE:ftids*/?)
`

type CommentsSearchNextInRestrictedTopicParams struct {
	Word  sql.NullString
	Ids   []int32
	Ftids []int32
}

func (q *Queries) CommentsSearchNextInRestrictedTopic(ctx context.Context, arg CommentsSearchNextInRestrictedTopicParams) ([]int32, error) {
	query := commentsSearchNextInRestrictedTopic
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	if len(arg.Ftids) > 0 {
		for _, v := range arg.Ftids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ftids*/?", strings.Repeat(",?", len(arg.Ftids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ftids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var comments_idcomments int32
		if err := rows.Scan(&comments_idcomments); err != nil {
			return nil, err
		}
		items = append(items, comments_idcomments)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const commentsSearchNextNotInRestrictedTopic = `-- name: CommentsSearchNextNotInRestrictedTopic :many
SELECT DISTINCT cs.comments_idcomments
FROM commentsSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
LEFT JOIN comments c ON c.idcomments=cs.comments_idcomments
LEFT JOIN forumthread fth ON fth.idforumthread=c.forumthread_idforumthread
LEFT JOIN forumtopic ft ON ft.idforumtopic=fth.forumtopic_idforumtopic
WHERE swl.word=?
AND cs.comments_idcomments IN (/*SLICE:ids*/?)
AND ft.forumcategory_idforumcategory!=0
`

type CommentsSearchNextNotInRestrictedTopicParams struct {
	Word sql.NullString
	Ids  []int32
}

func (q *Queries) CommentsSearchNextNotInRestrictedTopic(ctx context.Context, arg CommentsSearchNextNotInRestrictedTopicParams) ([]int32, error) {
	query := commentsSearchNextNotInRestrictedTopic
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var comments_idcomments int32
		if err := rows.Scan(&comments_idcomments); err != nil {
			return nil, err
		}
		items = append(items, comments_idcomments)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const completeWordList = `-- name: CompleteWordList :many
SELECT word
FROM searchwordlist
`

// This query selects all words from the "searchwordlist" table and prints them.
func (q *Queries) CompleteWordList(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, completeWordList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var word sql.NullString
		if err := rows.Scan(&word); err != nil {
			return nil, err
		}
		items = append(items, word)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createCategory = `-- name: CreateCategory :exec
INSERT INTO linkerCategory (title) VALUES (?)
`

func (q *Queries) CreateCategory(ctx context.Context, title sql.NullString) error {
	_, err := q.db.ExecContext(ctx, createCategory, title)
	return err
}

const create_category = `-- name: Create_category :exec
INSERT INTO faqCategories (name)
VALUES (?)
`

func (q *Queries) Create_category(ctx context.Context, name sql.NullString) error {
	_, err := q.db.ExecContext(ctx, create_category, name)
	return err
}

const deleteBlogsSearch = `-- name: DeleteBlogsSearch :exec
DELETE FROM blogsSearch
`

// This query deletes all data from the "blogsSearch" table.
func (q *Queries) DeleteBlogsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteBlogsSearch)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM linkerCategory WHERE idlinkerCategory = ?
`

func (q *Queries) DeleteCategory(ctx context.Context, idlinkercategory int32) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, idlinkercategory)
	return err
}

const deleteCommentsSearch = `-- name: DeleteCommentsSearch :exec
DELETE FROM commentsSearch
`

// This query deletes all data from the "commentsSearch" table.
func (q *Queries) DeleteCommentsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteCommentsSearch)
	return err
}

const deleteLinkerSearch = `-- name: DeleteLinkerSearch :exec
DELETE FROM linkerSearch
`

// This query deletes all data from the "linkerSearch" table.
func (q *Queries) DeleteLinkerSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteLinkerSearch)
	return err
}

const deleteQueueItem = `-- name: DeleteQueueItem :exec
DELETE FROM linkerQueue WHERE idlinkerQueue = ?
`

func (q *Queries) DeleteQueueItem(ctx context.Context, idlinkerqueue int32) error {
	_, err := q.db.ExecContext(ctx, deleteQueueItem, idlinkerqueue)
	return err
}

const deleteSiteNewsSearch = `-- name: DeleteSiteNewsSearch :exec
DELETE FROM siteNewsSearch
`

// This query deletes all data from the "siteNewsSearch" table.
func (q *Queries) DeleteSiteNewsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteSiteNewsSearch)
	return err
}

const deleteTopicRestrictions = `-- name: DeleteTopicRestrictions :exec
DELETE FROM topicrestrictions WHERE forumtopic_idforumtopic = ?
`

func (q *Queries) DeleteTopicRestrictions(ctx context.Context, forumtopicIdforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, deleteTopicRestrictions, forumtopicIdforumtopic)
	return err
}

const deleteUsersTopicLevel = `-- name: DeleteUsersTopicLevel :exec
DELETE FROM userstopiclevel WHERE forumtopic_idforumtopic = ? AND users_idusers = ?
`

type DeleteUsersTopicLevelParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
}

func (q *Queries) DeleteUsersTopicLevel(ctx context.Context, arg DeleteUsersTopicLevelParams) error {
	_, err := q.db.ExecContext(ctx, deleteUsersTopicLevel, arg.ForumtopicIdforumtopic, arg.UsersIdusers)
	return err
}

const deleteWritingApproval = `-- name: DeleteWritingApproval :exec
DELETE FROM writtingApprovedUsers
WHERE writing_idwriting = ? AND users_idusers = ?
`

type DeleteWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) DeleteWritingApproval(ctx context.Context, arg DeleteWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, deleteWritingApproval, arg.WritingIdwriting, arg.UsersIdusers)
	return err
}

const deleteWritingSearch = `-- name: DeleteWritingSearch :exec
DELETE FROM writingSearch
`

// This query deletes all data from the "writingSearch" table.
func (q *Queries) DeleteWritingSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteWritingSearch)
	return err
}

const delete_category = `-- name: Delete_category :exec
DELETE FROM faqCategories
WHERE idfaqCategories = ?
`

func (q *Queries) Delete_category(ctx context.Context, idfaqcategories int32) error {
	_, err := q.db.ExecContext(ctx, delete_category, idfaqcategories)
	return err
}

const delete_faq = `-- name: Delete_faq :exec
DELETE FROM faq
WHERE idfaq = ?
`

func (q *Queries) Delete_faq(ctx context.Context, idfaq int32) error {
	_, err := q.db.ExecContext(ctx, delete_faq, idfaq)
	return err
}

const editNewsPost = `-- name: EditNewsPost :exec
UPDATE siteNews SET news = ?, language_idlanguage = ? WHERE idsiteNews = ?
`

type EditNewsPostParams struct {
	News               sql.NullString
	LanguageIdlanguage int32
	Idsitenews         int32
}

func (q *Queries) EditNewsPost(ctx context.Context, arg EditNewsPostParams) error {
	_, err := q.db.ExecContext(ctx, editNewsPost, arg.News, arg.LanguageIdlanguage, arg.Idsitenews)
	return err
}

const faq_categories = `-- name: Faq_categories :many
SELECT idfaqCategories, name
FROM faqCategories
`

func (q *Queries) Faq_categories(ctx context.Context) ([]*Faqcategory, error) {
	rows, err := q.db.QueryContext(ctx, faq_categories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faqcategory
	for rows.Next() {
		var i Faqcategory
		if err := rows.Scan(&i.Idfaqcategories, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAllCategories = `-- name: FetchAllCategories :many
SELECT wc.idwritingcategory, wc.writingcategory_idwritingcategory, wc.title, wc.description
FROM writingCategory wc
`

func (q *Queries) FetchAllCategories(ctx context.Context) ([]*Writingcategory, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Writingcategory
	for rows.Next() {
		var i Writingcategory
		if err := rows.Scan(
			&i.Idwritingcategory,
			&i.WritingcategoryIdwritingcategory,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAllWritingApprovals = `-- name: FetchAllWritingApprovals :many
SELECT idusers, u.username, wau.writing_idwriting, wau.readdoc, wau.editdoc
FROM writtingApprovedUsers wau
LEFT JOIN users u ON idusers = wau.users_idusers
`

type FetchAllWritingApprovalsRow struct {
	Idusers          int32
	Username         sql.NullString
	WritingIdwriting int32
	Readdoc          sql.NullBool
	Editdoc          sql.NullBool
}

func (q *Queries) FetchAllWritingApprovals(ctx context.Context) ([]*FetchAllWritingApprovalsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchAllWritingApprovals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchAllWritingApprovalsRow
	for rows.Next() {
		var i FetchAllWritingApprovalsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Username,
			&i.WritingIdwriting,
			&i.Readdoc,
			&i.Editdoc,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchCategories = `-- name: FetchCategories :many
SELECT idwritingCategory, title, description
FROM writingCategory
WHERE writingCategory_idwritingCategory = ?
`

type FetchCategoriesRow struct {
	Idwritingcategory int32
	Title             sql.NullString
	Description       sql.NullString
}

func (q *Queries) FetchCategories(ctx context.Context, writingcategoryIdwritingcategory int32) ([]*FetchCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchCategories, writingcategoryIdwritingcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchCategoriesRow
	for rows.Next() {
		var i FetchCategoriesRow
		if err := rows.Scan(&i.Idwritingcategory, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPublicWritings = `-- name: FetchPublicWritings :many
SELECT w.title, w.abstract, w.idwriting, w.private, w.writingCategory_idwritingCategory
FROM writing w
WHERE w.private = 0
ORDER BY w.published DESC LIMIT 15
`

type FetchPublicWritingsRow struct {
	Title                            sql.NullString
	Abstract                         sql.NullString
	Idwriting                        int32
	Private                          sql.NullBool
	WritingcategoryIdwritingcategory int32
}

func (q *Queries) FetchPublicWritings(ctx context.Context) ([]*FetchPublicWritingsRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPublicWritings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchPublicWritingsRow
	for rows.Next() {
		var i FetchPublicWritingsRow
		if err := rows.Scan(
			&i.Title,
			&i.Abstract,
			&i.Idwriting,
			&i.Private,
			&i.WritingcategoryIdwritingcategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPublicWritingsInCategory = `-- name: FetchPublicWritingsInCategory :many
SELECT w.idwriting, w.users_idusers, w.forumthread_idforumthread, w.language_idlanguage, w.writingcategory_idwritingcategory, w.title, w.published, w.writting, w.abstract, w.private, u.Username,
    (SELECT COUNT(*) FROM comments c WHERE c.forumthread_idforumthread=w.forumthread_idforumthread AND w.forumthread_idforumthread != 0) as Comments
FROM writing w
LEFT JOIN users u ON w.Users_Idusers=u.idusers
WHERE w.private = 0 AND w.writingCategory_idwritingCategory=?
ORDER BY w.published DESC LIMIT 15
`

type FetchPublicWritingsInCategoryRow struct {
	Idwriting                        int32
	UsersIdusers                     int32
	ForumthreadIdforumthread         int32
	LanguageIdlanguage               int32
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Published                        sql.NullTime
	Writting                         sql.NullString
	Abstract                         sql.NullString
	Private                          sql.NullBool
	Username                         sql.NullString
	Comments                         int64
}

func (q *Queries) FetchPublicWritingsInCategory(ctx context.Context, writingcategoryIdwritingcategory int32) ([]*FetchPublicWritingsInCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchPublicWritingsInCategory, writingcategoryIdwritingcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchPublicWritingsInCategoryRow
	for rows.Next() {
		var i FetchPublicWritingsInCategoryRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadIdforumthread,
			&i.LanguageIdlanguage,
			&i.WritingcategoryIdwritingcategory,
			&i.Title,
			&i.Published,
			&i.Writting,
			&i.Abstract,
			&i.Private,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingApproval = `-- name: FetchWritingApproval :many
SELECT editdoc
FROM writtingApprovedUsers
WHERE writing_idwriting = ? AND users_idusers = ?
`

type FetchWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) FetchWritingApproval(ctx context.Context, arg FetchWritingApprovalParams) ([]sql.NullBool, error) {
	rows, err := q.db.QueryContext(ctx, fetchWritingApproval, arg.WritingIdwriting, arg.UsersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullBool
	for rows.Next() {
		var editdoc sql.NullBool
		if err := rows.Scan(&editdoc); err != nil {
			return nil, err
		}
		items = append(items, editdoc)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchWritingById = `-- name: FetchWritingById :one
SELECT w.idwriting, w.users_idusers, w.forumthread_idforumthread, w.language_idlanguage, w.writingcategory_idwritingcategory, w.title, w.published, w.writting, w.abstract, w.private, u.idusers AS WriterId, u.Username AS WriterUsername
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN writtingApprovedUsers wau ON w.idwriting = wau.writing_idwriting AND wau.users_idusers = ?
WHERE w.idwriting = ? AND (w.private = 0 OR wau.readdoc = 1 OR w.users_idusers = ?)
ORDER BY w.published DESC
`

type FetchWritingByIdParams struct {
	Userid    int32
	Idwriting int32
}

type FetchWritingByIdRow struct {
	Idwriting                        int32
	UsersIdusers                     int32
	ForumthreadIdforumthread         int32
	LanguageIdlanguage               int32
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Published                        sql.NullTime
	Writting                         sql.NullString
	Abstract                         sql.NullString
	Private                          sql.NullBool
	Writerid                         int32
	Writerusername                   sql.NullString
}

func (q *Queries) FetchWritingById(ctx context.Context, arg FetchWritingByIdParams) (*FetchWritingByIdRow, error) {
	row := q.db.QueryRowContext(ctx, fetchWritingById, arg.Userid, arg.Idwriting, arg.Userid)
	var i FetchWritingByIdRow
	err := row.Scan(
		&i.Idwriting,
		&i.UsersIdusers,
		&i.ForumthreadIdforumthread,
		&i.LanguageIdlanguage,
		&i.WritingcategoryIdwritingcategory,
		&i.Title,
		&i.Published,
		&i.Writting,
		&i.Abstract,
		&i.Private,
		&i.Writerid,
		&i.Writerusername,
	)
	return &i, err
}

const fetchWritingByIds = `-- name: FetchWritingByIds :many
SELECT w.idwriting, w.users_idusers, w.forumthread_idforumthread, w.language_idlanguage, w.writingcategory_idwritingcategory, w.title, w.published, w.writting, w.abstract, w.private, u.idusers AS WriterId, u.username AS WriterUsername
FROM writing w
JOIN users u ON w.users_idusers = u.idusers
LEFT JOIN writtingApprovedUsers wau ON w.idwriting = wau.writing_idwriting AND wau.users_idusers = ?
WHERE w.idwriting IN (/*SLICE:writingids*/?) AND (w.private = 0 OR wau.readdoc = 1 OR w.users_idusers = ?)
ORDER BY w.published DESC
`

type FetchWritingByIdsParams struct {
	Userid     int32
	Writingids []int32
}

type FetchWritingByIdsRow struct {
	Idwriting                        int32
	UsersIdusers                     int32
	ForumthreadIdforumthread         int32
	LanguageIdlanguage               int32
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Published                        sql.NullTime
	Writting                         sql.NullString
	Abstract                         sql.NullString
	Private                          sql.NullBool
	Writerid                         int32
	Writerusername                   sql.NullString
}

func (q *Queries) FetchWritingByIds(ctx context.Context, arg FetchWritingByIdsParams) ([]*FetchWritingByIdsRow, error) {
	query := fetchWritingByIds
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Userid)
	if len(arg.Writingids) > 0 {
		for _, v := range arg.Writingids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:writingids*/?", strings.Repeat(",?", len(arg.Writingids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:writingids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Userid)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FetchWritingByIdsRow
	for rows.Next() {
		var i FetchWritingByIdsRow
		if err := rows.Scan(
			&i.Idwriting,
			&i.UsersIdusers,
			&i.ForumthreadIdforumthread,
			&i.LanguageIdlanguage,
			&i.WritingcategoryIdwritingcategory,
			&i.Title,
			&i.Published,
			&i.Writting,
			&i.Abstract,
			&i.Private,
			&i.Writerid,
			&i.Writerusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findForumTopicByName = `-- name: FindForumTopicByName :one
SELECT idforumtopic FROM forumtopic WHERE title=?
`

func (q *Queries) FindForumTopicByName(ctx context.Context, title sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, findForumTopicByName, title)
	var idforumtopic int32
	err := row.Scan(&idforumtopic)
	return idforumtopic, err
}

const forumCategories = `-- name: ForumCategories :many
SELECT f.idforumcategory, f.forumcategory_idforumcategory, f.title, f.description
FROM forumcategory f
`

func (q *Queries) ForumCategories(ctx context.Context) ([]*Forumcategory, error) {
	rows, err := q.db.QueryContext(ctx, forumCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumcategory
	for rows.Next() {
		var i Forumcategory
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTopicRestrictions = `-- name: GetAllTopicRestrictions :many
SELECT idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, t.title, r.forumtopic_idforumtopic, r.modlevel, r.adminlevel
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
`

type GetAllTopicRestrictionsRow struct {
	Idforumtopic           int32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Title                  sql.NullString
	ForumtopicIdforumtopic sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) GetAllTopicRestrictions(ctx context.Context) ([]*GetAllTopicRestrictionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllTopicRestrictions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllTopicRestrictionsRow
	for rows.Next() {
		var i GetAllTopicRestrictionsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Title,
			&i.ForumtopicIdforumtopic,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTopics = `-- name: GetAllTopics :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition
FROM forumtopic t
LEFT JOIN forumcategory c ON t.forumcategory_idforumcategory = c.idforumcategory
GROUP BY t.idforumtopic
`

func (q *Queries) GetAllTopics(ctx context.Context) ([]*Forumtopic, error) {
	rows, err := q.db.QueryContext(ctx, getAllTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Forumtopic
	for rows.Next() {
		var i Forumtopic
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersAllTopicLevels = `-- name: GetAllUsersAllTopicLevels :many
SELECT u.idusers, u.email, u.passwd, u.username, t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, utl.users_idusers, utl.forumtopic_idforumtopic, utl.level, utl.invitemax, tr.forumtopic_idforumtopic, tr.viewlevel, tr.replylevel, tr.newthreadlevel, tr.seelevel, tr.invitelevel, tr.readlevel, tr.modlevel, tr.adminlevel
FROM users u
JOIN userstopiclevel utl ON utl.users_idusers=u.idusers
JOIN forumtopic t ON utl.forumtopic_idforumtopic = t.idforumtopic
LEFT JOIN topicrestrictions tr ON t.idforumtopic = tr.forumtopic_idforumtopic
`

type GetAllUsersAllTopicLevelsRow struct {
	Idusers                      int32
	Email                        sql.NullString
	Passwd                       sql.NullString
	Username                     sql.NullString
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	UsersIdusers                 int32
	ForumtopicIdforumtopic       int32
	Level                        sql.NullInt32
	Invitemax                    sql.NullInt32
	ForumtopicIdforumtopic_2     sql.NullInt32
	Viewlevel                    sql.NullInt32
	Replylevel                   sql.NullInt32
	Newthreadlevel               sql.NullInt32
	Seelevel                     sql.NullInt32
	Invitelevel                  sql.NullInt32
	Readlevel                    sql.NullInt32
	Modlevel                     sql.NullInt32
	Adminlevel                   sql.NullInt32
}

func (q *Queries) GetAllUsersAllTopicLevels(ctx context.Context) ([]*GetAllUsersAllTopicLevelsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersAllTopicLevels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAllUsersAllTopicLevelsRow
	for rows.Next() {
		var i GetAllUsersAllTopicLevelsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.UsersIdusers,
			&i.ForumtopicIdforumtopic,
			&i.Level,
			&i.Invitemax,
			&i.ForumtopicIdforumtopic_2,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlogs = `-- name: GetBlogs :many
SELECT b.idblogs, b.forumthread_idforumthread, b.users_idusers, b.language_idlanguage, b.blog, b.written
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE b.idblogs IN (/*SLICE:blogids*/?)
ORDER BY b.written DESC
`

// WHERE (b.language_idlanguage = sqlc.arg(Language_idlanguage) OR sqlc.arg(Language_idlanguage) = 0)
// AND (b.users_idusers = sqlc.arg(Users_idusers) OR sqlc.arg(Users_idusers) = 0)
// AND b.idblogs IN (sqlc.slice(blogIds))
// LIMIT ? OFFSET ?
func (q *Queries) GetBlogs(ctx context.Context, blogids []int32) ([]*Blog, error) {
	query := getBlogs
	var queryParams []interface{}
	if len(blogids) > 0 {
		for _, v := range blogids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:blogids*/?", strings.Repeat(",?", len(blogids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:blogids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Blog
	for rows.Next() {
		var i Blog
		if err := rows.Scan(
			&i.Idblogs,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Blog,
			&i.Written,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComment = `-- name: GetComment :one
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text
FROM comments c
WHERE c.Idcomments=?
`

func (q *Queries) GetComment(ctx context.Context, idcomments int32) (*Comment, error) {
	row := q.db.QueryRowContext(ctx, getComment, idcomments)
	var i Comment
	err := row.Scan(
		&i.Idcomments,
		&i.ForumthreadIdforumthread,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Written,
		&i.Text,
	)
	return &i, err
}

const getComments = `-- name: GetComments :many
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text
FROM comments c
WHERE c.Idcomments IN (/*SLICE:ids*/?)
`

func (q *Queries) GetComments(ctx context.Context, ids []int32) ([]*Comment, error) {
	query := getComments
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsWithThreadInfo = `-- name: GetCommentsWithThreadInfo :many
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text, pu.username AS posterusername, th.idforumthread, t.idforumtopic, t.title AS forumtopic_title, fc.idforumcategory, fc.title AS forumcategory_title
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_idforumthread=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users pu ON pu.idusers = c.users_idusers
LEFT JOIN forumcategory fc ON t.forumcategory_idforumcategory = fc.idforumcategory
WHERE c.Idcomments IN (/*SLICE:ids*/?)
ORDER BY c.written DESC
`

type GetCommentsWithThreadInfoParams struct {
	UsersIdusers int32
	Ids          []int32
}

type GetCommentsWithThreadInfoRow struct {
	Idcomments               int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Written                  sql.NullTime
	Text                     sql.NullString
	Posterusername           sql.NullString
	Idforumthread            sql.NullInt32
	Idforumtopic             sql.NullInt32
	ForumtopicTitle          sql.NullString
	Idforumcategory          sql.NullInt32
	ForumcategoryTitle       sql.NullString
}

func (q *Queries) GetCommentsWithThreadInfo(ctx context.Context, arg GetCommentsWithThreadInfoParams) ([]*GetCommentsWithThreadInfoRow, error) {
	query := getCommentsWithThreadInfo
	var queryParams []interface{}
	queryParams = append(queryParams, arg.UsersIdusers)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCommentsWithThreadInfoRow
	for rows.Next() {
		var i GetCommentsWithThreadInfoRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.Posterusername,
			&i.Idforumthread,
			&i.Idforumtopic,
			&i.ForumtopicTitle,
			&i.Idforumcategory,
			&i.ForumcategoryTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestNewsPosts = `-- name: GetLatestNewsPosts :many
SELECT u.username AS writerName, u.idusers as writerId, s.idsitenews, s.forumthread_idforumthread, s.language_idlanguage, s.users_idusers, s.news, s.occured, th.comments as Comments
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_idforumthread = th.idforumthread
ORDER BY s.occured DESC
LIMIT 15
`

type GetLatestNewsPostsRow struct {
	Writername               sql.NullString
	Writerid                 sql.NullInt32
	Idsitenews               int32
	ForumthreadIdforumthread int32
	LanguageIdlanguage       int32
	UsersIdusers             int32
	News                     sql.NullString
	Occured                  sql.NullTime
	Comments                 sql.NullInt32
}

func (q *Queries) GetLatestNewsPosts(ctx context.Context) ([]*GetLatestNewsPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestNewsPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetLatestNewsPostsRow
	for rows.Next() {
		var i GetLatestNewsPostsRow
		if err := rows.Scan(
			&i.Writername,
			&i.Writerid,
			&i.Idsitenews,
			&i.ForumthreadIdforumthread,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.News,
			&i.Occured,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsPost = `-- name: GetNewsPost :one
SELECT u.username AS writerName, u.idusers as writerId, s.idsitenews, s.forumthread_idforumthread, s.language_idlanguage, s.users_idusers, s.news, s.occured, th.comments as Comments
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_idforumthread = th.idforumthread
WHERE s.idsiteNews = ?
`

type GetNewsPostRow struct {
	Writername               sql.NullString
	Writerid                 sql.NullInt32
	Idsitenews               int32
	ForumthreadIdforumthread int32
	LanguageIdlanguage       int32
	UsersIdusers             int32
	News                     sql.NullString
	Occured                  sql.NullTime
	Comments                 sql.NullInt32
}

func (q *Queries) GetNewsPost(ctx context.Context, idsitenews int32) (*GetNewsPostRow, error) {
	row := q.db.QueryRowContext(ctx, getNewsPost, idsitenews)
	var i GetNewsPostRow
	err := row.Scan(
		&i.Writername,
		&i.Writerid,
		&i.Idsitenews,
		&i.ForumthreadIdforumthread,
		&i.LanguageIdlanguage,
		&i.UsersIdusers,
		&i.News,
		&i.Occured,
		&i.Comments,
	)
	return &i, err
}

const getNewsPosts = `-- name: GetNewsPosts :many
SELECT u.username AS writerName, u.idusers as writerId, s.idsitenews, s.forumthread_idforumthread, s.language_idlanguage, s.users_idusers, s.news, s.occured, th.comments as Comments
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_idforumthread = th.idforumthread
WHERE s.Idsitenews IN (/*SLICE:newsids*/?)
`

type GetNewsPostsRow struct {
	Writername               sql.NullString
	Writerid                 sql.NullInt32
	Idsitenews               int32
	ForumthreadIdforumthread int32
	LanguageIdlanguage       int32
	UsersIdusers             int32
	News                     sql.NullString
	Occured                  sql.NullTime
	Comments                 sql.NullInt32
}

func (q *Queries) GetNewsPosts(ctx context.Context, newsids []int32) ([]*GetNewsPostsRow, error) {
	query := getNewsPosts
	var queryParams []interface{}
	if len(newsids) > 0 {
		for _, v := range newsids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:newsids*/?", strings.Repeat(",?", len(newsids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:newsids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNewsPostsRow
	for rows.Next() {
		var i GetNewsPostsRow
		if err := rows.Scan(
			&i.Writername,
			&i.Writerid,
			&i.Idsitenews,
			&i.ForumthreadIdforumthread,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.News,
			&i.Occured,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewsThreadId = `-- name: GetNewsThreadId :one
SELECT s.forumthread_idforumthread, u.idusers
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
WHERE s.idsiteNews = ?
`

type GetNewsThreadIdRow struct {
	ForumthreadIdforumthread int32
	Idusers                  sql.NullInt32
}

func (q *Queries) GetNewsThreadId(ctx context.Context, idsitenews int32) (*GetNewsThreadIdRow, error) {
	row := q.db.QueryRowContext(ctx, getNewsThreadId, idsitenews)
	var i GetNewsThreadIdRow
	err := row.Scan(&i.ForumthreadIdforumthread, &i.Idusers)
	return &i, err
}

const getSecurityLevel = `-- name: GetSecurityLevel :one
SELECT level FROM permissions WHERE users_idusers = ? AND (section = ? OR section = 'all')
`

type GetSecurityLevelParams struct {
	UsersIdusers int32
	Section      sql.NullString
}

func (q *Queries) GetSecurityLevel(ctx context.Context, arg GetSecurityLevelParams) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getSecurityLevel, arg.UsersIdusers, arg.Section)
	var level sql.NullString
	err := row.Scan(&level)
	return level, err
}

const getTopicRestrictions = `-- name: GetTopicRestrictions :many
SELECT idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, t.title, r.forumtopic_idforumtopic, r.modlevel, r.adminlevel
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
WHERE idforumtopic = ?
`

type GetTopicRestrictionsRow struct {
	Idforumtopic           int32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Title                  sql.NullString
	ForumtopicIdforumtopic sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) GetTopicRestrictions(ctx context.Context, idforumtopic int32) ([]*GetTopicRestrictionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopicRestrictions, idforumtopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTopicRestrictionsRow
	for rows.Next() {
		var i GetTopicRestrictionsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Title,
			&i.ForumtopicIdforumtopic,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPermissions = `-- name: GetUserPermissions :one
SELECT p.idpermissions, p.users_idusers, p.section, p.level
FROM permissions p
WHERE p.users_idusers = ?
`

// This query selects permissions information for admin users.
// Result:
//
//	idpermissions (int)
//	level (int)
//	username (string)
//	email (string)
//	section (string)
func (q *Queries) GetUserPermissions(ctx context.Context, usersIdusers int32) (*Permission, error) {
	row := q.db.QueryRowContext(ctx, getUserPermissions, usersIdusers)
	var i Permission
	err := row.Scan(
		&i.Idpermissions,
		&i.UsersIdusers,
		&i.Section,
		&i.Level,
	)
	return &i, err
}

const getUsersAllTopicLevels = `-- name: GetUsersAllTopicLevels :many
SELECT u.idusers, u.email, u.passwd, u.username, t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, utl.users_idusers, utl.forumtopic_idforumtopic, utl.level, utl.invitemax, tr.forumtopic_idforumtopic, tr.viewlevel, tr.replylevel, tr.newthreadlevel, tr.seelevel, tr.invitelevel, tr.readlevel, tr.modlevel, tr.adminlevel
FROM users u
JOIN userstopiclevel utl ON utl.users_idusers=u.idusers
JOIN forumtopic t ON utl.forumtopic_idforumtopic = t.idforumtopic
JOIN topicrestrictions tr ON t.idforumtopic = tr.forumtopic_idforumtopic
WHERE u.idusers = ?
`

type GetUsersAllTopicLevelsRow struct {
	Idusers                      int32
	Email                        sql.NullString
	Passwd                       sql.NullString
	Username                     sql.NullString
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	UsersIdusers                 int32
	ForumtopicIdforumtopic       int32
	Level                        sql.NullInt32
	Invitemax                    sql.NullInt32
	ForumtopicIdforumtopic_2     int32
	Viewlevel                    sql.NullInt32
	Replylevel                   sql.NullInt32
	Newthreadlevel               sql.NullInt32
	Seelevel                     sql.NullInt32
	Invitelevel                  sql.NullInt32
	Readlevel                    sql.NullInt32
	Modlevel                     sql.NullInt32
	Adminlevel                   sql.NullInt32
}

func (q *Queries) GetUsersAllTopicLevels(ctx context.Context, idusers int32) ([]*GetUsersAllTopicLevelsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersAllTopicLevels, idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUsersAllTopicLevelsRow
	for rows.Next() {
		var i GetUsersAllTopicLevelsRow
		if err := rows.Scan(
			&i.Idusers,
			&i.Email,
			&i.Passwd,
			&i.Username,
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.UsersIdusers,
			&i.ForumtopicIdforumtopic,
			&i.Level,
			&i.Invitemax,
			&i.ForumtopicIdforumtopic_2,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersPermissions = `-- name: GetUsersPermissions :many
SELECT p.idpermissions, p.users_idusers, p.section, p.level
FROM permissions p
`

// This query selects permissions information for admin users.
// Result:
//
//	idpermissions (int)
//	level (int)
//	username (string)
//	email (string)
//	section (string)
func (q *Queries) GetUsersPermissions(ctx context.Context) ([]*Permission, error) {
	rows, err := q.db.QueryContext(ctx, getUsersPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.Idpermissions,
			&i.UsersIdusers,
			&i.Section,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersTopicLevel = `-- name: GetUsersTopicLevel :one
SELECT utl.users_idusers, utl.forumtopic_idforumtopic, utl.level, utl.invitemax
FROM userstopiclevel utl
WHERE utl.users_idusers = ? AND utl.forumtopic_idforumtopic = ?
`

type GetUsersTopicLevelParams struct {
	UsersIdusers           int32
	ForumtopicIdforumtopic int32
}

// This query selects permissions information for admin users.
// Result:
//
//	idpermissions (int)
//	level (int)
//	username (string)
//	email (string)
//	section (string)
func (q *Queries) GetUsersTopicLevel(ctx context.Context, arg GetUsersTopicLevelParams) (*Userstopiclevel, error) {
	row := q.db.QueryRowContext(ctx, getUsersTopicLevel, arg.UsersIdusers, arg.ForumtopicIdforumtopic)
	var i Userstopiclevel
	err := row.Scan(
		&i.UsersIdusers,
		&i.ForumtopicIdforumtopic,
		&i.Level,
		&i.Invitemax,
	)
	return &i, err
}

const getWordID = `-- name: GetWordID :one
SELECT idsearchwordlist FROM searchwordlist WHERE word = lcase(?)
`

func (q *Queries) GetWordID(ctx context.Context, lcase string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getWordID, lcase)
	var idsearchwordlist int32
	err := row.Scan(&idsearchwordlist)
	return idsearchwordlist, err
}

const get_all_user_topics = `-- name: Get_all_user_topics :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY t.lastaddition DESC
`

type Get_all_user_topicsRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
	Seelevel                     sql.NullInt32
	Level                        sql.NullInt32
}

func (q *Queries) Get_all_user_topics(ctx context.Context, usersIdusers int32) ([]*Get_all_user_topicsRow, error) {
	rows, err := q.db.QueryContext(ctx, get_all_user_topics, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Get_all_user_topicsRow
	for rows.Next() {
		var i Get_all_user_topicsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Lastposterusername,
			&i.Seelevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const get_all_user_topics_for_category = `-- name: Get_all_user_topics_for_category :many
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE t.forumcategory_idforumcategory = ? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY t.lastaddition DESC
`

type Get_all_user_topics_for_categoryParams struct {
	UsersIdusers                 int32
	ForumcategoryIdforumcategory int32
}

type Get_all_user_topics_for_categoryRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
	Seelevel                     sql.NullInt32
	Level                        sql.NullInt32
}

func (q *Queries) Get_all_user_topics_for_category(ctx context.Context, arg Get_all_user_topics_for_categoryParams) ([]*Get_all_user_topics_for_categoryRow, error) {
	rows, err := q.db.QueryContext(ctx, get_all_user_topics_for_category, arg.UsersIdusers, arg.ForumcategoryIdforumcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Get_all_user_topics_for_categoryRow
	for rows.Next() {
		var i Get_all_user_topics_for_categoryRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Lastposter,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Threads,
			&i.Comments,
			&i.Lastaddition,
			&i.Lastposterusername,
			&i.Seelevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const imageboardRSS = `-- name: ImageboardRSS :exec
SELECT title, description FROM imageboard WHERE idimageboard = ?
`

type ImageboardRSSRow struct {
	Title       sql.NullString
	Description sql.NullString
}

func (q *Queries) ImageboardRSS(ctx context.Context, idimageboard int32) error {
	_, err := q.db.ExecContext(ctx, imageboardRSS, idimageboard)
	return err
}

const insertUser = `-- name: InsertUser :execresult
INSERT INTO users (username, passwd, email)
VALUES (?, MD5(?), ?)
`

type InsertUserParams struct {
	Username sql.NullString
	MD5      string
	Email    sql.NullString
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertUser, arg.Username, arg.MD5, arg.Email)
}

const insertWriting = `-- name: InsertWriting :execlastid
INSERT INTO writing (writingCategory_idwritingCategory, title, abstract, writting, private, language_idlanguage, published, users_idusers)
VALUES (?, ?, ?, ?, ?, ?, NOW(), ?)
`

type InsertWritingParams struct {
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Abstract                         sql.NullString
	Writting                         sql.NullString
	Private                          sql.NullBool
	LanguageIdlanguage               int32
	UsersIdusers                     int32
}

func (q *Queries) InsertWriting(ctx context.Context, arg InsertWritingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertWriting,
		arg.WritingcategoryIdwritingcategory,
		arg.Title,
		arg.Abstract,
		arg.Writting,
		arg.Private,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertWritingApproval = `-- name: InsertWritingApproval :exec
INSERT INTO writtingApprovedUsers (writing_idwriting, users_idusers, readdoc, editdoc)
VALUES (?, ?, ?, ?)
`

type InsertWritingApprovalParams struct {
	WritingIdwriting int32
	UsersIdusers     int32
	Readdoc          sql.NullBool
	Editdoc          sql.NullBool
}

func (q *Queries) InsertWritingApproval(ctx context.Context, arg InsertWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, insertWritingApproval,
		arg.WritingIdwriting,
		arg.UsersIdusers,
		arg.Readdoc,
		arg.Editdoc,
	)
	return err
}

const insertWritingCategory = `-- name: InsertWritingCategory :exec
INSERT INTO writingCategory (writingCategory_idwritingCategory, title, description)
VALUES (?, ?, ?)
`

type InsertWritingCategoryParams struct {
	WritingcategoryIdwritingcategory int32
	Title                            sql.NullString
	Description                      sql.NullString
}

func (q *Queries) InsertWritingCategory(ctx context.Context, arg InsertWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, insertWritingCategory, arg.WritingcategoryIdwritingcategory, arg.Title, arg.Description)
	return err
}

const linkerSearchFirst = `-- name: LinkerSearchFirst :many
SELECT DISTINCT cs.linker_idlinker
FROM linkerSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
`

func (q *Queries) LinkerSearchFirst(ctx context.Context, word sql.NullString) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, linkerSearchFirst, word)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var linker_idlinker int32
		if err := rows.Scan(&linker_idlinker); err != nil {
			return nil, err
		}
		items = append(items, linker_idlinker)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkerSearchNext = `-- name: LinkerSearchNext :many
SELECT DISTINCT cs.linker_idlinker
FROM linkerSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
AND cs.linker_idlinker IN (/*SLICE:ids*/?)
`

type LinkerSearchNextParams struct {
	Word sql.NullString
	Ids  []int32
}

func (q *Queries) LinkerSearchNext(ctx context.Context, arg LinkerSearchNextParams) ([]int32, error) {
	query := linkerSearchNext
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var linker_idlinker int32
		if err := rows.Scan(&linker_idlinker); err != nil {
			return nil, err
		}
		items = append(items, linker_idlinker)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const login = `-- name: Login :one
SELECT idusers, email, passwd, username
FROM users
WHERE username = ? AND passwd = md5(?)
`

type LoginParams struct {
	Username sql.NullString
	MD5      string
}

func (q *Queries) Login(ctx context.Context, arg LoginParams) (*User, error) {
	row := q.db.QueryRowContext(ctx, login, arg.Username, arg.MD5)
	var i User
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.Username,
	)
	return &i, err
}

const makeCategory = `-- name: MakeCategory :exec
INSERT INTO forumcategory (forumcategory_idforumcategory, title, description) VALUES (?, ?, ?)
`

type MakeCategoryParams struct {
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) MakeCategory(ctx context.Context, arg MakeCategoryParams) error {
	_, err := q.db.ExecContext(ctx, makeCategory, arg.ForumcategoryIdforumcategory, arg.Title, arg.Description)
	return err
}

const makeImageBoard = `-- name: MakeImageBoard :exec
INSERT INTO imageboard (imageboard_idimageboard, title, description) VALUES (?, ?, ?)
`

type MakeImageBoardParams struct {
	ImageboardIdimageboard int32
	Title                  sql.NullString
	Description            sql.NullString
}

func (q *Queries) MakeImageBoard(ctx context.Context, arg MakeImageBoardParams) error {
	_, err := q.db.ExecContext(ctx, makeImageBoard, arg.ImageboardIdimageboard, arg.Title, arg.Description)
	return err
}

const makePost = `-- name: MakePost :execlastid
INSERT INTO comments (language_idlanguage, users_idusers, forumthread_idforumthread, text, written)
VALUES (?, ?, ?, ?, NOW())
`

type MakePostParams struct {
	LanguageIdlanguage       int32
	UsersIdusers             int32
	ForumthreadIdforumthread int32
	Text                     sql.NullString
}

func (q *Queries) MakePost(ctx context.Context, arg MakePostParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, makePost,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
		arg.ForumthreadIdforumthread,
		arg.Text,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const makeThread = `-- name: MakeThread :execlastid
;

INSERT INTO forumthread (forumtopic_idforumtopic) VALUES (?)
`

func (q *Queries) MakeThread(ctx context.Context, forumtopicIdforumtopic int32) (int64, error) {
	result, err := q.db.ExecContext(ctx, makeThread, forumtopicIdforumtopic)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const makeTopic = `-- name: MakeTopic :execlastid
INSERT INTO forumtopic (forumcategory_idforumcategory, title, description) VALUES (?, ?, ?)
`

type MakeTopicParams struct {
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) MakeTopic(ctx context.Context, arg MakeTopicParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, makeTopic, arg.ForumcategoryIdforumcategory, arg.Title, arg.Description)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const modify_faq = `-- name: Modify_faq :exec
UPDATE faq
SET answer = ?, question = ?, faqCategories_idfaqCategories = ?
WHERE idfaq = ?
`

type Modify_faqParams struct {
	Answer                       sql.NullString
	Question                     sql.NullString
	FaqcategoriesIdfaqcategories int32
	Idfaq                        int32
}

func (q *Queries) Modify_faq(ctx context.Context, arg Modify_faqParams) error {
	_, err := q.db.ExecContext(ctx, modify_faq,
		arg.Answer,
		arg.Question,
		arg.FaqcategoriesIdfaqcategories,
		arg.Idfaq,
	)
	return err
}

const moveToLinker = `-- name: MoveToLinker :exec
INSERT INTO linker (users_idusers, linkerCategory_idlinkerCategory, language_idlanguage, title, ` + "`" + `url` + "`" + `, description)
SELECT l.users_idusers, l.linkerCategory_idlinkerCategory, l.language_idlanguage, l.title, l.url, l.description
FROM linkerQueue l
WHERE l.idlinkerQueue = ?
`

func (q *Queries) MoveToLinker(ctx context.Context, idlinkerqueue int32) error {
	_, err := q.db.ExecContext(ctx, moveToLinker, idlinkerqueue)
	return err
}

const printImagePost = `-- name: PrintImagePost :one
SELECT i.idimagepost, i.forumthread_idforumthread, i.users_idusers, i.imageboard_idimageboard, i.posted, i.description, i.thumbnail, i.fullimage, u.username, th.comments
FROM imagepost i
LEFT JOIN users u ON i.users_idusers = u.idusers
LEFT JOIN forumthread th ON i.forumthread_idforumthread = th.idforumthread
WHERE i.idimagepost = ?
`

type PrintImagePostRow struct {
	Idimagepost              int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	ImageboardIdimageboard   int32
	Posted                   sql.NullTime
	Description              sql.NullString
	Thumbnail                sql.NullString
	Fullimage                sql.NullString
	Username                 sql.NullString
	Comments                 sql.NullInt32
}

func (q *Queries) PrintImagePost(ctx context.Context, idimagepost int32) (*PrintImagePostRow, error) {
	row := q.db.QueryRowContext(ctx, printImagePost, idimagepost)
	var i PrintImagePostRow
	err := row.Scan(
		&i.Idimagepost,
		&i.ForumthreadIdforumthread,
		&i.UsersIdusers,
		&i.ImageboardIdimageboard,
		&i.Posted,
		&i.Description,
		&i.Thumbnail,
		&i.Fullimage,
		&i.Username,
		&i.Comments,
	)
	return &i, err
}

const printImagePosts = `-- name: PrintImagePosts :many
SELECT i.idimagepost, i.forumthread_idforumthread, i.users_idusers, i.imageboard_idimageboard, i.posted, i.description, i.thumbnail, i.fullimage, u.username, th.comments
FROM imagepost i
LEFT JOIN users u ON i.users_idusers = u.idusers
LEFT JOIN forumthread th ON i.forumthread_idforumthread = th.idforumthread
WHERE i.imageboard_idimageboard = ?
`

type PrintImagePostsRow struct {
	Idimagepost              int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	ImageboardIdimageboard   int32
	Posted                   sql.NullTime
	Description              sql.NullString
	Thumbnail                sql.NullString
	Fullimage                sql.NullString
	Username                 sql.NullString
	Comments                 sql.NullInt32
}

func (q *Queries) PrintImagePosts(ctx context.Context, imageboardIdimageboard int32) ([]*PrintImagePostsRow, error) {
	rows, err := q.db.QueryContext(ctx, printImagePosts, imageboardIdimageboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*PrintImagePostsRow
	for rows.Next() {
		var i PrintImagePostsRow
		if err := rows.Scan(
			&i.Idimagepost,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.ImageboardIdimageboard,
			&i.Posted,
			&i.Description,
			&i.Thumbnail,
			&i.Fullimage,
			&i.Username,
			&i.Comments,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printSubBoards = `-- name: PrintSubBoards :many
SELECT idimageboard, title, description FROM imageboard WHERE imageboard_idimageboard = ?
`

type PrintSubBoardsRow struct {
	Idimageboard int32
	Title        sql.NullString
	Description  sql.NullString
}

func (q *Queries) PrintSubBoards(ctx context.Context, imageboardIdimageboard int32) ([]*PrintSubBoardsRow, error) {
	rows, err := q.db.QueryContext(ctx, printSubBoards, imageboardIdimageboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*PrintSubBoardsRow
	for rows.Next() {
		var i PrintSubBoardsRow
		if err := rows.Scan(&i.Idimageboard, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const remakeBlogSearch = `-- name: RemakeBlogSearch :exec
INSERT INTO blogsSearch (text, blogs_idblogs)
SELECT blog, idblogs
FROM blogs
`

// This query selects data from the "blogs" table and populates the "blogsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "blogsSearch" using the "blogs_idblogs".
func (q *Queries) RemakeBlogSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeBlogSearch)
	return err
}

const remakeBlogsSearchInsert = `-- name: RemakeBlogsSearchInsert :exec
INSERT INTO blogsSearch (text, blogs_idblogs)
SELECT blog, idblogs
FROM blogs
`

// This query selects data from the "blogs" table and populates the "blogsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "blogsSearch" using the "blogs_idblogs".
func (q *Queries) RemakeBlogsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeBlogsSearchInsert)
	return err
}

const remakeCommentsSearch = `-- name: RemakeCommentsSearch :exec
INSERT INTO commentsSearch (text, comments_idcomments)
SELECT text, idcomments
FROM comments
`

// This query selects data from the "comments" table and populates the "commentsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "commentsSearch" using the "comments_idcomments".
func (q *Queries) RemakeCommentsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeCommentsSearch)
	return err
}

const remakeCommentsSearchInsert = `-- name: RemakeCommentsSearchInsert :exec
INSERT INTO commentsSearch (text, comments_idcomments)
SELECT text, idcomments
FROM comments
`

// This query selects data from the "comments" table and populates the "commentsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "commentsSearch" using the "comments_idcomments".
func (q *Queries) RemakeCommentsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeCommentsSearchInsert)
	return err
}

const remakeLinkerSearch = `-- name: RemakeLinkerSearch :exec
INSERT INTO linkerSearch (text, linker_idlinker)
SELECT CONCAT(title, ' ', description), idlinker
FROM linker
`

// This query selects data from the "linker" table and populates the "linkerSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "linkerSearch" using the "linker_idlinker".
func (q *Queries) RemakeLinkerSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeLinkerSearch)
	return err
}

const remakeLinkerSearchInsert = `-- name: RemakeLinkerSearchInsert :exec
INSERT INTO linkerSearch (text, linker_idlinker)
SELECT CONCAT(title, ' ', description), idlinker
FROM linker
`

// This query selects data from the "linker" table and populates the "linkerSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "linkerSearch" using the "linker_idlinker".
func (q *Queries) RemakeLinkerSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeLinkerSearchInsert)
	return err
}

const remakeNewsSearch = `-- name: RemakeNewsSearch :exec
INSERT INTO siteNewsSearch (text, siteNews_idsiteNews)
SELECT news, idsiteNews
FROM siteNews
`

// This query selects data from the "siteNews" table and populates the "siteNewsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "siteNewsSearch" using the "siteNews_idsiteNews".
func (q *Queries) RemakeNewsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeNewsSearch)
	return err
}

const remakeNewsSearchInsert = `-- name: RemakeNewsSearchInsert :exec
INSERT INTO siteNewsSearch (text, siteNews_idsiteNews)
SELECT news, idsiteNews
FROM siteNews
`

// This query selects data from the "siteNews" table and populates the "siteNewsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "siteNewsSearch" using the "siteNews_idsiteNews".
func (q *Queries) RemakeNewsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeNewsSearchInsert)
	return err
}

const remakeWritingSearch = `-- name: RemakeWritingSearch :exec
INSERT INTO writingSearch (text, writing_idwriting)
SELECT CONCAT(title, ' ', abstract, ' ', writting), idwriting
FROM writing
`

// This query selects data from the "writing" table and populates the "writingSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "writingSearch" using the "writing_idwriting".
func (q *Queries) RemakeWritingSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeWritingSearch)
	return err
}

const remakeWritingSearchInsert = `-- name: RemakeWritingSearchInsert :exec
INSERT INTO writingSearch (text, writing_idwriting)
SELECT CONCAT(title, ' ', abstract, ' ', writting), idwriting
FROM writing
`

// This query selects data from the "writing" table and populates the "writingSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "writingSearch" using the "writing_idwriting".
func (q *Queries) RemakeWritingSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeWritingSearchInsert)
	return err
}

const renameCategory = `-- name: RenameCategory :exec
UPDATE linkerCategory SET title = ? WHERE idlinkerCategory = ?
`

type RenameCategoryParams struct {
	Title            sql.NullString
	Idlinkercategory int32
}

func (q *Queries) RenameCategory(ctx context.Context, arg RenameCategoryParams) error {
	_, err := q.db.ExecContext(ctx, renameCategory, arg.Title, arg.Idlinkercategory)
	return err
}

const rename_category = `-- name: Rename_category :exec
UPDATE faqCategories
SET name = ?
WHERE idfaqCategories = ?
`

type Rename_categoryParams struct {
	Name            sql.NullString
	Idfaqcategories int32
}

func (q *Queries) Rename_category(ctx context.Context, arg Rename_categoryParams) error {
	_, err := q.db.ExecContext(ctx, rename_category, arg.Name, arg.Idfaqcategories)
	return err
}

const selectUnansweredQuestions = `-- name: SelectUnansweredQuestions :many
SELECT idfaq, faqcategories_idfaqcategories, language_idlanguage, users_idusers, answer, question
FROM faq
WHERE faqCategories_idfaqCategories = '0' OR answer IS NULL
`

func (q *Queries) SelectUnansweredQuestions(ctx context.Context) ([]*Faq, error) {
	rows, err := q.db.QueryContext(ctx, selectUnansweredQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faq
	for rows.Next() {
		var i Faq
		if err := rows.Scan(
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setTopicRestrictions = `-- name: SetTopicRestrictions :exec
INSERT INTO topicrestrictions (forumtopic_idforumtopic, viewlevel, replylevel, newthreadlevel, seelevel, invitelevel, readlevel, modlevel, adminlevel)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON DUPLICATE KEY UPDATE
    viewlevel = VALUES(viewlevel),
    replylevel = VALUES(replylevel),
    newthreadlevel = VALUES(newthreadlevel),
    seelevel = VALUES(seelevel),
    invitelevel = VALUES(invitelevel),
    readlevel = VALUES(readlevel),
    modlevel = VALUES(modlevel),
    adminlevel = VALUES(adminlevel)
`

type SetTopicRestrictionsParams struct {
	ForumtopicIdforumtopic int32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) SetTopicRestrictions(ctx context.Context, arg SetTopicRestrictionsParams) error {
	_, err := q.db.ExecContext(ctx, setTopicRestrictions,
		arg.ForumtopicIdforumtopic,
		arg.Viewlevel,
		arg.Replylevel,
		arg.Newthreadlevel,
		arg.Seelevel,
		arg.Invitelevel,
		arg.Readlevel,
		arg.Modlevel,
		arg.Adminlevel,
	)
	return err
}

const setUsersTopicLevel = `-- name: SetUsersTopicLevel :exec
INSERT INTO userstopiclevel (forumtopic_idforumtopic, users_idusers, level, invitemax)
VALUES (?, ?, ?, ?)
ON DUPLICATE KEY UPDATE level = VALUES(level), invitemax = VALUES(invitemax)
`

type SetUsersTopicLevelParams struct {
	ForumtopicIdforumtopic int32
	UsersIdusers           int32
	Level                  sql.NullInt32
	Invitemax              sql.NullInt32
}

func (q *Queries) SetUsersTopicLevel(ctx context.Context, arg SetUsersTopicLevelParams) error {
	_, err := q.db.ExecContext(ctx, setUsersTopicLevel,
		arg.ForumtopicIdforumtopic,
		arg.UsersIdusers,
		arg.Level,
		arg.Invitemax,
	)
	return err
}

const showAdminQueue = `-- name: ShowAdminQueue :many
SELECT l.idlinkerqueue, l.language_idlanguage, l.users_idusers, l.linkercategory_idlinkercategory, l.title, l.url, l.description, u.username, c.title as category_title, c.idlinkerCategory
FROM linkerQueue l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory c ON l.linkerCategory_idlinkerCategory = c.idlinkerCategory
`

type ShowAdminQueueRow struct {
	Idlinkerqueue                  int32
	LanguageIdlanguage             int32
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
	Username                       sql.NullString
	CategoryTitle                  sql.NullString
	Idlinkercategory               int32
}

func (q *Queries) ShowAdminQueue(ctx context.Context) ([]*ShowAdminQueueRow, error) {
	rows, err := q.db.QueryContext(ctx, showAdminQueue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ShowAdminQueueRow
	for rows.Next() {
		var i ShowAdminQueueRow
		if err := rows.Scan(
			&i.Idlinkerqueue,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkercategoryIdlinkercategory,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Username,
			&i.CategoryTitle,
			&i.Idlinkercategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showAllBoards = `-- name: ShowAllBoards :many
SELECT b.idimageboard, b.title, b.description, b.imageboard_idimageboard, pb.title
FROM imageboard b
LEFT JOIN imageboard pb ON b.imageboard_idimageboard = pb.idimageboard OR b.imageboard_idimageboard = 0
GROUP BY b.idimageboard
`

type ShowAllBoardsRow struct {
	Idimageboard           int32
	Title                  sql.NullString
	Description            sql.NullString
	ImageboardIdimageboard int32
	Title_2                sql.NullString
}

func (q *Queries) ShowAllBoards(ctx context.Context) ([]*ShowAllBoardsRow, error) {
	rows, err := q.db.QueryContext(ctx, showAllBoards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ShowAllBoardsRow
	for rows.Next() {
		var i ShowAllBoardsRow
		if err := rows.Scan(
			&i.Idimageboard,
			&i.Title,
			&i.Description,
			&i.ImageboardIdimageboard,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showAllCategories = `-- name: ShowAllCategories :many
SELECT c.idforumcategory, c.forumcategory_idforumcategory, c.title, c.description, COUNT(c2.idforumcategory) as SubcategoryCount
FROM forumcategory c
LEFT JOIN forumcategory c2 ON c.forumcategory_idforumcategory = c2.idforumcategory
GROUP BY c.idforumcategory
`

type ShowAllCategoriesRow struct {
	Idforumcategory              int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Subcategorycount             int64
}

func (q *Queries) ShowAllCategories(ctx context.Context) ([]*ShowAllCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, showAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ShowAllCategoriesRow
	for rows.Next() {
		var i ShowAllCategoriesRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.ForumcategoryIdforumcategory,
			&i.Title,
			&i.Description,
			&i.Subcategorycount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showCategories = `-- name: ShowCategories :many
SELECT idlinkerCategory, title FROM linkerCategory
`

func (q *Queries) ShowCategories(ctx context.Context) ([]*Linkercategory, error) {
	rows, err := q.db.QueryContext(ctx, showCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Linkercategory
	for rows.Next() {
		var i Linkercategory
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showLatest = `-- name: ShowLatest :many
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linkercategory_idlinkercategory, l.forumthread_idforumthread, l.title, l.url, l.description, l.listed, th.Comments, lc.title as Category_Title, u.Username as PosterUsername
FROM linker l
LEFT JOIN users u ON l.users_idusers = u.idusers
LEFT JOIN linkerCategory lc ON l.linkerCategory_idlinkerCategory = lc.idlinkerCategory
LEFT JOIN forumthread th ON l.forumthread_idforumthread = th.idforumthread
WHERE lc.idlinkerCategory = ?
ORDER BY l.listed DESC
`

type ShowLatestRow struct {
	Idlinker                       int32
	LanguageIdlanguage             int32
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	ForumthreadIdforumthread       int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
	Listed                         sql.NullTime
	Comments                       sql.NullInt32
	CategoryTitle                  sql.NullString
	Posterusername                 sql.NullString
}

func (q *Queries) ShowLatest(ctx context.Context, idlinkercategory int32) ([]*ShowLatestRow, error) {
	rows, err := q.db.QueryContext(ctx, showLatest, idlinkercategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ShowLatestRow
	for rows.Next() {
		var i ShowLatestRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkercategoryIdlinkercategory,
			&i.ForumthreadIdforumthread,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Comments,
			&i.CategoryTitle,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showLink = `-- name: ShowLink :one
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linkercategory_idlinkercategory, l.forumthread_idforumthread, l.title, l.url, l.description, l.listed, u.username, lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory lc ON l.linkerCategory_idlinkerCategory = lc.idlinkerCategory
WHERE l.idlinker = ?
`

type ShowLinkRow struct {
	Idlinker                       int32
	LanguageIdlanguage             int32
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	ForumthreadIdforumthread       int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
	Listed                         sql.NullTime
	Username                       sql.NullString
	Title_2                        sql.NullString
}

func (q *Queries) ShowLink(ctx context.Context, idlinker int32) (*ShowLinkRow, error) {
	row := q.db.QueryRowContext(ctx, showLink, idlinker)
	var i ShowLinkRow
	err := row.Scan(
		&i.Idlinker,
		&i.LanguageIdlanguage,
		&i.UsersIdusers,
		&i.LinkercategoryIdlinkercategory,
		&i.ForumthreadIdforumthread,
		&i.Title,
		&i.Url,
		&i.Description,
		&i.Listed,
		&i.Username,
		&i.Title_2,
	)
	return &i, err
}

const showLinks = `-- name: ShowLinks :many
SELECT l.idlinker, l.language_idlanguage, l.users_idusers, l.linkercategory_idlinkercategory, l.forumthread_idforumthread, l.title, l.url, l.description, l.listed, u.username, lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory lc ON l.linkerCategory_idlinkerCategory = lc.idlinkerCategory
WHERE l.idlinker IN (/*SLICE:linkerids*/?)
`

type ShowLinksRow struct {
	Idlinker                       int32
	LanguageIdlanguage             int32
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	ForumthreadIdforumthread       int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
	Listed                         sql.NullTime
	Username                       sql.NullString
	Title_2                        sql.NullString
}

func (q *Queries) ShowLinks(ctx context.Context, linkerids []int32) ([]*ShowLinksRow, error) {
	query := showLinks
	var queryParams []interface{}
	if len(linkerids) > 0 {
		for _, v := range linkerids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:linkerids*/?", strings.Repeat(",?", len(linkerids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:linkerids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ShowLinksRow
	for rows.Next() {
		var i ShowLinksRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.LinkercategoryIdlinkercategory,
			&i.ForumthreadIdforumthread,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Listed,
			&i.Username,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_blog = `-- name: Show_blog :one
SELECT b.blog, b.written, u.username, b.idblogs, coalesce(th.comments, 0), b.users_idusers, b.forumthread_idforumthread
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE b.idblogs = ?
LIMIT 1
`

type Show_blogRow struct {
	Blog                     sql.NullString
	Written                  time.Time
	Username                 sql.NullString
	Idblogs                  int32
	Comments                 int32
	UsersIdusers             int32
	ForumthreadIdforumthread int32
}

func (q *Queries) Show_blog(ctx context.Context, idblogs int32) (*Show_blogRow, error) {
	row := q.db.QueryRowContext(ctx, show_blog, idblogs)
	var i Show_blogRow
	err := row.Scan(
		&i.Blog,
		&i.Written,
		&i.Username,
		&i.Idblogs,
		&i.Comments,
		&i.UsersIdusers,
		&i.ForumthreadIdforumthread,
	)
	return &i, err
}

const show_blog_edit = `-- name: Show_blog_edit :one
SELECT b.blog, b.language_idlanguage
FROM blogs b, users u
WHERE b.users_idusers = u.idusers AND b.idblogs = ?
LIMIT 1
`

type Show_blog_editRow struct {
	Blog               sql.NullString
	LanguageIdlanguage int32
}

func (q *Queries) Show_blog_edit(ctx context.Context, idblogs int32) (*Show_blog_editRow, error) {
	row := q.db.QueryRowContext(ctx, show_blog_edit, idblogs)
	var i Show_blog_editRow
	err := row.Scan(&i.Blog, &i.LanguageIdlanguage)
	return &i, err
}

const show_blogger_list = `-- name: Show_blogger_list :many
SELECT u.username, COUNT(b.idblogs)
FROM blogs b, users u
WHERE b.users_idusers = u.idusers
GROUP BY u.idusers
`

type Show_blogger_listRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) Show_blogger_list(ctx context.Context) ([]*Show_blogger_listRow, error) {
	rows, err := q.db.QueryContext(ctx, show_blogger_list)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Show_blogger_listRow
	for rows.Next() {
		var i Show_blogger_listRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_bookmarks = `-- name: Show_bookmarks :one
SELECT Idbookmarks, list
FROM bookmarks
WHERE users_idusers = ?
`

type Show_bookmarksRow struct {
	Idbookmarks int32
	List        sql.NullString
}

// This query retrieves the "list" from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) Show_bookmarks(ctx context.Context, usersIdusers int32) (*Show_bookmarksRow, error) {
	row := q.db.QueryRowContext(ctx, show_bookmarks, usersIdusers)
	var i Show_bookmarksRow
	err := row.Scan(&i.Idbookmarks, &i.List)
	return &i, err
}

const show_latest_blogs = `-- name: Show_latest_blogs :many
SELECT b.blog, b.written, u.username, b.idblogs, coalesce(th.comments, 0), b.users_idusers
FROM blogs b
LEFT JOIN users u ON b.users_idusers=u.idusers
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE (b.language_idlanguage = ? OR ? = 0)
AND (b.users_idusers = ? OR ? = 0)
ORDER BY b.written DESC
LIMIT ? OFFSET ?
`

type Show_latest_blogsParams struct {
	LanguageIdlanguage int32
	UsersIdusers       int32
	Limit              int32
	Offset             int32
}

type Show_latest_blogsRow struct {
	Blog         sql.NullString
	Written      time.Time
	Username     sql.NullString
	Idblogs      int32
	Comments     int32
	UsersIdusers int32
}

func (q *Queries) Show_latest_blogs(ctx context.Context, arg Show_latest_blogsParams) ([]*Show_latest_blogsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_latest_blogs,
		arg.LanguageIdlanguage,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
		arg.UsersIdusers,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Show_latest_blogsRow
	for rows.Next() {
		var i Show_latest_blogsRow
		if err := rows.Scan(
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Idblogs,
			&i.Comments,
			&i.UsersIdusers,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_questions = `-- name: Show_questions :many
SELECT c.idfaqcategories, c.name, f.idfaq, f.faqcategories_idfaqcategories, f.language_idlanguage, f.users_idusers, f.answer, f.question
FROM faq f
LEFT JOIN faqCategories c ON c.idfaqCategories = f.faqCategories_idfaqCategories
WHERE c.idfaqCategories <> 0 AND f.answer IS NOT NULL
ORDER BY c.idfaqCategories
`

type Show_questionsRow struct {
	Idfaqcategories              sql.NullInt32
	Name                         sql.NullString
	Idfaq                        int32
	FaqcategoriesIdfaqcategories int32
	LanguageIdlanguage           int32
	UsersIdusers                 int32
	Answer                       sql.NullString
	Question                     sql.NullString
}

func (q *Queries) Show_questions(ctx context.Context) ([]*Show_questionsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_questions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Show_questionsRow
	for rows.Next() {
		var i Show_questionsRow
		if err := rows.Scan(
			&i.Idfaqcategories,
			&i.Name,
			&i.Idfaq,
			&i.FaqcategoriesIdfaqcategories,
			&i.LanguageIdlanguage,
			&i.UsersIdusers,
			&i.Answer,
			&i.Question,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const siteNewsSearchFirst = `-- name: SiteNewsSearchFirst :many
SELECT DISTINCT cs.siteNews_idsiteNews
FROM siteNewsSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
`

func (q *Queries) SiteNewsSearchFirst(ctx context.Context, word sql.NullString) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, siteNewsSearchFirst, word)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var sitenews_idsitenews int32
		if err := rows.Scan(&sitenews_idsitenews); err != nil {
			return nil, err
		}
		items = append(items, sitenews_idsitenews)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const siteNewsSearchNext = `-- name: SiteNewsSearchNext :many
SELECT DISTINCT cs.siteNews_idsiteNews
FROM siteNewsSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
AND cs.siteNews_idsiteNews IN (/*SLICE:ids*/?)
`

type SiteNewsSearchNextParams struct {
	Word sql.NullString
	Ids  []int32
}

func (q *Queries) SiteNewsSearchNext(ctx context.Context, arg SiteNewsSearchNextParams) ([]int32, error) {
	query := siteNewsSearchNext
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var sitenews_idsitenews int32
		if err := rows.Scan(&sitenews_idsitenews); err != nil {
			return nil, err
		}
		items = append(items, sitenews_idsitenews)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const somethingNotifyBlogs = `-- name: SomethingNotifyBlogs :many
SELECT u.email FROM blogs t, users u, preferences p
WHERE t.idblogs=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type SomethingNotifyBlogsParams struct {
	Idblogs int32
	Idusers int32
}

func (q *Queries) SomethingNotifyBlogs(ctx context.Context, arg SomethingNotifyBlogsParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, somethingNotifyBlogs, arg.Idblogs, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const somethingNotifyLinker = `-- name: SomethingNotifyLinker :many
SELECT u.email FROM linker t, users u, preferences p
WHERE t.idlinker=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type SomethingNotifyLinkerParams struct {
	Idlinker int32
	Idusers  int32
}

func (q *Queries) SomethingNotifyLinker(ctx context.Context, arg SomethingNotifyLinkerParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, somethingNotifyLinker, arg.Idlinker, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const somethingNotifyWriting = `-- name: SomethingNotifyWriting :many
SELECT u.email FROM writing t, users u, preferences p
WHERE t.idwriting=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type SomethingNotifyWritingParams struct {
	Idwriting int32
	Idusers   int32
}

func (q *Queries) SomethingNotifyWriting(ctx context.Context, arg SomethingNotifyWritingParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, somethingNotifyWriting, arg.Idwriting, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const threadNotify = `-- name: ThreadNotify :many
SELECT u.email FROM comments c, users u, preferences p
WHERE c.forumthread_idforumthread=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=c.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type ThreadNotifyParams struct {
	ForumthreadIdforumthread int32
	Idusers                  int32
}

func (q *Queries) ThreadNotify(ctx context.Context, arg ThreadNotifyParams) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, threadNotify, arg.ForumthreadIdforumthread, arg.Idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQueue = `-- name: UpdateQueue :exec
UPDATE linkerQueue SET linkerCategory_idlinkerCategory = ?, title = ?, url = ?, description = ? WHERE idlinkerQueue = ?
`

type UpdateQueueParams struct {
	LinkercategoryIdlinkercategory int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
	Idlinkerqueue                  int32
}

func (q *Queries) UpdateQueue(ctx context.Context, arg UpdateQueueParams) error {
	_, err := q.db.ExecContext(ctx, updateQueue,
		arg.LinkercategoryIdlinkercategory,
		arg.Title,
		arg.Url,
		arg.Description,
		arg.Idlinkerqueue,
	)
	return err
}

const updateWriting = `-- name: UpdateWriting :exec
UPDATE writing
SET title = ?, abstract = ?, writting = ?, private = ?, language_idlanguage = ?
WHERE idwriting = ?
`

type UpdateWritingParams struct {
	Title              sql.NullString
	Abstract           sql.NullString
	Writting           sql.NullString
	Private            sql.NullBool
	LanguageIdlanguage int32
	Idwriting          int32
}

func (q *Queries) UpdateWriting(ctx context.Context, arg UpdateWritingParams) error {
	_, err := q.db.ExecContext(ctx, updateWriting,
		arg.Title,
		arg.Abstract,
		arg.Writting,
		arg.Private,
		arg.LanguageIdlanguage,
		arg.Idwriting,
	)
	return err
}

const updateWritingApproval = `-- name: UpdateWritingApproval :exec
UPDATE writtingApprovedUsers
SET readdoc = ?, editdoc = ?
WHERE writing_idwriting = ? AND users_idusers = ?
`

type UpdateWritingApprovalParams struct {
	Readdoc          sql.NullBool
	Editdoc          sql.NullBool
	WritingIdwriting int32
	UsersIdusers     int32
}

func (q *Queries) UpdateWritingApproval(ctx context.Context, arg UpdateWritingApprovalParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingApproval,
		arg.Readdoc,
		arg.Editdoc,
		arg.WritingIdwriting,
		arg.UsersIdusers,
	)
	return err
}

const updateWritingCategory = `-- name: UpdateWritingCategory :exec
UPDATE writingCategory
SET title = ?, description = ?, writingCategory_idwritingCategory = ?
WHERE idwritingCategory = ?
`

type UpdateWritingCategoryParams struct {
	Title                            sql.NullString
	Description                      sql.NullString
	WritingcategoryIdwritingcategory int32
	Idwritingcategory                int32
}

func (q *Queries) UpdateWritingCategory(ctx context.Context, arg UpdateWritingCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateWritingCategory,
		arg.Title,
		arg.Description,
		arg.WritingcategoryIdwritingcategory,
		arg.Idwritingcategory,
	)
	return err
}

const update_blog = `-- name: Update_blog :exec
UPDATE blogs
SET language_idlanguage = ?, blog = ?
WHERE idblogs = ?
`

type Update_blogParams struct {
	LanguageIdlanguage int32
	Blog               sql.NullString
	Idblogs            int32
}

func (q *Queries) Update_blog(ctx context.Context, arg Update_blogParams) error {
	_, err := q.db.ExecContext(ctx, update_blog, arg.LanguageIdlanguage, arg.Blog, arg.Idblogs)
	return err
}

const update_bookmarks = `-- name: Update_bookmarks :exec
UPDATE bookmarks
SET list = ?
WHERE users_idusers = ?
`

type Update_bookmarksParams struct {
	List         sql.NullString
	UsersIdusers int32
}

// This query updates the "list" column in the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) Update_bookmarks(ctx context.Context, arg Update_bookmarksParams) error {
	_, err := q.db.ExecContext(ctx, update_bookmarks, arg.List, arg.UsersIdusers)
	return err
}

const update_comment = `-- name: Update_comment :exec
UPDATE comments
SET language_idlanguage = ?, text = ?
WHERE idcomments = ?
`

type Update_commentParams struct {
	LanguageIdlanguage int32
	Text               sql.NullString
	Idcomments         int32
}

func (q *Queries) Update_comment(ctx context.Context, arg Update_commentParams) error {
	_, err := q.db.ExecContext(ctx, update_comment, arg.LanguageIdlanguage, arg.Text, arg.Idcomments)
	return err
}

const update_forumthread = `-- name: Update_forumthread :exec
UPDATE forumthread
SET lastaddition = (
    SELECT written
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
), comments = (
    SELECT COUNT(users_idusers) - 1
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
), lastposter = (
    SELECT users_idusers
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
), firstpost = (
    SELECT idcomments
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    LIMIT 1
)
WHERE idforumthread = ?
`

func (q *Queries) Update_forumthread(ctx context.Context, idforumthread int32) error {
	_, err := q.db.ExecContext(ctx, update_forumthread, idforumthread)
	return err
}

const update_forumthreads = `-- name: Update_forumthreads :exec
UPDATE forumthread
SET lastaddition = (
    SELECT written
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
), comments = (
    SELECT COUNT(users_idusers) - 1
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
), lastposter = (
    SELECT users_idusers
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
), firstpost = (
    SELECT idcomments
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    LIMIT 1
)
`

func (q *Queries) Update_forumthreads(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthreads)
	return err
}

const update_forumtopic = `-- name: Update_forumtopic :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
), lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
WHERE idforumtopic = ?
`

func (q *Queries) Update_forumtopic(ctx context.Context, idforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic, idforumtopic)
	return err
}

const update_forumtopics = `-- name: Update_forumtopics :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
), lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
), lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
`

func (q *Queries) Update_forumtopics(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopics)
	return err
}

const userAllow = `-- name: UserAllow :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES (?, ?, ?)
`

type UserAllowParams struct {
	UsersIdusers int32
	Section      sql.NullString
	Level        sql.NullString
}

// This query inserts a new permission into the "permissions" table.
// Parameters:
//
//	? - User ID to be associated with the permission (int)
//	? - Section for which the permission is granted (string)
//	? - Level of the permission (string)
func (q *Queries) UserAllow(ctx context.Context, arg UserAllowParams) error {
	_, err := q.db.ExecContext(ctx, userAllow, arg.UsersIdusers, arg.Section, arg.Level)
	return err
}

const userByEmail = `-- name: UserByEmail :one
SELECT idusers, email, passwd, username
FROM users
WHERE email = ?
`

func (q *Queries) UserByEmail(ctx context.Context, email sql.NullString) (*User, error) {
	row := q.db.QueryRowContext(ctx, userByEmail, email)
	var i User
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.Username,
	)
	return &i, err
}

const userByUid = `-- name: UserByUid :one
SELECT idusers, email, passwd, username
FROM users
WHERE idusers = ?
`

func (q *Queries) UserByUid(ctx context.Context, idusers int32) (*User, error) {
	row := q.db.QueryRowContext(ctx, userByUid, idusers)
	var i User
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.Username,
	)
	return &i, err
}

const userByUsername = `-- name: UserByUsername :one
SELECT idusers, email, passwd, username
FROM users
WHERE username = ?
`

func (q *Queries) UserByUsername(ctx context.Context, username sql.NullString) (*User, error) {
	row := q.db.QueryRowContext(ctx, userByUsername, username)
	var i User
	err := row.Scan(
		&i.Idusers,
		&i.Email,
		&i.Passwd,
		&i.Username,
	)
	return &i, err
}

const userDisallow = `-- name: UserDisallow :exec
DELETE FROM permissions
WHERE idpermissions = ?
`

// This query deletes a permission from the "permissions" table based on the provided "permid".
// Parameters:
//
//	? - Permission ID to be deleted (int)
func (q *Queries) UserDisallow(ctx context.Context, idpermissions int32) error {
	_, err := q.db.ExecContext(ctx, userDisallow, idpermissions)
	return err
}

const user_allow = `-- name: User_allow :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES (?, ?, ?)
`

type User_allowParams struct {
	UsersIdusers int32
	Section      sql.NullString
	Level        sql.NullString
}

func (q *Queries) User_allow(ctx context.Context, arg User_allowParams) error {
	_, err := q.db.ExecContext(ctx, user_allow, arg.UsersIdusers, arg.Section, arg.Level)
	return err
}

const user_get_all_comments_for_thread = `-- name: User_get_all_comments_for_thread :many
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text, pu.username AS posterusername
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_idforumthread=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users pu ON pu.idusers = c.users_idusers
WHERE c.forumthread_idforumthread=? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY c.written
`

type User_get_all_comments_for_threadParams struct {
	UsersIdusers             int32
	ForumthreadIdforumthread int32
}

type User_get_all_comments_for_threadRow struct {
	Idcomments               int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Written                  sql.NullTime
	Text                     sql.NullString
	Posterusername           sql.NullString
}

func (q *Queries) User_get_all_comments_for_thread(ctx context.Context, arg User_get_all_comments_for_threadParams) ([]*User_get_all_comments_for_threadRow, error) {
	rows, err := q.db.QueryContext(ctx, user_get_all_comments_for_thread, arg.UsersIdusers, arg.ForumthreadIdforumthread)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User_get_all_comments_for_threadRow
	for rows.Next() {
		var i User_get_all_comments_for_threadRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.ForumthreadIdforumthread,
			&i.UsersIdusers,
			&i.LanguageIdlanguage,
			&i.Written,
			&i.Text,
			&i.Posterusername,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const user_get_comment = `-- name: User_get_comment :one
SELECT c.idcomments, c.forumthread_idforumthread, c.users_idusers, c.language_idlanguage, c.written, c.text, pu.Username
FROM comments c
LEFT JOIN forumthread th ON c.forumthread_idforumthread=th.idforumthread
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users pu ON pu.idusers = c.users_idusers
WHERE c.idcomments = ? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
LIMIT 1
`

type User_get_commentParams struct {
	UsersIdusers int32
	Idcomments   int32
}

type User_get_commentRow struct {
	Idcomments               int32
	ForumthreadIdforumthread int32
	UsersIdusers             int32
	LanguageIdlanguage       int32
	Written                  sql.NullTime
	Text                     sql.NullString
	Username                 sql.NullString
}

func (q *Queries) User_get_comment(ctx context.Context, arg User_get_commentParams) (*User_get_commentRow, error) {
	row := q.db.QueryRowContext(ctx, user_get_comment, arg.UsersIdusers, arg.Idcomments)
	var i User_get_commentRow
	err := row.Scan(
		&i.Idcomments,
		&i.ForumthreadIdforumthread,
		&i.UsersIdusers,
		&i.LanguageIdlanguage,
		&i.Written,
		&i.Text,
		&i.Username,
	)
	return &i, err
}

const user_get_thread = `-- name: User_get_thread :one
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked, lu.username AS LastPosterUsername, r.seelevel, u.level
FROM forumthread th
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0) AND th.idforumthread=?
ORDER BY t.lastaddition DESC
`

type User_get_threadParams struct {
	UsersIdusers  int32
	Idforumthread int32
}

type User_get_threadRow struct {
	Idforumthread          int32
	Firstpost              int32
	Lastposter             int32
	ForumtopicIdforumtopic int32
	Comments               sql.NullInt32
	Lastaddition           sql.NullTime
	Locked                 sql.NullBool
	Lastposterusername     sql.NullString
	Seelevel               sql.NullInt32
	Level                  sql.NullInt32
}

func (q *Queries) User_get_thread(ctx context.Context, arg User_get_threadParams) (*User_get_threadRow, error) {
	row := q.db.QueryRowContext(ctx, user_get_thread, arg.UsersIdusers, arg.Idforumthread)
	var i User_get_threadRow
	err := row.Scan(
		&i.Idforumthread,
		&i.Firstpost,
		&i.Lastposter,
		&i.ForumtopicIdforumtopic,
		&i.Comments,
		&i.Lastaddition,
		&i.Locked,
		&i.Lastposterusername,
		&i.Seelevel,
		&i.Level,
	)
	return &i, err
}

const user_get_threads_for_topic = `-- name: User_get_threads_for_topic :many
SELECT th.idforumthread, th.firstpost, th.lastposter, th.forumtopic_idforumtopic, th.comments, th.lastaddition, th.locked, lu.username AS lastposterusername, lu.idusers AS lastposterid, fcu.username as firstpostusername, fc.written as firstpostwritten, fc.text as firstposttext
FROM forumthread th
LEFT JOIN forumtopic t ON th.forumtopic_idforumtopic=t.idforumtopic
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
LEFT JOIN comments fc ON th.firstpost=fc.idcomments
LEFT JOIN users fcu ON fcu.idusers = fc.users_idusers
WHERE th.forumtopic_idforumtopic=? AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY th.lastaddition DESC
`

type User_get_threads_for_topicParams struct {
	UsersIdusers           int32
	ForumtopicIdforumtopic int32
}

type User_get_threads_for_topicRow struct {
	Idforumthread          int32
	Firstpost              int32
	Lastposter             int32
	ForumtopicIdforumtopic int32
	Comments               sql.NullInt32
	Lastaddition           sql.NullTime
	Locked                 sql.NullBool
	Lastposterusername     sql.NullString
	Lastposterid           sql.NullInt32
	Firstpostusername      sql.NullString
	Firstpostwritten       sql.NullTime
	Firstposttext          sql.NullString
}

func (q *Queries) User_get_threads_for_topic(ctx context.Context, arg User_get_threads_for_topicParams) ([]*User_get_threads_for_topicRow, error) {
	rows, err := q.db.QueryContext(ctx, user_get_threads_for_topic, arg.UsersIdusers, arg.ForumtopicIdforumtopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User_get_threads_for_topicRow
	for rows.Next() {
		var i User_get_threads_for_topicRow
		if err := rows.Scan(
			&i.Idforumthread,
			&i.Firstpost,
			&i.Lastposter,
			&i.ForumtopicIdforumtopic,
			&i.Comments,
			&i.Lastaddition,
			&i.Locked,
			&i.Lastposterusername,
			&i.Lastposterid,
			&i.Firstpostusername,
			&i.Firstpostwritten,
			&i.Firstposttext,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const user_get_topic = `-- name: User_get_topic :one
SELECT t.idforumtopic, t.lastposter, t.forumcategory_idforumcategory, t.title, t.description, t.threads, t.comments, t.lastaddition, lu.username AS LastPosterUsername, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = ?
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0) AND t.idforumtopic=?
ORDER BY t.lastaddition DESC
`

type User_get_topicParams struct {
	UsersIdusers int32
	Idforumtopic int32
}

type User_get_topicRow struct {
	Idforumtopic                 int32
	Lastposter                   int32
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
	Threads                      sql.NullInt32
	Comments                     sql.NullInt32
	Lastaddition                 sql.NullTime
	Lastposterusername           sql.NullString
	Seelevel                     sql.NullInt32
	Level                        sql.NullInt32
}

func (q *Queries) User_get_topic(ctx context.Context, arg User_get_topicParams) (*User_get_topicRow, error) {
	row := q.db.QueryRowContext(ctx, user_get_topic, arg.UsersIdusers, arg.Idforumtopic)
	var i User_get_topicRow
	err := row.Scan(
		&i.Idforumtopic,
		&i.Lastposter,
		&i.ForumcategoryIdforumcategory,
		&i.Title,
		&i.Description,
		&i.Threads,
		&i.Comments,
		&i.Lastaddition,
		&i.Lastposterusername,
		&i.Seelevel,
		&i.Level,
	)
	return &i, err
}

const usernametouid = `-- name: Usernametouid :one
SELECT idusers FROM users WHERE username = ?
`

func (q *Queries) Usernametouid(ctx context.Context, username sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, usernametouid, username)
	var idusers int32
	err := row.Scan(&idusers)
	return idusers, err
}

const writeNewsPost = `-- name: WriteNewsPost :exec
INSERT INTO siteNews (news, users_idusers, occured, language_idlanguage)
VALUES (?, ?, NOW(), ?)
`

type WriteNewsPostParams struct {
	News               sql.NullString
	UsersIdusers       int32
	LanguageIdlanguage int32
}

func (q *Queries) WriteNewsPost(ctx context.Context, arg WriteNewsPostParams) error {
	_, err := q.db.ExecContext(ctx, writeNewsPost, arg.News, arg.UsersIdusers, arg.LanguageIdlanguage)
	return err
}

const writeSiteNewsRSS = `-- name: WriteSiteNewsRSS :many
SELECT s.idsiteNews, s.occured, s.news
FROM siteNews s
ORDER BY s.occured DESC LIMIT 15
`

type WriteSiteNewsRSSRow struct {
	Idsitenews int32
	Occured    sql.NullTime
	News       sql.NullString
}

func (q *Queries) WriteSiteNewsRSS(ctx context.Context) ([]*WriteSiteNewsRSSRow, error) {
	rows, err := q.db.QueryContext(ctx, writeSiteNewsRSS)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*WriteSiteNewsRSSRow
	for rows.Next() {
		var i WriteSiteNewsRSSRow
		if err := rows.Scan(&i.Idsitenews, &i.Occured, &i.News); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const writingSearchDelete = `-- name: WritingSearchDelete :exec
DELETE FROM writingSearch
WHERE writing_idwriting=?
`

func (q *Queries) WritingSearchDelete(ctx context.Context, writingIdwriting int32) error {
	_, err := q.db.ExecContext(ctx, writingSearchDelete, writingIdwriting)
	return err
}

const writingSearchFirst = `-- name: WritingSearchFirst :many
SELECT DISTINCT cs.writing_idwriting
FROM writingSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
`

func (q *Queries) WritingSearchFirst(ctx context.Context, word sql.NullString) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, writingSearchFirst, word)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var writing_idwriting int32
		if err := rows.Scan(&writing_idwriting); err != nil {
			return nil, err
		}
		items = append(items, writing_idwriting)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const writingSearchNext = `-- name: WritingSearchNext :many
SELECT DISTINCT cs.writing_idwriting
FROM writingSearch cs
LEFT JOIN searchwordlist swl ON swl.idsearchwordlist=cs.searchwordlist_idsearchwordlist
WHERE swl.word=?
AND cs.writing_idwriting IN (/*SLICE:ids*/?)
`

type WritingSearchNextParams struct {
	Word sql.NullString
	Ids  []int32
}

func (q *Queries) WritingSearchNext(ctx context.Context, arg WritingSearchNextParams) ([]int32, error) {
	query := writingSearchNext
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Word)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var writing_idwriting int32
		if err := rows.Scan(&writing_idwriting); err != nil {
			return nil, err
		}
		items = append(items, writing_idwriting)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
