// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: queries.sql

package main

import (
	"context"
	"database/sql"
)

const selectLanguages = `-- name: SelectLanguages :many
SELECT idlanguage, nameof
FROM language
`

// This query selects all languages from the "language" table.
// Result:
//
//	idlanguage (int)
//	nameof (string)
func (q *Queries) SelectLanguages(ctx context.Context) ([]*Language, error) {
	rows, err := q.db.QueryContext(ctx, selectLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(&i.Idlanguage, &i.Nameof); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addImage = `-- name: addImage :exec
INSERT INTO imagepost (imageboard_idimageboard, thumbnail, fullimage, users_idusers, description, posted)
VALUES ($1, $2, $3, $4, $5, NOW())
`

func (q *Queries) addImage(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, addImage)
	return err
}

const addToLinker = `-- name: addToLinker :exec
INSERT INTO linker (users_idusers, linkerCategory_idlinkerCategory, title, url, description, listed)
VALUES ($1, $2, $3, $4, $5, NOW())
`

func (q *Queries) addToLinker(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, addToLinker)
	return err
}

const addToQueue = `-- name: addToQueue :exec
INSERT INTO linkerQueue (users_idusers, linkerCategory_idlinkerCategory, title, url, description) VALUES ($1, $2, $3, $4, $5)
`

func (q *Queries) addToQueue(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, addToQueue)
	return err
}

const addTopicRestrictions = `-- name: addTopicRestrictions :exec
INSERT INTO topicrestrictions (forumtopic_idforumtopic, viewlevel, replylevel, newthreadlevel, seelevel, invitelevel, readlevel, modlevel, adminlevel)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

func (q *Queries) addTopicRestrictions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, addTopicRestrictions)
	return err
}

const addUsersTopicLevel = `-- name: addUsersTopicLevel :exec
INSERT INTO userstopiclevel (forumtopic_idforumtopic, users_idusers, level, invitemax)
VALUES ($1, $2, $3, $4)
`

func (q *Queries) addUsersTopicLevel(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, addUsersTopicLevel)
	return err
}

const addWord = `-- name: addWord :exec
INSERT INTO searchwordlist (word) VALUES (lcase(?))
`

func (q *Queries) addWord(ctx context.Context, lcase string) error {
	_, err := q.db.ExecContext(ctx, addWord, lcase)
	return err
}

const add_blog = `-- name: add_blog :exec
INSERT INTO blogs (users_idusers, language_idlanguage, blog, written)
VALUES (?, ?, ?, NOW())
`

type add_blogParams struct {
	UsersIdusers       int32
	LanguageIdlanguage int32
	Blog               sql.NullString
}

func (q *Queries) add_blog(ctx context.Context, arg add_blogParams) error {
	_, err := q.db.ExecContext(ctx, add_blog, arg.UsersIdusers, arg.LanguageIdlanguage, arg.Blog)
	return err
}

const add_bookmarks = `-- name: add_bookmarks :exec
INSERT INTO bookmarks (users_idusers, list)
VALUES (?, ?)
`

type add_bookmarksParams struct {
	UsersIdusers int32
	List         sql.NullString
}

// This query adds a new entry to the "bookmarks" table and returns the last inserted ID as "returnthis".
func (q *Queries) add_bookmarks(ctx context.Context, arg add_bookmarksParams) error {
	_, err := q.db.ExecContext(ctx, add_bookmarks, arg.UsersIdusers, arg.List)
	return err
}

const add_question = `-- name: add_question :exec
INSERT INTO faq (question, users_idusers, language_idlanguage)
VALUES (?, ?, ?)
`

type add_questionParams struct {
	Question           sql.NullString
	UsersIdusers       int32
	LanguageIdlanguage int32
}

func (q *Queries) add_question(ctx context.Context, arg add_questionParams) error {
	_, err := q.db.ExecContext(ctx, add_question, arg.Question, arg.UsersIdusers, arg.LanguageIdlanguage)
	return err
}

const adminCategories = `-- name: adminCategories :many
SELECT idlinkerCategory, title FROM linkerCategory
`

func (q *Queries) adminCategories(ctx context.Context) ([]*Linkercategory, error) {
	rows, err := q.db.QueryContext(ctx, adminCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Linkercategory
	for rows.Next() {
		var i Linkercategory
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUserPermissions = `-- name: adminUserPermissions :many
SELECT p.idpermissions, p.level, u.username, u.email, p.section
FROM permissions p, users u
WHERE u.idusers = p.users_idusers
ORDER BY p.level
`

type adminUserPermissionsRow struct {
	Idpermissions int32
	Level         sql.NullString
	Username      sql.NullString
	Email         sql.NullString
	Section       sql.NullString
}

// This query selects permissions information for admin users.
// Result:
//
//	idpermissions (int)
//	level (int)
//	username (string)
//	email (string)
//	section (string)
func (q *Queries) adminUserPermissions(ctx context.Context) ([]*adminUserPermissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminUserPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*adminUserPermissionsRow
	for rows.Next() {
		var i adminUserPermissionsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.Level,
			&i.Username,
			&i.Email,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const adminUsers = `-- name: adminUsers :many
SELECT u.idusers, u.username, u.email
FROM users u
`

type adminUsersRow struct {
	Idusers  int32
	Username sql.NullString
	Email    sql.NullString
}

// This query selects all admin users from the "users" table.
// Result:
//
//	idusers (int)
//	username (string)
//	email (string)
func (q *Queries) adminUsers(ctx context.Context) ([]*adminUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, adminUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*adminUsersRow
	for rows.Next() {
		var i adminUsersRow
		if err := rows.Scan(&i.Idusers, &i.Username, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const admin_categories = `-- name: admin_categories :many
SELECT idfaqCategories, name
FROM faqCategories
`

func (q *Queries) admin_categories(ctx context.Context) ([]*Faqcategory, error) {
	rows, err := q.db.QueryContext(ctx, admin_categories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Faqcategory
	for rows.Next() {
		var i Faqcategory
		if err := rows.Scan(&i.Idfaqcategories, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const admin_user_permissions = `-- name: admin_user_permissions :many
SELECT p.idpermissions, p.level, u.username, u.email, p.section
FROM permissions p, users u
WHERE u.idusers = p.users_idusers AND p.section = ?
ORDER BY p.level
`

type admin_user_permissionsRow struct {
	Idpermissions int32
	Level         sql.NullString
	Username      sql.NullString
	Email         sql.NullString
	Section       sql.NullString
}

func (q *Queries) admin_user_permissions(ctx context.Context, section sql.NullString) ([]*admin_user_permissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, admin_user_permissions, section)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*admin_user_permissionsRow
	for rows.Next() {
		var i admin_user_permissionsRow
		if err := rows.Scan(
			&i.Idpermissions,
			&i.Level,
			&i.Username,
			&i.Email,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const assignImagePostThisThreadId = `-- name: assignImagePostThisThreadId :exec
UPDATE imagepost SET forumthread_idforumthread = $1 WHERE idimagepost = $2
`

func (q *Queries) assignImagePostThisThreadId(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, assignImagePostThisThreadId)
	return err
}

const assignLinkerThisThreadId = `-- name: assignLinkerThisThreadId :exec
UPDATE linker SET forumthread_idforumthread = $1 WHERE idlinker = $2
`

func (q *Queries) assignLinkerThisThreadId(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, assignLinkerThisThreadId)
	return err
}

const assignNewsThisThreadId = `-- name: assignNewsThisThreadId :exec
UPDATE siteNews SET forumthread_idforumthread = $1 WHERE idsiteNews = $2
`

func (q *Queries) assignNewsThisThreadId(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, assignNewsThisThreadId)
	return err
}

const assign_answer = `-- name: assign_answer :exec
UPDATE faq
SET answer = ?
WHERE idfaq = ?
`

type assign_answerParams struct {
	Answer sql.NullString
	Idfaq  int32
}

func (q *Queries) assign_answer(ctx context.Context, arg assign_answerParams) error {
	_, err := q.db.ExecContext(ctx, assign_answer, arg.Answer, arg.Idfaq)
	return err
}

const assign_blog_to_thread = `-- name: assign_blog_to_thread :exec
UPDATE blogs
SET forumthread_idforumthread = ?
WHERE idblogs = ?
`

type assign_blog_to_threadParams struct {
	ForumthreadIdforumthread int32
	Idblogs                  int32
}

func (q *Queries) assign_blog_to_thread(ctx context.Context, arg assign_blog_to_threadParams) error {
	_, err := q.db.ExecContext(ctx, assign_blog_to_thread, arg.ForumthreadIdforumthread, arg.Idblogs)
	return err
}

const blogid_to_userid = `-- name: blogid_to_userid :one
SELECT idusers
FROM users u, blogs b
WHERE u.idusers = b.users_idusers AND b.idblogs = ?
`

func (q *Queries) blogid_to_userid(ctx context.Context, idblogs int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, blogid_to_userid, idblogs)
	var idusers int32
	err := row.Scan(&idusers)
	return idusers, err
}

const categories = `-- name: categories :one
SELECT idfaqCategories, name
FROM faqCategories
`

func (q *Queries) categories(ctx context.Context) (*Faqcategory, error) {
	row := q.db.QueryRowContext(ctx, categories)
	var i Faqcategory
	err := row.Scan(&i.Idfaqcategories, &i.Name)
	return &i, err
}

const category_combobox = `-- name: category_combobox :many
SELECT idlinkerCategory, title FROM linkerCategory
`

func (q *Queries) category_combobox(ctx context.Context) ([]*Linkercategory, error) {
	rows, err := q.db.QueryContext(ctx, category_combobox)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Linkercategory
	for rows.Next() {
		var i Linkercategory
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const category_faqs = `-- name: category_faqs :many
SELECT question, idfaq, answer, faqCategories_idfaqCategories
FROM faq
WHERE faqCategories_idfaqCategories = ? OR answer IS NULL
`

type category_faqsRow struct {
	Question                     sql.NullString
	Idfaq                        int32
	Answer                       sql.NullString
	FaqcategoriesIdfaqcategories int32
}

func (q *Queries) category_faqs(ctx context.Context, faqcategoriesIdfaqcategories int32) ([]*category_faqsRow, error) {
	rows, err := q.db.QueryContext(ctx, category_faqs, faqcategoriesIdfaqcategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*category_faqsRow
	for rows.Next() {
		var i category_faqsRow
		if err := rows.Scan(
			&i.Question,
			&i.Idfaq,
			&i.Answer,
			&i.FaqcategoriesIdfaqcategories,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const changeCategory = `-- name: changeCategory :exec
UPDATE forumcategory SET title = $2, description = $3 WHERE idforumcategory = $1
`

func (q *Queries) changeCategory(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, changeCategory)
	return err
}

const changeImageBoard = `-- name: changeImageBoard :exec
UPDATE imageboard SET title = $2, description = $3, imageboard_idimageboard = $4 WHERE idimageboard = $1
`

func (q *Queries) changeImageBoard(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, changeImageBoard)
	return err
}

const changeTopic = `-- name: changeTopic :exec
UPDATE forumtopic SET title = $2, description = $3 WHERE idforumtopic = $1
`

func (q *Queries) changeTopic(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, changeTopic)
	return err
}

const completeWordList = `-- name: completeWordList :exec
SELECT word
FROM searchwordlist
`

// This query selects all words from the "searchwordlist" table and prints them.
func (q *Queries) completeWordList(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, completeWordList)
	return err
}

const countCategories = `-- name: countCategories :one
SELECT COUNT(*) AS count
FROM language
`

// This query returns the count of all records in the "language" table.
// Result:
//
//	count(*) - The count of rows in the "language" table (int)
func (q *Queries) countCategories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCategories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLinkerCategories = `-- name: countLinkerCategories :one
SELECT COUNT(*) FROM linkerCategory
`

func (q *Queries) countLinkerCategories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLinkerCategories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const count_categories = `-- name: count_categories :one
SELECT COUNT(*) FROM faqCategories
`

func (q *Queries) count_categories(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, count_categories)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCategory = `-- name: createCategory :exec
INSERT INTO linkerCategory (title) VALUES ($1)
`

func (q *Queries) createCategory(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createCategory)
	return err
}

const createLanguage = `-- name: createLanguage :exec
INSERT INTO language (nameof)
VALUES ($1)
`

// This query inserts a new record into the "language" table.
// Parameters:
//
//	$1 - Name of the new language (string)
func (q *Queries) createLanguage(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createLanguage)
	return err
}

const create_category = `-- name: create_category :exec
INSERT INTO faqCategories (name)
VALUES (?)
`

func (q *Queries) create_category(ctx context.Context, name sql.NullString) error {
	_, err := q.db.ExecContext(ctx, create_category, name)
	return err
}

const deleteBlogsSearch = `-- name: deleteBlogsSearch :exec
DELETE FROM blogsSearch
`

// This query deletes all data from the "blogsSearch" table.
func (q *Queries) deleteBlogsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteBlogsSearch)
	return err
}

const deleteCategory = `-- name: deleteCategory :exec
DELETE FROM linkerCategory WHERE idlinkerCategory = $1
`

func (q *Queries) deleteCategory(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteCategory)
	return err
}

const deleteCommentsSearch = `-- name: deleteCommentsSearch :exec
DELETE FROM commentsSearch
`

// This query deletes all data from the "commentsSearch" table.
func (q *Queries) deleteCommentsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteCommentsSearch)
	return err
}

const deleteLanguage = `-- name: deleteLanguage :exec
DELETE FROM language
WHERE idlanguage = $1
`

// This query deletes a record from the "language" table based on the provided "cid".
// Parameters:
//
//	$1 - Language ID to be deleted (int)
func (q *Queries) deleteLanguage(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteLanguage)
	return err
}

const deleteLinkerSearch = `-- name: deleteLinkerSearch :exec
DELETE FROM linkerSearch
`

// This query deletes all data from the "linkerSearch" table.
func (q *Queries) deleteLinkerSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteLinkerSearch)
	return err
}

const deleteQueueItem = `-- name: deleteQueueItem :exec
DELETE FROM linkerQueue WHERE idlinkerQueue = $1
`

func (q *Queries) deleteQueueItem(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteQueueItem)
	return err
}

const deleteSiteNewsSearch = `-- name: deleteSiteNewsSearch :exec
DELETE FROM siteNewsSearch
`

// This query deletes all data from the "siteNewsSearch" table.
func (q *Queries) deleteSiteNewsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteSiteNewsSearch)
	return err
}

const deleteTopicRestrictions = `-- name: deleteTopicRestrictions :exec
DELETE FROM topicrestrictions WHERE forumtopic_idforumtopic = $1
`

func (q *Queries) deleteTopicRestrictions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteTopicRestrictions)
	return err
}

const deleteUsersTopicLevel = `-- name: deleteUsersTopicLevel :exec
DELETE FROM userstopiclevel WHERE forumtopic_idforumtopic = $1 AND users_idusers = $2
`

func (q *Queries) deleteUsersTopicLevel(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteUsersTopicLevel)
	return err
}

const deleteWritingSearch = `-- name: deleteWritingSearch :exec
DELETE FROM writingSearch
`

// This query deletes all data from the "writingSearch" table.
func (q *Queries) deleteWritingSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteWritingSearch)
	return err
}

const delete_blog = `-- name: delete_blog :exec
DELETE FROM blogs
WHERE idblogs = ?
`

func (q *Queries) delete_blog(ctx context.Context, idblogs int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog, idblogs)
	return err
}

const delete_blog_comments = `-- name: delete_blog_comments :exec
DELETE FROM comments
WHERE forumthread_idforumthread = ?
`

func (q *Queries) delete_blog_comments(ctx context.Context, forumthreadIdforumthread int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog_comments, forumthreadIdforumthread)
	return err
}

const delete_blog_search = `-- name: delete_blog_search :exec
DELETE FROM blogsSearch
WHERE blogs_idblogs = ?
`

func (q *Queries) delete_blog_search(ctx context.Context, blogsIdblogs int32) error {
	_, err := q.db.ExecContext(ctx, delete_blog_search, blogsIdblogs)
	return err
}

const delete_bookmarks = `-- name: delete_bookmarks :exec
DELETE FROM bookmarks
WHERE users_idusers = ?
`

// This query deletes all entries from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) delete_bookmarks(ctx context.Context, usersIdusers int32) error {
	_, err := q.db.ExecContext(ctx, delete_bookmarks, usersIdusers)
	return err
}

const delete_category = `-- name: delete_category :exec
DELETE FROM faqCategories
WHERE idfaqCategories = ?
`

func (q *Queries) delete_category(ctx context.Context, idfaqcategories int32) error {
	_, err := q.db.ExecContext(ctx, delete_category, idfaqcategories)
	return err
}

const doCalled = `-- name: doCalled :many
SELECT s.news, s.idsiteNews, u.idusers, s.language_idlanguage
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
WHERE s.idsiteNews = $1
`

type doCalledRow struct {
	News               sql.NullString
	Idsitenews         int32
	Idusers            sql.NullInt32
	LanguageIdlanguage int32
}

func (q *Queries) doCalled(ctx context.Context) ([]*doCalledRow, error) {
	rows, err := q.db.QueryContext(ctx, doCalled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*doCalledRow
	for rows.Next() {
		var i doCalledRow
		if err := rows.Scan(
			&i.News,
			&i.Idsitenews,
			&i.Idusers,
			&i.LanguageIdlanguage,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const editNewsPost = `-- name: editNewsPost :exec
UPDATE siteNews SET news = $1, language_idlanguage = $2 WHERE idsiteNews = $3
`

func (q *Queries) editNewsPost(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, editNewsPost)
	return err
}

const existsTopicRestrictions = `-- name: existsTopicRestrictions :one
SELECT (forumtopic_idforumtopic) FROM topicrestrictions WHERE forumtopic_idforumtopic = $1
`

func (q *Queries) existsTopicRestrictions(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, existsTopicRestrictions)
	var forumtopic_idforumtopic int32
	err := row.Scan(&forumtopic_idforumtopic)
	return forumtopic_idforumtopic, err
}

const expandCategories = `-- name: expandCategories :many
SELECT f.idforumcategory, f.title, f.description
FROM forumcategory f WHERE f.forumcategory_idforumcategory = $1
`

type expandCategoriesRow struct {
	Idforumcategory int32
	Title           sql.NullString
	Description     sql.NullString
}

func (q *Queries) expandCategories(ctx context.Context) ([]*expandCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, expandCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*expandCategoriesRow
	for rows.Next() {
		var i expandCategoriesRow
		if err := rows.Scan(&i.Idforumcategory, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findForumTopicByName = `-- name: findForumTopicByName :one
SELECT idforumtopic FROM forumtopic WHERE title=?
`

func (q *Queries) findForumTopicByName(ctx context.Context, title sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, findForumTopicByName, title)
	var idforumtopic int32
	err := row.Scan(&idforumtopic)
	return idforumtopic, err
}

const getLangs = `-- name: getLangs :one
SELECT language_idlanguage FROM userlang WHERE users_idusers = ?
`

func (q *Queries) getLangs(ctx context.Context, usersIdusers int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getLangs, usersIdusers)
	var language_idlanguage int32
	err := row.Scan(&language_idlanguage)
	return language_idlanguage, err
}

const getNewsThreadId = `-- name: getNewsThreadId :one
SELECT s.forumthread_idforumthread FROM siteNews s, users u
WHERE s.users_idusers = u.idusers AND s.idsiteNews = $1
`

func (q *Queries) getNewsThreadId(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNewsThreadId)
	var forumthread_idforumthread int32
	err := row.Scan(&forumthread_idforumthread)
	return forumthread_idforumthread, err
}

const getSecurityLevel = `-- name: getSecurityLevel :one
SELECT level FROM permissions WHERE users_idusers = ? AND (section = ? OR section = 'all')
`

type getSecurityLevelParams struct {
	UsersIdusers int32
	Section      sql.NullString
}

func (q *Queries) getSecurityLevel(ctx context.Context, arg getSecurityLevelParams) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getSecurityLevel, arg.UsersIdusers, arg.Section)
	var level sql.NullString
	err := row.Scan(&level)
	return level, err
}

const getUsersTopicLevel = `-- name: getUsersTopicLevel :one
SELECT level FROM userstopiclevel WHERE forumtopic_idforumtopic = $1 AND users_idusers = $2
`

func (q *Queries) getUsersTopicLevel(ctx context.Context) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getUsersTopicLevel)
	var level sql.NullInt32
	err := row.Scan(&level)
	return level, err
}

const getUsersTopicLevelInviteMax = `-- name: getUsersTopicLevelInviteMax :one
SELECT invitemax FROM userstopiclevel WHERE forumtopic_idforumtopic = $1 AND users_idusers = $2
`

func (q *Queries) getUsersTopicLevelInviteMax(ctx context.Context) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getUsersTopicLevelInviteMax)
	var invitemax sql.NullInt32
	err := row.Scan(&invitemax)
	return invitemax, err
}

const getWordID = `-- name: getWordID :one
SELECT idsearchwordlist FROM searchwordlist WHERE word = lcase(?)
`

func (q *Queries) getWordID(ctx context.Context, lcase string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getWordID, lcase)
	var idsearchwordlist int32
	err := row.Scan(&idsearchwordlist)
	return idsearchwordlist, err
}

const lang_combobox = `-- name: lang_combobox :many
SELECT l.idlanguage, l.nameof FROM language l
`

func (q *Queries) lang_combobox(ctx context.Context) ([]*Language, error) {
	rows, err := q.db.QueryContext(ctx, lang_combobox)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Language
	for rows.Next() {
		var i Language
		if err := rows.Scan(&i.Idlanguage, &i.Nameof); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const makeCategory = `-- name: makeCategory :exec
INSERT INTO forumcategory (forumcategory_idforumcategory, title, description) VALUES (?, ?, ?)
`

type makeCategoryParams struct {
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) makeCategory(ctx context.Context, arg makeCategoryParams) error {
	_, err := q.db.ExecContext(ctx, makeCategory, arg.ForumcategoryIdforumcategory, arg.Title, arg.Description)
	return err
}

const makeImageBoard = `-- name: makeImageBoard :exec
INSERT INTO imageboard (imageboard_idimageboard, title, description) VALUES ($1, $2, $3)
`

func (q *Queries) makeImageBoard(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, makeImageBoard)
	return err
}

const makePost = `-- name: makePost :exec
INSERT INTO comments (language_idlanguage, users_idusers, forumthread_idforumthread, text, written)
VALUES (?, ?, ?, ?, NOW())
`

type makePostParams struct {
	LanguageIdlanguage       int32
	UsersIdusers             int32
	ForumthreadIdforumthread int32
	Text                     sql.NullString
}

func (q *Queries) makePost(ctx context.Context, arg makePostParams) error {
	_, err := q.db.ExecContext(ctx, makePost,
		arg.LanguageIdlanguage,
		arg.UsersIdusers,
		arg.ForumthreadIdforumthread,
		arg.Text,
	)
	return err
}

const makeThread = `-- name: makeThread :exec
INSERT INTO forumthread (forumtopic_idforumtopic) VALUES (?)
`

func (q *Queries) makeThread(ctx context.Context, forumtopicIdforumtopic int32) error {
	_, err := q.db.ExecContext(ctx, makeThread, forumtopicIdforumtopic)
	return err
}

const makeTopic = `-- name: makeTopic :exec
INSERT INTO forumtopic (forumcategory_idforumcategory, title, description) VALUES (?, ?, ?)
`

type makeTopicParams struct {
	ForumcategoryIdforumcategory int32
	Title                        sql.NullString
	Description                  sql.NullString
}

func (q *Queries) makeTopic(ctx context.Context, arg makeTopicParams) error {
	_, err := q.db.ExecContext(ctx, makeTopic, arg.ForumcategoryIdforumcategory, arg.Title, arg.Description)
	return err
}

const modify_faq = `-- name: modify_faq :exec
UPDATE faq
SET answer = ?, question = ?, faqCategories_idfaqCategories = ?
WHERE idfaq = ?
`

type modify_faqParams struct {
	Answer                       sql.NullString
	Question                     sql.NullString
	FaqcategoriesIdfaqcategories int32
	Idfaq                        int32
}

func (q *Queries) modify_faq(ctx context.Context, arg modify_faqParams) error {
	_, err := q.db.ExecContext(ctx, modify_faq,
		arg.Answer,
		arg.Question,
		arg.FaqcategoriesIdfaqcategories,
		arg.Idfaq,
	)
	return err
}

const moveToLinker = `-- name: moveToLinker :many
SELECT l.users_idusers, l.linkerCategory_idlinkerCategory, l.language_idlanguage, l.title, l.url, l.description
FROM linkerQueue l WHERE l.idlinkerQueue = $1
`

type moveToLinkerRow struct {
	UsersIdusers                   int32
	LinkercategoryIdlinkercategory int32
	LanguageIdlanguage             int32
	Title                          sql.NullString
	Url                            sql.NullString
	Description                    sql.NullString
}

func (q *Queries) moveToLinker(ctx context.Context) ([]*moveToLinkerRow, error) {
	rows, err := q.db.QueryContext(ctx, moveToLinker)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*moveToLinkerRow
	for rows.Next() {
		var i moveToLinkerRow
		if err := rows.Scan(
			&i.UsersIdusers,
			&i.LinkercategoryIdlinkercategory,
			&i.LanguageIdlanguage,
			&i.Title,
			&i.Url,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notifyChange = `-- name: notifyChange :many

SELECT email FROM users WHERE idusers = ?
`

// -- name: addToGeneralSearch :exec
// INSERT INTO ? (?, searchwordlist_idsearchwordlist) VALUES (?, ?)
func (q *Queries) notifyChange(ctx context.Context, idusers int32) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, notifyChange, idusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var email sql.NullString
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postUpdate = `-- name: postUpdate :exec
UPDATE comments c, forumthread th, forumtopic t
SET
th.lastposter=c.users_idusers, t.lastposter=c.users_idusers,
th.lastaddition=c.written, t.lastaddition=c.written,
t.comments=IF(th.comments IS NULL, 0, t.comments+1),
t.threads=IF(th.comments IS NULL, IF(t.threads IS NULL, 1, t.threads+1), t.threads),
th.comments=IF(th.comments IS NULL, 0, th.comments+1),
th.firstpost=IF(th.firstpost=0, c.idcomments, th.firstpost)
WHERE c.idcomments=?
`

func (q *Queries) postUpdate(ctx context.Context, idcomments int32) error {
	_, err := q.db.ExecContext(ctx, postUpdate, idcomments)
	return err
}

const preferencesRefreshPref = `-- name: preferencesRefreshPref :many
SELECT language_idlanguage FROM preferences WHERE users_idusers = ?
`

func (q *Queries) preferencesRefreshPref(ctx context.Context, usersIdusers int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, preferencesRefreshPref, usersIdusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var language_idlanguage int32
		if err := rows.Scan(&language_idlanguage); err != nil {
			return nil, err
		}
		items = append(items, language_idlanguage)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printBoardPosts = `-- name: printBoardPosts :many
SELECT i.description, i.thumbnail, i.fullimage, u.username, i.posted, i.idimagepost, IF(th.comments IS NULL, 0, th.comments + 1)
FROM imagepost i
LEFT JOIN users u ON i.users_idusers = u.idusers
LEFT JOIN forumthread th ON i.forumthread_idforumthread = th.idforumthread
WHERE i.imageboard_idimageboard = $1
ORDER BY i.posted DESC
`

type printBoardPostsRow struct {
	Description sql.NullString
	Thumbnail   sql.NullString
	Fullimage   sql.NullString
	Username    sql.NullString
	Posted      sql.NullTime
	Idimagepost int32
	If          interface{}
}

func (q *Queries) printBoardPosts(ctx context.Context) ([]*printBoardPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, printBoardPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printBoardPostsRow
	for rows.Next() {
		var i printBoardPostsRow
		if err := rows.Scan(
			&i.Description,
			&i.Thumbnail,
			&i.Fullimage,
			&i.Username,
			&i.Posted,
			&i.Idimagepost,
			&i.If,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printCategoryRoots = `-- name: printCategoryRoots :many
SELECT c3.idforumcategory, c3.title, c2.idforumcategory, c2.title, c1.title
FROM forumcategory c1
LEFT JOIN forumcategory c2 ON c2.idforumcategory = c1.forumcategory_idforumcategory
LEFT JOIN forumcategory c3 ON c3.idforumcategory = c2.forumcategory_idforumcategory
WHERE c1.idforumcategory = $1
`

type printCategoryRootsRow struct {
	Idforumcategory   sql.NullInt32
	Title             sql.NullString
	Idforumcategory_2 sql.NullInt32
	Title_2           sql.NullString
	Title_3           sql.NullString
}

func (q *Queries) printCategoryRoots(ctx context.Context) ([]*printCategoryRootsRow, error) {
	rows, err := q.db.QueryContext(ctx, printCategoryRoots)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printCategoryRootsRow
	for rows.Next() {
		var i printCategoryRootsRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.Title,
			&i.Idforumcategory_2,
			&i.Title_2,
			&i.Title_3,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printImagePost = `-- name: printImagePost :many
SELECT i.description, i.thumbnail, i.fullimage, u.username, i.posted, i.forumthread_idforumthread, i.idimagepost
FROM imagepost i
LEFT JOIN users u ON i.users_idusers = u.idusers
WHERE i.idimagepost = $1
`

type printImagePostRow struct {
	Description              sql.NullString
	Thumbnail                sql.NullString
	Fullimage                sql.NullString
	Username                 sql.NullString
	Posted                   sql.NullTime
	ForumthreadIdforumthread int32
	Idimagepost              int32
}

func (q *Queries) printImagePost(ctx context.Context) ([]*printImagePostRow, error) {
	rows, err := q.db.QueryContext(ctx, printImagePost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printImagePostRow
	for rows.Next() {
		var i printImagePostRow
		if err := rows.Scan(
			&i.Description,
			&i.Thumbnail,
			&i.Fullimage,
			&i.Username,
			&i.Posted,
			&i.ForumthreadIdforumthread,
			&i.Idimagepost,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printSubBoards = `-- name: printSubBoards :many
SELECT idimageboard, title, description FROM imageboard WHERE imageboard_idimageboard = $1
`

type printSubBoardsRow struct {
	Idimageboard int32
	Title        sql.NullString
	Description  sql.NullString
}

func (q *Queries) printSubBoards(ctx context.Context) ([]*printSubBoardsRow, error) {
	rows, err := q.db.QueryContext(ctx, printSubBoards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printSubBoardsRow
	for rows.Next() {
		var i printSubBoardsRow
		if err := rows.Scan(&i.Idimageboard, &i.Title, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printThread = `-- name: printThread :many
SELECT c.idcomments, c.text, c.written, u.username, u.idusers FROM comments c, users u
WHERE c.users_idusers=u.idusers AND c.forumthread_idforumthread=?
ORDER BY c.written
`

type printThreadRow struct {
	Idcomments int32
	Text       sql.NullString
	Written    sql.NullTime
	Username   sql.NullString
	Idusers    int32
}

func (q *Queries) printThread(ctx context.Context, forumthreadIdforumthread int32) ([]*printThreadRow, error) {
	rows, err := q.db.QueryContext(ctx, printThread, forumthreadIdforumthread)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printThreadRow
	for rows.Next() {
		var i printThreadRow
		if err := rows.Scan(
			&i.Idcomments,
			&i.Text,
			&i.Written,
			&i.Username,
			&i.Idusers,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printTopic = `-- name: printTopic :many
SELECT LEFT(c.text, 255), fu.username, c.written, lu.username, t.lastaddition, t.idforumthread, t.comments, r.viewlevel, u.level
FROM forumthread t
LEFT JOIN topicrestrictions r ON t.forumtopic_idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.forumtopic_idforumtopic AND u.users_idusers = $1
LEFT JOIN comments c ON c.idcomments = t.firstpost
LEFT JOIN users fu ON fu.idusers = c.users_idusers
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE t.forumtopic_idforumcategory = $2
ORDER BY t.lastaddition DESC
`

type printTopicRow struct {
	Left          string
	Username      sql.NullString
	Written       sql.NullTime
	Username_2    sql.NullString
	Lastaddition  sql.NullTime
	Idforumthread int32
	Comments      sql.NullInt32
	Viewlevel     sql.NullInt32
	Level         sql.NullInt32
}

func (q *Queries) printTopic(ctx context.Context) ([]*printTopicRow, error) {
	rows, err := q.db.QueryContext(ctx, printTopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printTopicRow
	for rows.Next() {
		var i printTopicRow
		if err := rows.Scan(
			&i.Left,
			&i.Username,
			&i.Written,
			&i.Username_2,
			&i.Lastaddition,
			&i.Idforumthread,
			&i.Comments,
			&i.Viewlevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printTopicRestrictions = `-- name: printTopicRestrictions :many
SELECT idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, t.title, r.forumtopic_idforumtopic, r.modlevel, r.adminlevel
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
WHERE idforumtopic = $1
`

type printTopicRestrictionsRow struct {
	Idforumtopic           int32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Title                  sql.NullString
	ForumtopicIdforumtopic sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
}

func (q *Queries) printTopicRestrictions(ctx context.Context) ([]*printTopicRestrictionsRow, error) {
	rows, err := q.db.QueryContext(ctx, printTopicRestrictions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printTopicRestrictionsRow
	for rows.Next() {
		var i printTopicRestrictionsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Viewlevel,
			&i.Replylevel,
			&i.Newthreadlevel,
			&i.Seelevel,
			&i.Invitelevel,
			&i.Readlevel,
			&i.Title,
			&i.ForumtopicIdforumtopic,
			&i.Modlevel,
			&i.Adminlevel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const printTopicRoots = `-- name: printTopicRoots :many
SELECT c3.idforumcategory, c3.title, c2.idforumcategory, c2.title, c1.idforumcategory, c1.title, t.title
FROM forumtopic t
LEFT JOIN forumcategory c1 ON c1.idforumcategory = t.forumcategory_idforumcategory
LEFT JOIN forumcategory c2 ON c2.idforumcategory = c1.forumcategory_idforumcategory
LEFT JOIN forumcategory c3 ON c3.idforumcategory = c2.forumcategory_idforumcategory
WHERE t.idforumtopic = $1
`

type printTopicRootsRow struct {
	Idforumcategory   sql.NullInt32
	Title             sql.NullString
	Idforumcategory_2 sql.NullInt32
	Title_2           sql.NullString
	Idforumcategory_3 sql.NullInt32
	Title_3           sql.NullString
	Title_4           sql.NullString
}

func (q *Queries) printTopicRoots(ctx context.Context) ([]*printTopicRootsRow, error) {
	rows, err := q.db.QueryContext(ctx, printTopicRoots)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*printTopicRootsRow
	for rows.Next() {
		var i printTopicRootsRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.Title,
			&i.Idforumcategory_2,
			&i.Title_2,
			&i.Idforumcategory_3,
			&i.Title_3,
			&i.Title_4,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reassign_category = `-- name: reassign_category :exec
UPDATE faq
SET faqCategories_idfaqCategories = ?
WHERE idfaq = ?
`

type reassign_categoryParams struct {
	FaqcategoriesIdfaqcategories int32
	Idfaq                        int32
}

func (q *Queries) reassign_category(ctx context.Context, arg reassign_categoryParams) error {
	_, err := q.db.ExecContext(ctx, reassign_category, arg.FaqcategoriesIdfaqcategories, arg.Idfaq)
	return err
}

const remakeBlogSearch = `-- name: remakeBlogSearch :exec
INSERT INTO blogsSearch (text, blogs_idblogs)
SELECT blog, idblogs
FROM blogs
`

// This query selects data from the "blogs" table and populates the "blogsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "blogsSearch" using the "blogs_idblogs".
func (q *Queries) remakeBlogSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeBlogSearch)
	return err
}

const remakeBlogsSearchInsert = `-- name: remakeBlogsSearchInsert :exec
INSERT INTO blogsSearch (text, blogs_idblogs)
SELECT blog, idblogs
FROM blogs
`

// This query selects data from the "blogs" table and populates the "blogsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "blogsSearch" using the "blogs_idblogs".
func (q *Queries) remakeBlogsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeBlogsSearchInsert)
	return err
}

const remakeCommentsSearch = `-- name: remakeCommentsSearch :exec
INSERT INTO commentsSearch (text, comments_idcomments)
SELECT text, idcomments
FROM comments
`

// This query selects data from the "comments" table and populates the "commentsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "commentsSearch" using the "comments_idcomments".
func (q *Queries) remakeCommentsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeCommentsSearch)
	return err
}

const remakeCommentsSearchInsert = `-- name: remakeCommentsSearchInsert :exec
INSERT INTO commentsSearch (text, comments_idcomments)
SELECT text, idcomments
FROM comments
`

// This query selects data from the "comments" table and populates the "commentsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "commentsSearch" using the "comments_idcomments".
func (q *Queries) remakeCommentsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeCommentsSearchInsert)
	return err
}

const remakeLinkerSearch = `-- name: remakeLinkerSearch :exec
INSERT INTO linkerSearch (text, linker_idlinker)
SELECT CONCAT(title, ' ', description), idlinker
FROM linker
`

// This query selects data from the "linker" table and populates the "linkerSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "linkerSearch" using the "linker_idlinker".
func (q *Queries) remakeLinkerSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeLinkerSearch)
	return err
}

const remakeLinkerSearchInsert = `-- name: remakeLinkerSearchInsert :exec
INSERT INTO linkerSearch (text, linker_idlinker)
SELECT CONCAT(title, ' ', description), idlinker
FROM linker
`

// This query selects data from the "linker" table and populates the "linkerSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "linkerSearch" using the "linker_idlinker".
func (q *Queries) remakeLinkerSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeLinkerSearchInsert)
	return err
}

const remakeNewsSearch = `-- name: remakeNewsSearch :exec
INSERT INTO siteNewsSearch (text, siteNews_idsiteNews)
SELECT news, idsiteNews
FROM siteNews
`

// This query selects data from the "siteNews" table and populates the "siteNewsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "siteNewsSearch" using the "siteNews_idsiteNews".
func (q *Queries) remakeNewsSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeNewsSearch)
	return err
}

const remakeNewsSearchInsert = `-- name: remakeNewsSearchInsert :exec
INSERT INTO siteNewsSearch (text, siteNews_idsiteNews)
SELECT news, idsiteNews
FROM siteNews
`

// This query selects data from the "siteNews" table and populates the "siteNewsSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "siteNewsSearch" using the "siteNews_idsiteNews".
func (q *Queries) remakeNewsSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeNewsSearchInsert)
	return err
}

const remakeWritingSearch = `-- name: remakeWritingSearch :exec
INSERT INTO writingSearch (text, writing_idwriting)
SELECT CONCAT(title, ' ', abstract, ' ', writting), idwriting
FROM writing
`

// This query selects data from the "writing" table and populates the "writingSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "writingSearch" using the "writing_idwriting".
func (q *Queries) remakeWritingSearch(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeWritingSearch)
	return err
}

const remakeWritingSearchInsert = `-- name: remakeWritingSearchInsert :exec
INSERT INTO writingSearch (text, writing_idwriting)
SELECT CONCAT(title, ' ', abstract, ' ', writting), idwriting
FROM writing
`

// This query selects data from the "writing" table and populates the "writingSearch" table with the specified columns.
// Then, it iterates over the "queue" linked list to add each text and ID pair to the "writingSearch" using the "writing_idwriting".
func (q *Queries) remakeWritingSearchInsert(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, remakeWritingSearchInsert)
	return err
}

const renameCategory = `-- name: renameCategory :exec
UPDATE linkerCategory SET title = $1 WHERE idlinkerCategory = $2
`

func (q *Queries) renameCategory(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, renameCategory)
	return err
}

const renameLanguage = `-- name: renameLanguage :exec
UPDATE language
SET nameof = $1
WHERE idlanguage = $2
`

// This query updates the "nameof" field in the "language" table based on the provided "cid".
// Parameters:
//
//	$1 - New name for the language (string)
//	$2 - Language ID to be updated (int)
func (q *Queries) renameLanguage(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, renameLanguage)
	return err
}

const rename_category = `-- name: rename_category :exec
UPDATE faqCategories
SET name = ?
WHERE idfaqCategories = ?
`

type rename_categoryParams struct {
	Name            sql.NullString
	Idfaqcategories int32
}

func (q *Queries) rename_category(ctx context.Context, arg rename_categoryParams) error {
	_, err := q.db.ExecContext(ctx, rename_category, arg.Name, arg.Idfaqcategories)
	return err
}

const setTopicRestrictions = `-- name: setTopicRestrictions :exec
UPDATE topicrestrictions SET viewlevel = $1, replylevel = $2, newthreadlevel = $3, seelevel = $4, invitelevel = $5, readlevel = $6, modlevel = $7, adminlevel = $8
WHERE forumtopic_idforumtopic = $9
`

func (q *Queries) setTopicRestrictions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, setTopicRestrictions)
	return err
}

const setUsersTopicLevel = `-- name: setUsersTopicLevel :exec
UPDATE userstopiclevel SET level = $3, invitemax = $4 WHERE forumtopic_idforumtopic = $1 AND users_idusers = $2
`

func (q *Queries) setUsersTopicLevel(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, setUsersTopicLevel)
	return err
}

const showAdminQueue = `-- name: showAdminQueue :many
SELECT l.title, l.url, l.description, u.username, l.idlinkerQueue, c.title, c.idlinkerCategory
FROM linkerQueue l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory c ON l.linkerCategory_idlinkerCategory = c.idlinkerCategory
`

type showAdminQueueRow struct {
	Title            sql.NullString
	Url              sql.NullString
	Description      sql.NullString
	Username         sql.NullString
	Idlinkerqueue    int32
	Title_2          sql.NullString
	Idlinkercategory int32
}

func (q *Queries) showAdminQueue(ctx context.Context) ([]*showAdminQueueRow, error) {
	rows, err := q.db.QueryContext(ctx, showAdminQueue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showAdminQueueRow
	for rows.Next() {
		var i showAdminQueueRow
		if err := rows.Scan(
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Username,
			&i.Idlinkerqueue,
			&i.Title_2,
			&i.Idlinkercategory,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showAllBoards = `-- name: showAllBoards :many
SELECT b.idimageboard, b.title, b.description, b.imageboard_idimageboard, pb.title
FROM imageboard b
LEFT JOIN imageboard pb ON b.imageboard_idimageboard = pb.idimageboard OR b.imageboard_idimageboard = 0
GROUP BY b.idimageboard
`

type showAllBoardsRow struct {
	Idimageboard           int32
	Title                  sql.NullString
	Description            sql.NullString
	ImageboardIdimageboard int32
	Title_2                sql.NullString
}

func (q *Queries) showAllBoards(ctx context.Context) ([]*showAllBoardsRow, error) {
	rows, err := q.db.QueryContext(ctx, showAllBoards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showAllBoardsRow
	for rows.Next() {
		var i showAllBoardsRow
		if err := rows.Scan(
			&i.Idimageboard,
			&i.Title,
			&i.Description,
			&i.ImageboardIdimageboard,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showAllCategories = `-- name: showAllCategories :many
SELECT c.idforumcategory, c.title, c.description, c.forumcategory_idforumcategory, c2.title
FROM forumcategory c
LEFT JOIN forumcategory c2 ON c.forumcategory_idforumcategory = c2.idforumcategory
`

type showAllCategoriesRow struct {
	Idforumcategory              int32
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	Title_2                      sql.NullString
}

func (q *Queries) showAllCategories(ctx context.Context) ([]*showAllCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, showAllCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showAllCategoriesRow
	for rows.Next() {
		var i showAllCategoriesRow
		if err := rows.Scan(
			&i.Idforumcategory,
			&i.Title,
			&i.Description,
			&i.ForumcategoryIdforumcategory,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showAllTopics = `-- name: showAllTopics :many
SELECT t.idforumtopic, t.title, t.description, t.forumcategory_idforumcategory, c.title
FROM forumtopic t
LEFT JOIN forumcategory c ON t.forumcategory_idforumcategory = c.idforumcategory
GROUP BY t.idforumtopic
`

type showAllTopicsRow struct {
	Idforumtopic                 int32
	Title                        sql.NullString
	Description                  sql.NullString
	ForumcategoryIdforumcategory int32
	Title_2                      sql.NullString
}

func (q *Queries) showAllTopics(ctx context.Context) ([]*showAllTopicsRow, error) {
	rows, err := q.db.QueryContext(ctx, showAllTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showAllTopicsRow
	for rows.Next() {
		var i showAllTopicsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Title,
			&i.Description,
			&i.ForumcategoryIdforumcategory,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showCategories = `-- name: showCategories :many
SELECT idlinkerCategory, title FROM linkerCategory
`

func (q *Queries) showCategories(ctx context.Context) ([]*Linkercategory, error) {
	rows, err := q.db.QueryContext(ctx, showCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Linkercategory
	for rows.Next() {
		var i Linkercategory
		if err := rows.Scan(&i.Idlinkercategory, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showLatest = `-- name: showLatest :many
SELECT l.title, l.url, l.description, u.username, l.idlinker, l.listed,
       IF(th.comments IS NULL, 0, th.comments+1), lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory lc ON l.linkerCategory_idlinkerCategory = lc.idlinkerCategory
WHERE l.linkerCategory_idlinkerCategory = $1
ORDER BY l.listed DESC
`

type showLatestRow struct {
	Title       sql.NullString
	Url         sql.NullString
	Description sql.NullString
	Username    sql.NullString
	Idlinker    int32
	Listed      sql.NullTime
	If          interface{}
	Title_2     sql.NullString
}

func (q *Queries) showLatest(ctx context.Context) ([]*showLatestRow, error) {
	rows, err := q.db.QueryContext(ctx, showLatest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showLatestRow
	for rows.Next() {
		var i showLatestRow
		if err := rows.Scan(
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Username,
			&i.Idlinker,
			&i.Listed,
			&i.If,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showLinkComments = `-- name: showLinkComments :many
SELECT l.title, l.url, l.description, u.username, l.listed, l.forumthread_idforumthread, lc.title
FROM linker l
JOIN users u ON l.users_idusers = u.idusers
JOIN linkerCategory lc ON l.linkerCategory_idlinkerCategory = lc.idlinkerCategory
WHERE l.idlinker = $1
`

type showLinkCommentsRow struct {
	Title                    sql.NullString
	Url                      sql.NullString
	Description              sql.NullString
	Username                 sql.NullString
	Listed                   sql.NullTime
	ForumthreadIdforumthread int32
	Title_2                  sql.NullString
}

func (q *Queries) showLinkComments(ctx context.Context) ([]*showLinkCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, showLinkComments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showLinkCommentsRow
	for rows.Next() {
		var i showLinkCommentsRow
		if err := rows.Scan(
			&i.Title,
			&i.Url,
			&i.Description,
			&i.Username,
			&i.Listed,
			&i.ForumthreadIdforumthread,
			&i.Title_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showNews = `-- name: showNews :one
SELECT count(idsiteNews) FROM siteNews
WHERE $1 AND $2
`

func (q *Queries) showNews(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, showNews)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const showNewsPosts = `-- name: showNewsPosts :many
SELECT u.username, s.news, s.occured, s.idsiteNews, u.idusers, IF(th.comments IS NULL, 0, th.comments + 1)
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
LEFT JOIN forumthread th ON s.forumthread_idforumthread = th.idforumthread
WHERE $1 AND $2
ORDER BY s.occured DESC
LIMIT 10
`

type showNewsPostsRow struct {
	Username   sql.NullString
	News       sql.NullString
	Occured    sql.NullTime
	Idsitenews int32
	Idusers    sql.NullInt32
	If         interface{}
}

func (q *Queries) showNewsPosts(ctx context.Context) ([]*showNewsPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, showNewsPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showNewsPostsRow
	for rows.Next() {
		var i showNewsPostsRow
		if err := rows.Scan(
			&i.Username,
			&i.News,
			&i.Occured,
			&i.Idsitenews,
			&i.Idusers,
			&i.If,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showPost = `-- name: showPost :many
SELECT u.username, s.news, s.occured, s.idsiteNews, u.idusers, s.forumthread_idforumthread
FROM siteNews s
LEFT JOIN users u ON s.users_idusers = u.idusers
WHERE s.idsiteNews = $1
`

type showPostRow struct {
	Username                 sql.NullString
	News                     sql.NullString
	Occured                  sql.NullTime
	Idsitenews               int32
	Idusers                  sql.NullInt32
	ForumthreadIdforumthread int32
}

func (q *Queries) showPost(ctx context.Context) ([]*showPostRow, error) {
	rows, err := q.db.QueryContext(ctx, showPost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showPostRow
	for rows.Next() {
		var i showPostRow
		if err := rows.Scan(
			&i.Username,
			&i.News,
			&i.Occured,
			&i.Idsitenews,
			&i.Idusers,
			&i.ForumthreadIdforumthread,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showTableTopics = `-- name: showTableTopics :many
SELECT t.idforumtopic, t.title, t.description, t.comments, t.threads, t.lastaddition, lu.username, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = $1
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE forumcategory_idforumcategory = $2 AND IF(r.seelevel IS NOT NULL, r.seelevel , 0) <= IF(u.level IS NOT NULL, u.level, 0)
ORDER BY t.lastaddition DESC
`

type showTableTopicsRow struct {
	Idforumtopic int32
	Title        sql.NullString
	Description  sql.NullString
	Comments     sql.NullInt32
	Threads      sql.NullInt32
	Lastaddition sql.NullTime
	Username     sql.NullString
	Seelevel     sql.NullInt32
	Level        sql.NullInt32
}

func (q *Queries) showTableTopics(ctx context.Context) ([]*showTableTopicsRow, error) {
	rows, err := q.db.QueryContext(ctx, showTableTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*showTableTopicsRow
	for rows.Next() {
		var i showTableTopicsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Title,
			&i.Description,
			&i.Comments,
			&i.Threads,
			&i.Lastaddition,
			&i.Username,
			&i.Seelevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const showTopicUserLevels = `-- name: showTopicUserLevels :one
SELECT r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, r.modlevel, r.adminlevel
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
WHERE idforumtopic = $1
`

type showTopicUserLevelsRow struct {
	Viewlevel      sql.NullInt32
	Replylevel     sql.NullInt32
	Newthreadlevel sql.NullInt32
	Seelevel       sql.NullInt32
	Invitelevel    sql.NullInt32
	Readlevel      sql.NullInt32
	Modlevel       sql.NullInt32
	Adminlevel     sql.NullInt32
}

func (q *Queries) showTopicUserLevels(ctx context.Context) (*showTopicUserLevelsRow, error) {
	row := q.db.QueryRowContext(ctx, showTopicUserLevels)
	var i showTopicUserLevelsRow
	err := row.Scan(
		&i.Viewlevel,
		&i.Replylevel,
		&i.Newthreadlevel,
		&i.Seelevel,
		&i.Invitelevel,
		&i.Readlevel,
		&i.Modlevel,
		&i.Adminlevel,
	)
	return &i, err
}

const show_blog_comments = `-- name: show_blog_comments :many
SELECT b.blog, b.written, u.username, b.idblogs, b.forumthread_idforumthread
FROM blogs b, users u
WHERE b.users_idusers = u.idusers AND b.idblogs = ?
`

type show_blog_commentsRow struct {
	Blog                     sql.NullString
	Written                  sql.NullTime
	Username                 sql.NullString
	Idblogs                  int32
	ForumthreadIdforumthread int32
}

func (q *Queries) show_blog_comments(ctx context.Context, idblogs int32) ([]*show_blog_commentsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_blog_comments, idblogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_blog_commentsRow
	for rows.Next() {
		var i show_blog_commentsRow
		if err := rows.Scan(
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Idblogs,
			&i.ForumthreadIdforumthread,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_blog_edit = `-- name: show_blog_edit :many
SELECT b.blog, b.language_idlanguage
FROM blogs b, users u
WHERE b.users_idusers = u.idusers AND b.idblogs = ?
`

type show_blog_editRow struct {
	Blog               sql.NullString
	LanguageIdlanguage int32
}

func (q *Queries) show_blog_edit(ctx context.Context, idblogs int32) ([]*show_blog_editRow, error) {
	rows, err := q.db.QueryContext(ctx, show_blog_edit, idblogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_blog_editRow
	for rows.Next() {
		var i show_blog_editRow
		if err := rows.Scan(&i.Blog, &i.LanguageIdlanguage); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_blogger_list = `-- name: show_blogger_list :many
SELECT u.username, COUNT(b.idblogs)
FROM blogs b, users u
WHERE b.users_idusers = u.idusers
GROUP BY u.idusers
`

type show_blogger_listRow struct {
	Username sql.NullString
	Count    int64
}

func (q *Queries) show_blogger_list(ctx context.Context) ([]*show_blogger_listRow, error) {
	rows, err := q.db.QueryContext(ctx, show_blogger_list)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_blogger_listRow
	for rows.Next() {
		var i show_blogger_listRow
		if err := rows.Scan(&i.Username, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_bookmarks = `-- name: show_bookmarks :one
SELECT list
FROM bookmarks
WHERE users_idusers = ?
`

// This query retrieves the "list" from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) show_bookmarks(ctx context.Context, usersIdusers int32) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, show_bookmarks, usersIdusers)
	var list sql.NullString
	err := row.Scan(&list)
	return list, err
}

const show_categories = `-- name: show_categories :exec
SELECT f.idforumcategory, f.title, f.description
FROM forumcategory f WHERE f.forumcategory_idforumcategory = $1
`

type show_categoriesRow struct {
	Idforumcategory int32
	Title           sql.NullString
	Description     sql.NullString
}

func (q *Queries) show_categories(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, show_categories)
	return err
}

const show_latest_blogs = `-- name: show_latest_blogs :many
SELECT b.blog, b.written, u.username, b.idblogs, IF(th.comments IS NULL, 0, th.comments + 1), b.users_idusers
FROM blogs b, users u
LEFT JOIN forumthread th ON b.forumthread_idforumthread = th.idforumthread
WHERE b.users_idusers = ? AND (b.language_idlanguage = ?)
ORDER BY b.written DESC
LIMIT ? OFFSET ?
`

type show_latest_blogsParams struct {
	UsersIdusers       int32
	LanguageIdlanguage int32
	Limit              int32
	Offset             int32
}

type show_latest_blogsRow struct {
	Blog         sql.NullString
	Written      sql.NullTime
	Username     sql.NullString
	Idblogs      int32
	If           interface{}
	UsersIdusers int32
}

func (q *Queries) show_latest_blogs(ctx context.Context, arg show_latest_blogsParams) ([]*show_latest_blogsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_latest_blogs,
		arg.UsersIdusers,
		arg.LanguageIdlanguage,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_latest_blogsRow
	for rows.Next() {
		var i show_latest_blogsRow
		if err := rows.Scan(
			&i.Blog,
			&i.Written,
			&i.Username,
			&i.Idblogs,
			&i.If,
			&i.UsersIdusers,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_questions = `-- name: show_questions :many
SELECT c.idfaqCategories, c.name, f.question, f.answer
FROM faq f, faqCategories c
WHERE c.idfaqCategories <> ? AND f.answer IS NOT NULL AND c.idfaqCategories = f.faqCategories_idfaqCategories AND (c.idfaqCategories = ?)
ORDER BY c.idfaqCategories
`

type show_questionsParams struct {
	Idfaqcategories   int32
	Idfaqcategories_2 int32
}

type show_questionsRow struct {
	Idfaqcategories int32
	Name            sql.NullString
	Question        sql.NullString
	Answer          sql.NullString
}

func (q *Queries) show_questions(ctx context.Context, arg show_questionsParams) ([]*show_questionsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_questions, arg.Idfaqcategories, arg.Idfaqcategories_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_questionsRow
	for rows.Next() {
		var i show_questionsRow
		if err := rows.Scan(
			&i.Idfaqcategories,
			&i.Name,
			&i.Question,
			&i.Answer,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const show_topics = `-- name: show_topics :many
SELECT t.idforumtopic, t.title, t.description, t.comments, t.threads, t.lastaddition, lu.username, r.seelevel, u.level
FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic = t.idforumtopic AND u.users_idusers = $1
LEFT JOIN users lu ON lu.idusers = t.lastposter
WHERE t.forumcategory_idforumcategory = $2
ORDER BY t.lastaddition DESC
`

type show_topicsRow struct {
	Idforumtopic int32
	Title        sql.NullString
	Description  sql.NullString
	Comments     sql.NullInt32
	Threads      sql.NullInt32
	Lastaddition sql.NullTime
	Username     sql.NullString
	Seelevel     sql.NullInt32
	Level        sql.NullInt32
}

func (q *Queries) show_topics(ctx context.Context) ([]*show_topicsRow, error) {
	rows, err := q.db.QueryContext(ctx, show_topics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*show_topicsRow
	for rows.Next() {
		var i show_topicsRow
		if err := rows.Scan(
			&i.Idforumtopic,
			&i.Title,
			&i.Description,
			&i.Comments,
			&i.Threads,
			&i.Lastaddition,
			&i.Username,
			&i.Seelevel,
			&i.Level,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const somethingNotifyBlogs = `-- name: somethingNotifyBlogs :exec
SELECT u.email FROM blogs t, users u, preferences p
WHERE t.idblogs=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type somethingNotifyBlogsParams struct {
	Idblogs int32
	Idusers int32
}

func (q *Queries) somethingNotifyBlogs(ctx context.Context, arg somethingNotifyBlogsParams) error {
	_, err := q.db.ExecContext(ctx, somethingNotifyBlogs, arg.Idblogs, arg.Idusers)
	return err
}

const somethingNotifyLinker = `-- name: somethingNotifyLinker :exec
SELECT u.email FROM linker t, users u, preferences p
WHERE t.idlinker=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type somethingNotifyLinkerParams struct {
	Idlinker int32
	Idusers  int32
}

func (q *Queries) somethingNotifyLinker(ctx context.Context, arg somethingNotifyLinkerParams) error {
	_, err := q.db.ExecContext(ctx, somethingNotifyLinker, arg.Idlinker, arg.Idusers)
	return err
}

const somethingNotifyWriting = `-- name: somethingNotifyWriting :exec
SELECT u.email FROM writing t, users u, preferences p
WHERE t.idwriting=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=t.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type somethingNotifyWritingParams struct {
	Idwriting int32
	Idusers   int32
}

func (q *Queries) somethingNotifyWriting(ctx context.Context, arg somethingNotifyWritingParams) error {
	_, err := q.db.ExecContext(ctx, somethingNotifyWriting, arg.Idwriting, arg.Idusers)
	return err
}

const threadAllowThis = `-- name: threadAllowThis :one
SELECT r.forumtopic_idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, r.modlevel, r.adminlevel, u.level FROM forumthread t
LEFT JOIN topicrestrictions r ON t.forumtopic_idforumtopic=r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic=t.forumtopic_idforumtopic AND u.users_idusers=?
WHERE t.idforumthread=? LIMIT 1
`

type threadAllowThisParams struct {
	UsersIdusers  int32
	Idforumthread int32
}

type threadAllowThisRow struct {
	ForumtopicIdforumtopic sql.NullInt32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
	Level                  sql.NullInt32
}

func (q *Queries) threadAllowThis(ctx context.Context, arg threadAllowThisParams) (*threadAllowThisRow, error) {
	row := q.db.QueryRowContext(ctx, threadAllowThis, arg.UsersIdusers, arg.Idforumthread)
	var i threadAllowThisRow
	err := row.Scan(
		&i.ForumtopicIdforumtopic,
		&i.Viewlevel,
		&i.Replylevel,
		&i.Newthreadlevel,
		&i.Seelevel,
		&i.Invitelevel,
		&i.Readlevel,
		&i.Modlevel,
		&i.Adminlevel,
		&i.Level,
	)
	return &i, err
}

const threadNotify = `-- name: threadNotify :exec
SELECT u.email FROM comments c, users u, preferences p
WHERE c.forumthread_idforumthread=? AND u.idusers=p.users_idusers AND p.emailforumupdates=1 AND u.idusers=c.users_idusers AND u.idusers!=?
GROUP BY u.idusers
`

type threadNotifyParams struct {
	ForumthreadIdforumthread int32
	Idusers                  int32
}

func (q *Queries) threadNotify(ctx context.Context, arg threadNotifyParams) error {
	_, err := q.db.ExecContext(ctx, threadNotify, arg.ForumthreadIdforumthread, arg.Idusers)
	return err
}

const topicAllowThis = `-- name: topicAllowThis :one
SELECT r.forumtopic_idforumtopic, r.viewlevel, r.replylevel, r.newthreadlevel, r.seelevel, r.invitelevel, r.readlevel, r.modlevel, r.adminlevel, u.level FROM forumtopic t
LEFT JOIN topicrestrictions r ON t.idforumtopic=r.forumtopic_idforumtopic
LEFT JOIN userstopiclevel u ON u.forumtopic_idforumtopic=t.idforumtopic AND u.users_idusers=?
WHERE t.idforumtopic=? LIMIT 1
`

type topicAllowThisParams struct {
	UsersIdusers int32
	Idforumtopic int32
}

type topicAllowThisRow struct {
	ForumtopicIdforumtopic sql.NullInt32
	Viewlevel              sql.NullInt32
	Replylevel             sql.NullInt32
	Newthreadlevel         sql.NullInt32
	Seelevel               sql.NullInt32
	Invitelevel            sql.NullInt32
	Readlevel              sql.NullInt32
	Modlevel               sql.NullInt32
	Adminlevel             sql.NullInt32
	Level                  sql.NullInt32
}

func (q *Queries) topicAllowThis(ctx context.Context, arg topicAllowThisParams) (*topicAllowThisRow, error) {
	row := q.db.QueryRowContext(ctx, topicAllowThis, arg.UsersIdusers, arg.Idforumtopic)
	var i topicAllowThisRow
	err := row.Scan(
		&i.ForumtopicIdforumtopic,
		&i.Viewlevel,
		&i.Replylevel,
		&i.Newthreadlevel,
		&i.Seelevel,
		&i.Invitelevel,
		&i.Readlevel,
		&i.Modlevel,
		&i.Adminlevel,
		&i.Level,
	)
	return &i, err
}

const updateQueue = `-- name: updateQueue :exec
UPDATE linkerQueue SET linkerCategory_idlinkerCategory = $1, title = $2, url = $3, description = $4 WHERE idlinkerQueue = $5
`

func (q *Queries) updateQueue(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, updateQueue)
	return err
}

const update_blog = `-- name: update_blog :exec
UPDATE blogs
SET language_idlanguage = ?, blog = ?
WHERE idblogs = ?
`

type update_blogParams struct {
	LanguageIdlanguage int32
	Blog               sql.NullString
	Idblogs            int32
}

func (q *Queries) update_blog(ctx context.Context, arg update_blogParams) error {
	_, err := q.db.ExecContext(ctx, update_blog, arg.LanguageIdlanguage, arg.Blog, arg.Idblogs)
	return err
}

const update_bookmarks = `-- name: update_bookmarks :exec
UPDATE bookmarks
SET list = ?
WHERE users_idusers = ?
`

type update_bookmarksParams struct {
	List         sql.NullString
	UsersIdusers int32
}

// This query updates the "list" column in the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) update_bookmarks(ctx context.Context, arg update_bookmarksParams) error {
	_, err := q.db.ExecContext(ctx, update_bookmarks, arg.List, arg.UsersIdusers)
	return err
}

const update_forumthread_comments = `-- name: update_forumthread_comments :exec
UPDATE forumthread
SET comments = (
    SELECT COUNT(users_idusers) - 1
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
)
`

// This query updates the "comments" column in the "forumthread" table.
// It sets the "comments" column to the count of users (excluding the thread creator) from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_comments(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_comments)
	return err
}

const update_forumthread_firstpost = `-- name: update_forumthread_firstpost :exec
UPDATE forumthread
SET firstpost = (
    SELECT idcomments
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    LIMIT 1
)
`

// This query updates the "firstpost" column in the "forumthread" table.
// It sets the "firstpost" column to the ID of the first comment from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_firstpost(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_firstpost)
	return err
}

const update_forumthread_lastaddition = `-- name: update_forumthread_lastaddition :exec
UPDATE forumthread
SET lastaddition = (
    SELECT written
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
)
`

// This query updates the "lastaddition" column in the "forumthread" table.
// It sets the "lastaddition" column to the latest "written" value from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_lastaddition(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_lastaddition)
	return err
}

const update_forumthread_lastposter = `-- name: update_forumthread_lastposter :exec
UPDATE forumthread
SET lastposter = (
    SELECT users_idusers
    FROM comments
    WHERE forumthread_idforumthread = idforumthread
    ORDER BY written DESC
    LIMIT 1
)
`

// This query updates the "lastposter" column in the "forumthread" table.
// It sets the "lastposter" column to the latest "users_idusers" value from the "comments" table for the corresponding "forumthread_idforumthread".
func (q *Queries) update_forumthread_lastposter(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumthread_lastposter)
	return err
}

const update_forumtopic_comments = `-- name: update_forumtopic_comments :exec
UPDATE forumtopic
SET comments = (
    SELECT SUM(comments)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
)
`

// This query updates the "comments" column in the "forumtopic" table.
// It sets the "comments" column to the sum of comments from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
func (q *Queries) update_forumtopic_comments(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic_comments)
	return err
}

const update_forumtopic_lastaddition_lastposter = `-- name: update_forumtopic_lastaddition_lastposter :exec
UPDATE forumtopic
SET lastaddition = (
    SELECT lastaddition
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
),
lastposter = (
    SELECT lastposter
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
    ORDER BY lastaddition DESC
    LIMIT 1
)
`

// This query updates the "lastaddition" and "lastposter" columns in the "forumtopic" table.
// It sets the "lastaddition" column to the latest "lastaddition" value from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
// It sets the "lastposter" column to the latest "lastposter" value from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
func (q *Queries) update_forumtopic_lastaddition_lastposter(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic_lastaddition_lastposter)
	return err
}

const update_forumtopic_threads = `-- name: update_forumtopic_threads :exec
UPDATE forumtopic
SET threads = (
    SELECT COUNT(idforumthread)
    FROM forumthread
    WHERE forumtopic_idforumtopic = idforumtopic
)
`

// This query updates the "threads" column in the "forumtopic" table.
// It sets the "threads" column to the count of forum threads from the "forumthread" table for the corresponding "forumtopic_idforumtopic".
func (q *Queries) update_forumtopic_threads(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, update_forumtopic_threads)
	return err
}

const userAllow = `-- name: userAllow :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES ($1, $2, $3)
`

// This query inserts a new permission into the "permissions" table.
// Parameters:
//
//	$1 - User ID to be associated with the permission (int)
//	$2 - Section for which the permission is granted (string)
//	$3 - Level of the permission (string)
func (q *Queries) userAllow(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, userAllow)
	return err
}

const userDisallow = `-- name: userDisallow :exec
DELETE FROM permissions
WHERE idpermissions = $1
`

// This query deletes a permission from the "permissions" table based on the provided "permid".
// Parameters:
//
//	$1 - Permission ID to be deleted (int)
func (q *Queries) userDisallow(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, userDisallow)
	return err
}

const user_allow = `-- name: user_allow :exec
INSERT INTO permissions (users_idusers, section, level)
VALUES (?, ?, ?)
`

type user_allowParams struct {
	UsersIdusers int32
	Section      sql.NullString
	Level        sql.NullString
}

func (q *Queries) user_allow(ctx context.Context, arg user_allowParams) error {
	_, err := q.db.ExecContext(ctx, user_allow, arg.UsersIdusers, arg.Section, arg.Level)
	return err
}

const user_disallow = `-- name: user_disallow :exec
DELETE FROM permissions
WHERE idpermissions = ? AND section = ?
`

type user_disallowParams struct {
	Idpermissions int32
	Section       sql.NullString
}

func (q *Queries) user_disallow(ctx context.Context, arg user_disallowParams) error {
	_, err := q.db.ExecContext(ctx, user_disallow, arg.Idpermissions, arg.Section)
	return err
}

const usernametouid = `-- name: usernametouid :one

SELECT idusers FROM users WHERE username = ?
`

// -- name: forumTopicSearch :many
// SELECT * FROM comments c
// LEFT JOIN forumthread th ON th.idforumthread = c.forumthread_idforumthread
// LEFT JOIN forumtopic t ON t.idforumtopic = th.forumtopic_idforumtopic
// LEFT JOIN userstopiclevel utl ON t.idforumtopic = utl.forumtopic_idforumtopic AND utl.users_idusers = ?
// LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
//
//	WHERE c.idcomments IN (?) AND th.idforumthread != 0 AND t.idforumtopic = ?
//
// AND ((r.readlevel <= utl.level AND r.viewlevel <= utl.level AND r.seelevel <= utl.level));
//
// -- name: forumSearch :many
// SELECT c.forumthread_idforumthread FROM comments c
// LEFT JOIN forumthread th ON th.idforumthread = c.forumthread_idforumthread
// LEFT JOIN forumtopic t ON t.idforumtopic = th.forumtopic_idforumtopic
// LEFT JOIN forumcategory fc ON fc.idforumcategory = t.forumcategory_idforumcategory
// LEFT JOIN userstopiclevel utl ON t.idforumtopic = utl.forumtopic_idforumtopic AND utl.users_idusers = ?
// LEFT JOIN topicrestrictions r ON t.idforumtopic = r.forumtopic_idforumtopic
// WHERE c.idcomments IN (?) AND th.idforumthread != 0 AND t.idforumtopic != 0
// AND ((r.readlevel <= utl.level AND r.viewlevel <= utl.level AND r.seelevel <= utl.level) OR ?)
// AND fc.idforumcategory != 0
// GROUP BY c.forumthread_idforumthread;
func (q *Queries) usernametouid(ctx context.Context, username sql.NullString) (int32, error) {
	row := q.db.QueryRowContext(ctx, usernametouid, username)
	var idusers int32
	err := row.Scan(&idusers)
	return idusers, err
}

const users_bookmarks = `-- name: users_bookmarks :one
SELECT list
FROM bookmarks
WHERE users_idusers = ?
`

// This query retrieves the "list" from the "bookmarks" table for a specific user based on their "users_idusers".
func (q *Queries) users_bookmarks(ctx context.Context, usersIdusers int32) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, users_bookmarks, usersIdusers)
	var list sql.NullString
	err := row.Scan(&list)
	return list, err
}

const writeLinkerRSS = `-- name: writeLinkerRSS :many
SELECT l.idlinker, l.title, l.description, l.url
FROM linker l
WHERE l.linkerCategory_idlinkerCategory = $1
ORDER BY l.listed DESC
`

type writeLinkerRSSRow struct {
	Idlinker    int32
	Title       sql.NullString
	Description sql.NullString
	Url         sql.NullString
}

func (q *Queries) writeLinkerRSS(ctx context.Context) ([]*writeLinkerRSSRow, error) {
	rows, err := q.db.QueryContext(ctx, writeLinkerRSS)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*writeLinkerRSSRow
	for rows.Next() {
		var i writeLinkerRSSRow
		if err := rows.Scan(
			&i.Idlinker,
			&i.Title,
			&i.Description,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const writeNewsPost = `-- name: writeNewsPost :exec
INSERT INTO siteNews (news, users_idusers, occured, language_idlanguage)
VALUES ($1, $2, NOW(), $3)
`

func (q *Queries) writeNewsPost(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, writeNewsPost)
	return err
}

const writeRSS = `-- name: writeRSS :exec
SELECT title, description FROM imageboard WHERE idimageboard = $1
`

type writeRSSRow struct {
	Title       sql.NullString
	Description sql.NullString
}

func (q *Queries) writeRSS(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, writeRSS)
	return err
}

const writeSiteNewsRSS = `-- name: writeSiteNewsRSS :many
SELECT s.idsiteNews, s.occured, s.news
FROM siteNews s
ORDER BY s.occured DESC LIMIT 15
`

type writeSiteNewsRSSRow struct {
	Idsitenews int32
	Occured    sql.NullTime
	News       sql.NullString
}

func (q *Queries) writeSiteNewsRSS(ctx context.Context) ([]*writeSiteNewsRSSRow, error) {
	rows, err := q.db.QueryContext(ctx, writeSiteNewsRSS)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*writeSiteNewsRSSRow
	for rows.Next() {
		var i writeSiteNewsRSSRow
		if err := rows.Scan(&i.Idsitenews, &i.Occured, &i.News); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const write_blog_atom = `-- name: write_blog_atom :many
SELECT b.idblogs, LEFT(b.written, 255), b.blog, u.username
FROM blogs b, users u
WHERE u.idusers = b.users_idusers AND b.users_idusers = ?
ORDER BY b.written DESC
LIMIT ?
`

type write_blog_atomParams struct {
	UsersIdusers int32
	Limit        int32
}

type write_blog_atomRow struct {
	Idblogs  int32
	Left     string
	Blog     sql.NullString
	Username sql.NullString
}

func (q *Queries) write_blog_atom(ctx context.Context, arg write_blog_atomParams) ([]*write_blog_atomRow, error) {
	rows, err := q.db.QueryContext(ctx, write_blog_atom, arg.UsersIdusers, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*write_blog_atomRow
	for rows.Next() {
		var i write_blog_atomRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.Left,
			&i.Blog,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const write_blog_rss = `-- name: write_blog_rss :many
SELECT b.idblogs, LEFT(b.written, 255), b.blog, u.username
FROM blogs b, users u
WHERE u.idusers = b.users_idusers AND b.users_idusers= ?
ORDER BY b.written DESC
LIMIT ?
`

type write_blog_rssParams struct {
	UsersIdusers int32
	Limit        int32
}

type write_blog_rssRow struct {
	Idblogs  int32
	Left     string
	Blog     sql.NullString
	Username sql.NullString
}

func (q *Queries) write_blog_rss(ctx context.Context, arg write_blog_rssParams) ([]*write_blog_rssRow, error) {
	rows, err := q.db.QueryContext(ctx, write_blog_rss, arg.UsersIdusers, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*write_blog_rssRow
	for rows.Next() {
		var i write_blog_rssRow
		if err := rows.Scan(
			&i.Idblogs,
			&i.Left,
			&i.Blog,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
